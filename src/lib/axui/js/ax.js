/*!
 *Last modified: 2023-06-11 23:29:08
 *Filename: ax.js
 *Description: Global JS
 *Version: v2.0.13
 *Website:www.axui.cn
 *Contact:3217728223@qq.com
 *Author:Michael
 */
/*!
 * 全局变量，至于ax.js头部，可全站使用
 */
'use strict';
/**
 * 定义常用错误提示 
 */
const axError = {
    formatError: 'This is not a valid data format!',
    paraError: 'The parameters do not meet the requirements!',
    arrayRequired: 'The value must be an array type!',
    noNode: 'This page can not find the node!',
    required: 'Required field is missing!',
    notExist: 'The program cannot be executed because the object does not exist!',
}
/**
 * 定义判断是否是移动端函数，返回true或false 
 */
const axIsMobi = () => {
    let userAgentInfo = navigator.userAgent;
    let mobileAgents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    for (let v = 0; v < mobileAgents.length; v++) {
        if (userAgentInfo.indexOf(mobileAgents[v]) > 0) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * 判断字符串是否为日期格式，返回true或false 
 * 2021-2-5,2021/2/5,2021,2021-2,2-5
 */
const axIsDate = (str) => {
    return isNaN(str) && !isNaN(Date.parse(str));
}
/**
 * 定义客户端函数，通过屏幕宽度判断是什么终端
 */
const axClient = () => {
    let screenWidth = window.screen.width;
    if (screenWidth < 500) {
        return 'phone';
    } else if (screenWidth > 500 && screenWidth < 900) {
        return 'pad';
    } else if (screenWidth > 900 && screenWidth < 1200) {
        return 'padflip';
    } else if (screenWidth > 1200 && screenWidth < 1500) {
        return 'padpro';
    } else {
        return 'pc';
    }
}
/**
 * 获得对象真正的类型
 * 可检测出Array,Object,Function,String,Number,Boolean,Date,Null,Undefined,HTMLDivElement(Dom节点都包含HTML)等
 */
const axType = (obj) => Object.prototype.toString.call(obj).slice(8, -1);
/**
 * 定义判断为空函数，可判断function(){}，0，''，[]，{}，undefined，null
 */
const axIsEmpty = (data) => {
    let type = axType(data);
    if (!data) {
        return true;
    } else if (type === 'Function') {
        return (data.toString().replace(/\s+/g, '').match(/{.*}/g)[0] == '{}');
    } else if (type === 'Array') {
        return data.join('') == '';
    } else if (type === 'Object') {
        return (Object.keys(data).length === 0)
    } else {
        return false;
    }
}
/**
 * 判断是否是虚拟节点，也就是仅存在内存当中并没有append到页面里
*/
const axIsVnode = (elem) => {
    return !getComputedStyle(elem).display;
}
/**
 * 去掉字符串的头尾空格，中间如果有空格则只保留一个
*/
const axTrim = (str, all = false) => {
    return all ? str.replace(/\s+/g, '') : str.trim().replace(/\s+/ig, ' ');
};
/**
 * 字符串根据分隔符转成数组
*/
const axSplitToArr = (data, separator = ',', space = 'all') => {
    let dataType = axType(data),
        spaceStr = '',
        dataArr = [];
    if (dataType === 'String') {
        if (space === 'one') {
            spaceStr = axTrim(data, false)
        } else if (space === 'none') {
            spaceStr = axTrim(data, true)
        } else {
            spaceStr = data.trim();
        }
        dataArr = spaceStr.split(separator);
    } else if (dataType === 'Array') {
        dataArr = data;
    }
    return dataArr;
};
/**
 * 阻止默认事件
*/
const axPreventDefault = (event) => {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}
/**
 * 取字符串，可向前取或向后取
*/
const axStrEnd = (str, key, type = 'afterend', inside = true) => {
    if (!str || !key) {
        return false;
    }
    str = str.trim();
    if (str.includes(key)) {
        let index, result, len = key.length;
        if (type === 'beforebegin') {
            index = str.indexOf(key);
            inside ? index += len : null;
            result = str.substring(0, index);
        } else if (type === 'afterbegin') {
            index = str.indexOf(key);
            !inside ? index += len : null;
            result = str.substring(index, str.length);
        } else if (type === 'beforeend') {
            index = str.lastIndexOf(key);
            inside ? index += len : null;
            result = str.substring(0, index);
        } else if (type === 'afterend') {
            index = str.lastIndexOf(key);
            !inside ? index += len : null;
            result = str.substring(index, str.length);
        } else {
            result = '';
        }
        return result;
    } else {
        return '';
    }
}
/**
 * 判断选择器类型
*/
const axStrType = (str) => {
    if (typeof str !== 'string') {
        console.error('Argument must be a string!')
        return false;
    }
    str = str.trim();
    let isUpperCase = (letter) => {
        if (letter >= 'A' && letter <= 'Z') {
            return true;
        }
    },
        type = '';
    if (str) {
        if (str.includes(' ')) {
            type = 'level';
        } else {
            if (str.startsWith('#')) {
                type = 'id';
            } else if (str.startsWith('.')) {
                type = 'class';
            } else if (str.startsWith('[') && str.endsWith(']')) {
                type = 'name';
            } else if ([...str].every(i => isUpperCase(i))) {
                type = 'node';
            }
        }
    }
    return type;
}
/**
 * 将字符串转成DOM对象，诸如<div>...</div>的字符串
 */
const axStrToDom = (str) => {
    if (typeof str != 'string') {
        return false;
    }
    str = str.trim();
    let wrapper;
    if (str.startsWith("<tr") || str.endsWith("</tr>")) {
        wrapper = document.createElement('tr');
        wrapper.innerHTML = str;
        return wrapper;
    } else {
        wrapper = document.createElement('div');
        wrapper.innerHTML = str;
        return wrapper.firstElementChild;
    }
}
/**
 * 将#id转成DOM，插件中常用
 */
const axIdToDom = (elem) => {
    let type = axType(elem);
    if (!elem) {
        console.warn('Node selector is empty!');
        return false;
    } else if (type === 'String') {
        let trim = elem.trim();
        if (axStrType(trim)) {
            if (axStrType(trim) === 'name' && !trim.includes('=')) {
                trim = trim.slice(0, 1) + 'name=' + trim.slice(1);
            }
            return document.querySelector(trim);
        } else {
            console.warn('No node is found with this string!');
            return false;
        }
    } else if (type.includes('HTML')) {
        return elem;
    } else {
        return false;
    }
}
/**
 * 将多种形式转成DOM数组，插件中常用
 */
const axAllToDoms = (data) => {
    if (axIsEmpty(data)) {
        return [];
    }
    let doms = [],
        type = axType(data);
    if (type.includes('HTML')) {
        doms.push(data);
    } else if (type === 'String') {
        let str = axTrim(data),
            separator = ',';
        if (str.includes(' ')) {
            separator = ' ';
        }
        str.split(separator).forEach(k => {
            let dom = axIdToDom(k);
            dom ? doms.push(dom) : null;
        });
    } else if (type === 'Array') {
        data.forEach(k => {
            let dom = axIdToDom(k);
            dom ? doms.push(dom) : null;
        });
    } else if (type === 'NodeList') {
        doms = [...data];
    }
    return doms;
}
/**
 * 将多种形态的字符串，对象等都转成数组格式
 * obj='a'/'a,b,c'/'a b c'/{}/0/1/[]
 */
const axValueToArr = (obj) => {
    let arr = [];
    if (!axIsEmpty(obj) || obj === 0) {
        if (Array.isArray(obj)) {
            arr = obj;
        } else if (typeof obj === 'string') {
            let str = obj.trim(),
                separator = obj.includes(',') ? ',' : ' ';
            if (str.includes(separator)) {
                arr = str.split(separator);
            } else {
                arr.push(obj);
            }
        } else {
            arr.push(obj);
        }
    }
    return arr;
}
/**
 * 从对象数组中去重，[{id:0,label:'a'},{id:0,label:'b'}]转为[{id:0,label:'a'}]
 * 如果prop为空则，对普通数组去重，[0,0,1,2]转为[0,1,2]
 */
const axUnique = (arr, prop) => {
    if (prop) {
        let map = new Map();
        for (let k of arr) {
            if (!map.has(k[prop])) {
                map.set(k[prop], k);
            }
        }
        return [...map.values()];
    } else {
        return [...new Set(arr)]
    }
}
/**
 * 对DOM节点进行class操作，支持get、add和remove三个方法
 */
const axClass = {
    get: function (classes) {
        return axValueToArr(classes);
    },
    add: function (obj, classes, before) {
        let dom = axIdToDom(obj),
            arr = this.get(classes);
        if (!dom || arr.length === 0) {
            return false;
        }
        arr.forEach(k => {
            let flag = before ? before(k) : true;
            flag ? dom.classList.add(k) : null;
        });
        return this;
    },
    del: function (obj, classes, before) {
        let dom = axIdToDom(obj),
            arr = this.get(classes);
        if (!dom || arr.length === 0) {
            return false;
        }
        arr.forEach(k => {
            let flag = before ? before(k) : true;
            flag ? dom.classList.remove(k) : null;
        });
        return this;
    }
}
/**
 * 将字符串转成数组继而转成Dom，诸如"#xxx,,yyy,DIV"这类参数型的字符串
 */
const axArrToDom = (str, parent) => {
    let arr = str.split(","),
        doms = [],
        reg = /^[0-9]*$/,
        _parent = '';
    if ((typeof parent) === 'string') {
        _parent = document.querySelector(parent);
    } else {
        _parent = parent;
    }
    arr.forEach(item => {
        if (reg.test(item.substr(0, 1))) {
            return;
        } else if (axStrType(item) == 'class') {
            if (_parent) {
                doms = doms.concat([..._parent.querySelectorAll(item)]);
            } else {
                doms = doms.concat([...document.querySelectorAll(item)]);
            }
        } else if (axStrType(item) == 'id') {
            doms.push(document.querySelector(item));
        } else if (item) {
            let nodes = document.querySelectorAll(item);
            if (nodes) {
                if (_parent) {
                    doms = doms.concat([..._parent.querySelectorAll(item)]);
                } else {
                    doms = doms.concat([...document.querySelectorAll(item)]);
                }
            }
        } else {
            return doms;
        }
    })
    return doms;
}
/**
 * 将带children属性的多维数组拍平为一维数组
*/
const axArrToFlat = (arr) => {
    let result = [],
        data = [...arr];
    data.forEach(i => {
        if (i.children) {
            result = [...result, i, ...axArrToFlat(i.children)];
        } else {
            result.push(i);
        }
    });
    return result;
}
/**
 * 根据现有数组获得新项目的ID（数组最大id或索引+1）
*/
const axIncreaseId = (data, hasId = true) => {
    let ids = [],
        newId;
    if (hasId) {
        data.forEach(i => {
            ids.push(~~i.id);
        });
        newId = Math.max(...ids) + 1;
    } else {
        newId = data.length;
    }
    return newId;
}
/**
 * 从表单控件取值，用于校验判断，适合的控件：checkbox、radio、select-multiple和file
*/
const axMultiValues = (name, type = 'checkbox', format = 'array', form, separator = ',') => {
    let inputs,
        values = [],
        parent = form ? axIdToDom(form) : '';
    if (axType(name) == 'NodeList' || axType(name) == 'Array') {
        if (type.includes('select') || type == 'file') {
            console.warn('Can not be an node array in this type!');
            return false;
        }
        inputs = name;
    } else if (typeof name == 'object' || (axStrType(name) && axStrType(name) !== 'name')) {
        let dom = axIdToDom(name);
        if (type.includes('select') || name.nodeName == 'SELECT') {
            type = 'select';
            inputs = dom.options;
        } else if (type == 'file' || dom.type == 'file') {
            type = 'file';
            inputs = [dom];
        } else {
            inputs = [...dom.querySelectorAll('input')];
        }
    } else {
        let selector = '';
        if (axStrType(name) === 'name') {
            selector = name.replace('[', '[name=');
        } else {
            selector = `[name=${name}]`;
        }
        if (type.includes('select')) {
            inputs = parent ? parent.querySelector(selector).options : document.querySelector(selector).options;
        } else if (type == 'file') {
            inputs = parent ? [parent.querySelector(selector)] : [document.querySelector(selector)];
        } else {
            inputs = parent ? [...parent.querySelectorAll(selector)] : [...document.querySelectorAll(selector)];
        }
    }
    for (let i = 0; i < inputs.length; i++) {
        let condition,
            item = inputs[i];
        if (type.includes('select')) {
            condition = item.selected;
        } else {
            condition = item.checked;
        }
        if (type == 'file') {
            values = [...item.files];
        } else {
            if (condition) {
                values.push(item.value);
            }
        }
    }
    if (format == 'string') {
        values = values.join(separator)
    }
    return values;
}
/**
 * 防抖函数
 * 使用表现：持续输入后延迟执行
*/
const axDebounce = (fn, delay = 200) => {
    let timer = null,
        handler = function () {
            if (timer) clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(this, arguments);
            }, delay);
        }
    handler.cancel = function () {
        if (timer) clearTimeout(timer);
    }
    return handler;
}
/**
 * 节流函数
 * 使用表现：持续点击多次也只会按固定间隔时间执行
*/
const axThrottle = (fn, interval = 500) => {
    let last = 0,
        timer = null,
        handler = function () {
            let now = new Date().getTime();
            if (now - last > interval) {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                fn.apply(this, arguments);
                last = now;
            } else if (timer === null) {
                timer = setTimeout(() => {
                    timer = null;
                    fn.apply(this, arguments);
                }, interval);
            }
        }
    handler.cancel = function () {
        clearTimeout(timer);
        timer = null;
    }
    return handler;
}
/**
 * 数组元素移动位置
 */
const axMoveArr = (arr, from, to) => {
    if (from > arr.length || to > arr.length || from < 0 || to < 0) {
        console.error('Exceeded array length!');
        return false;
    }
    let obj = arr[from];
    arr.splice(from, 1);
    arr.splice(to, 0, obj);
    return arr;
}
/**
 * 判断元素以及其父元素是否可见
 */
const axIsVisible = (element) => {
    let elem = axIdToDom(element),
        loopable = true,
        visible = getComputedStyle(elem).display != 'none' && getComputedStyle(elem).visibility != 'hidden';
    while (loopable && visible) {
        elem = elem.parentNode;
        if (elem && elem != document.body) {
            visible = getComputedStyle(elem).display != 'none' && getComputedStyle(elem).visibility != 'hidden';
        } else {
            loopable = false;
        }
    }
    return visible;
}
/**
 * 判断在元素在其父元素中是否可见，要求父元素position必须为absolute/fixed/relative，否则会判断出错
 */
const axChildVisible = (child, parent) => {
    let parentDom = axIdToDom(parent),
        childDom = axIdToDom(child),
        parentScroll = parentDom.scrollTop,
        parentHeight = parentDom.getBoundingClientRect().height;
    return (childDom.offsetTop + childDom.offsetHeight > parentScroll) && (childDom.offsetTop < parentScroll + parentHeight);
};
/**
 * 在某div中使用滚轮，整个页面不滚动
 */
const axPreventScroll = (prevent, scroll) => {
    let preventDom = prevent ? axIdToDom(prevent) : null,
        scrollDom = scroll ? axIdToDom(scroll) : null,
        scrollAmount = 60,
        scrollObj = navigator.userAgent.indexOf("Firefox") > 0 ? { event: 'DOMMouseScroll', detail: 'detail' } : { event: 'mousewheel', detail: 'wheelDelta' },
        scrollFun = (elem) => {
            if (elem && elem.scrollHeight > elem.clientHeight) {
                elem.addEventListener(scrollObj.event, (e) => {
                    elem.scrollTop += e[scrollObj.detail] > 0 ? -scrollAmount : scrollAmount;
                }, false);
            }
        };
    if (navigator.userAgent.indexOf("Firefox") > 0) {
        scrollAmount = -60,
            preventDom.addEventListener(scrollObj.event, (e) => {
                e.preventDefault();
            }, false);
        if (!scrollDom) {
            scrollFun(preventDom);
        } else {
            scrollFun(scrollDom);
        }
    } else {
        preventDom.addEventListener(scrollObj.event, (e) => {
            e = e || window.event;
            e.returnValue = false;
        }, false);
        if (!scrollDom) {
            scrollFun(preventDom);
        } else {
            scrollFun(scrollDom);
        }
    }
    return this;
}
const axUlToArr = (element, start = 0, replace = true) => {
    let elem = axIdToDom(element),
        newId = start;
    if (!element) { console.error(axError.notExist); return false; }
    let getChild = () => {
        let data = [];
        [...elem.children].forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    },
        getAttrs = (node, obj) => {
            let attrs = [...node.attributes].filter(k => k.name !== 'label' && k.name !== 'value');
            attrs.forEach(k => {
                if (['selected', 'disabled', 'readonly', 'active', 'checked', 'expanded'].includes(k.name)) {
                    obj[k.name] = true;
                } else {
                    obj[k.name] = k.value.trim();
                }
            });
        };
    let getJson = (elem, index) => {
        let node = elem.firstElementChild,
            obj = { id: index, node: node };
        obj.label = node.textContent.trim();
        if (replace) {
            obj.value = node.hasAttribute('value') ? node.getAttribute('value') : obj.label;
        } else {
            node.hasAttribute('value') ? obj.value = node.getAttribute('value') : null;
        }
        getAttrs(node, obj);
        let parent = elem.querySelector('ul') || elem.querySelector('ol');
        if (parent) {
            obj.children = [];
            [...parent.children].forEach(item => {
                obj.children.push(getJson(item, newId++));
            });
        }
        return obj;
    }
    return { data: getChild(), index: newId };
}
/**
 * 将下拉菜单Dom树转成对象数组格式：[{id:'',label:'',value:''},{id:'',label:'',value:''}...]
 */
const axSelectToArr = (element, start = 0, replace = true) => {
    let elem = axIdToDom(element),
        newId = start;
    if (!elem) { console.error(axError.notExist); return false; }
    let getChild = () => {
        let data = [];
        [...elem.children].forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    },
        getAttrs = (node, obj) => {
            let attrs = [...node.attributes].filter(k => k.name !== 'label' && k.name !== 'value');
            attrs.forEach(k => {
                if (['selected', 'disabled', 'readonly', 'active', 'checked', 'expanded'].includes(k.name)) {
                    obj[k.name] = true;
                } else {
                    obj[k.name] = k.value.trim();
                }
            });
        };
    let getJson = (elem, index) => {
        let obj = { id: index, node: elem },
            label = elem.textContent.trim(),
            value = elem.hasAttribute('value') ? elem.getAttribute('value').trim() : '';
        getAttrs(elem, obj);
        if (elem.nodeName == 'OPTGROUP') {
            obj.label = elem.getAttribute('label').trim();
            obj.value = obj.label;
            obj.children = [];
            [...elem.children].forEach(item => {
                obj.children.push(getJson(item, newId++));
            });
        } else {
            obj.label = label ? label : value.trim();
            if (replace) {
                obj.value = value ? value : obj.label;
            } else {
                obj.value = value;
            }
        }
        return obj;
    }
    return { data: getChild(), index: newId };
}
/**
 * 从table数据转成二维数组格式：[['','',...],...]
 * element为table标签
 */
const axTableToJson = (element) => {
    let elem = axIdToDom(element),
        tbody = elem.querySelector('tbody'),
        rows = tbody.rows,
        rowArr = [];
    [...rows].forEach((i) => {
        let tds = i.cells,
            tdArr = [];
        [...tds].forEach((k) => {
            tdArr.push(k.innerText.trim());
        });
        rowArr.push(tdArr);
    });
    return rowArr;
}
/**
 * 一维数组转tree数组，root为顶级id，通常是-1或0
 */
const axArrToTree = (arr) => {
    let root = arr[0].pId;
    arr.forEach(k => {
        let children = arr.filter(i => k.id == i.pId);
        if (children.length) {
            k.children = children;
        }
    });
    return arr.filter(k => k.pId == root);
}
/**
 * 使用任意值找到一项，可以是一个对象、数字、字符串或节点
 */
const axFindItem = (obj, data, map) => {
    let type = axType(obj),
        propMap = Object.assign({ string: 'label', number: 'id', dom: 'headerDom' }, map),
        result,
        objFind = (value, list) => {
            let keys = Object.keys(value),
                item = list.find(k => {
                    let flag = true;
                    for (let v of keys) {
                        if (k[v] != value[v]) {
                            flag = false;
                            break;
                        }
                    }
                    return flag
                });
            return item;
        };
    if (type === 'Object') {
        result = data.find(k => k === obj) || objFind(obj, data);
    } else if (type === 'Array') {
        result = data.find(k => k === obj);
    } else if (type === 'Number') {
        if (data[0].hasOwnProperty(propMap.number)) {
            result = data.find(k => String(k[propMap.number]) === String(obj));
        } else {
            result = data[obj];
        }
    } else if (type === 'String') {
        if (obj.startsWith('#')) {
            result = data.find(k => '#' + k[propMap.dom].id === obj);
        } else {
            result = data.find(k => String(k[propMap.number]) === obj || String(k[propMap.string]) === obj);
        }
    } else if (type.includes('HTML')) {
        result = data.find(k => k[propMap.dom] === obj);
    } else {
        result = false;
    }
    return result;
}
/**
 * 将创建tree的数据对象push到数组里和节点里
 */
const axTreeMethod = {
    addPath: (data, rootStart = -1, idStart = 0) => {
        if (!Array.isArray(data) || data.length === 0) {
            return false;
        }
        let floorMax = 0,
            idMax = 0,
            hasId = data[0].hasOwnProperty('id') ? true : false,
            index = idStart,
            each = (data, floor, path = rootStart) => {
                data.forEach(item => {
                    if (!hasId) {
                        item.id = index;
                        index++;
                    }
                    item.floor = floor;
                    item.pId = item.pId || item.pId === 0 ? item.pId : rootStart;
                    floor >= floorMax ? floorMax = floor : null;
                    if (!isNaN(item.id)) {
                        item.id >= idMax ? idMax = item.id : null;
                    }
                    if (item.children && item.children.length > 0) {
                        let nextPath = path.toString() + '>' + item.id.toString();
                        item.children.forEach(k => {
                            k.path = nextPath + '>' + k.id;
                            k.pId = item.id;
                        });
                        each(item.children, floor + 1, nextPath);
                    }
                    if (!item.path) {
                        item.path = item.pId + '>' + item.id;
                    }
                });
            }
        each(data, 1);
        return { data, floorMax, idMax };
    },
    remove: (item, flat, tree, callback) => {
        if (item.floor !== 1) {
            let parent = flat.find(k => k.id == item.pId),
                children = parent.children,
                index = children.indexOf(item);
            children.splice(index, 1);
        } else {
            tree ? tree = tree.filter(k => k != item) : null;
        }
        flat = flat.filter(k => k !== item && !k.path.includes('>' + item.id + '>'));
        item.wrapperDom.remove();
        callback && callback(item, flat);
        return { flat, tree };
    },
    createData: (source, target, flat, isChild) => {
        let obj = {},
            sourceType = axType(source),
            newId = axIncreaseId(flat),
            newLabel = sourceType === 'String' ? source : '新节点' + newId;
        if (sourceType === 'Object') {
            let attrs = isChild ? {
                path: target.path + '>' + source.id,
                floor: target.floor + 1
            } : {
                path: target.path.replace(new RegExp('(.*)' + target.id), '$1' + source.id),
                floor: target.floor
            };
            !source.hasOwnProperty('id') ? source.id = newId : null;
            obj = Object.assign(source, attrs);
        } else {
            obj = isChild ? {
                id: newId,
                label: newLabel,
                pId: target.id,
                path: target.path + '>' + newId,
                floor: target.floor + 1
            } : {
                id: newId,
                label: newLabel,
                pId: target.pId,
                path: target.path.replace(new RegExp('(.*)' + target.id), '$1' + newId),
                floor: target.floor
            };
        }
        return obj;
    },
    existChildPush: (source, target, isFront = true) => {
        if (isFront) {
            target.children.unshift(source);
            target.bodyDom.insertAdjacentElement('afterBegin', source.wrapperDom);
        } else {
            target.children.push(source);
            target.bodyDom.insertAdjacentElement('beforeEnd', source.wrapperDom);
        }
    },
    noExistChildPush: (source, target, childToParent) => {
        target.children = [];
        target.children.push(source);
        target = childToParent(target);
        target.bodyDom.appendChild(source.wrapperDom);
        target.wrapperDom.appendChild(target.bodyDom);
    },
}
axTreeMethod.fullData = async (opt = {}) => {
    if (axIsEmpty(opt.source)) {
        return false;
    }
    let dataType = axType(opt.source),
        options = Object.assign({ idStart: 0, rootStart: -1, replace: false, ajaxData: {}, ajaxType: 'post', async: false, addPath: true }, opt),
        treeData = [],
        result = {},
        getFromNode = (node) => {
            let nodeName = node.nodeName, arr = [];
            if (nodeName === 'SELECT' || nodeName === 'DATALIST') {
                arr = axSelectToArr(node, options.idStart, options.replace).data;
            } else if (nodeName === 'UL' || nodeName === 'OL') {
                arr = axUlToArr(node, options.idStart, options.replace).data;
            }
            return arr;
        },
        getFromArray = (data) => {
            let arr = [], copyData = axClone(data);
            if (copyData[0].hasOwnProperty('pId') && copyData[0].hasOwnProperty('id')) {
                arr = axArrToTree(copyData);
            } else {
                arr = copyData;
            }
            return arr;
        };
    !axIsEmpty(options.ajaxData) ? options.async = true : null;
    if (options.async) {
        let loadDom = options.source.loadDom ? axIdToDom(options.source.loadDom) : null;
        await axAjax({
            url: options.source,
            data: !axIsEmpty(options.ajaxData) ? options.ajaxData : '',
            type: options.ajaxType,
            opened: (response) => {
                if (options.opened) {
                    options.opened(response);
                } else {
                    options.instance && options.xhrName ? options.instance[options.xhrName] = response.xhr : null;
                }
            },
            before: (response) => {
                if (options.before) {
                    options.before(response);
                } else {
                    loadDom ? loadDom.setAttribute('loading', '') : null;
                }
            },
            success: (response) => {
                if (axIsEmpty(response.content)) {
                    console.warn('No data obtained!');
                    return false;
                }
                loadDom && loadDom.hasAttribute('loading') ? loadDom.removeAttribute('loading') : null;
                options.success && options.success(response);
                treeData = getFromArray(response.content);
            }
        });
    }
    else {
        if (dataType.includes('HTML')) {
            treeData = getFromNode(options.source);
        } else if (dataType === 'String') {
            if (axStrType(options.source)) {
                treeData = getFromNode(axIdToDom(options.source));
            }
        } else if (dataType === 'Array') {
            treeData = getFromArray(options.source);
        }
    }
    result = options.addPath ? axTreeMethod.addPath(treeData, options.rootStart, options.idStart) : treeData;
    options.callback && options.callback(result);
    return result;
}
/**
 * 日期相关工具
 */
const axDateMethod = {};
axDateMethod.toSlash = (dateObj) => {
    return dateObj.replace('-', '/');
}
axDateMethod.toDate = (dateObj, type) => {
    let dateType = axType(dateObj),
        date;
    if (dateType === 'Date') {
        date = new Date(dateObj.valueOf());
    } else if (dateType === 'String') {
        date = new Date(axDateMethod.toSlash(dateObj));
    } else if (dateType === 'Object') {
        date = new Date();
        dateObj.hasOwnProperty('YYYY') ? date.setFullYear(dateObj.YYYY) : null;
        dateObj.hasOwnProperty('MM') ? date.setMonth(dateObj.MM) : null;
        dateObj.hasOwnProperty('DD') ? date.setDate(dateObj.DD) : null;
        dateObj.hasOwnProperty('hh') ? date.setHours(dateObj.hh) : null;
        dateObj.hasOwnProperty('mm') ? date.setMinutes(dateObj.mm) : null;
        dateObj.hasOwnProperty('ss') ? date.setSeconds(dateObj.ss) : null;
    } else {
        date = new Date();
    }
    if (type === 'date') {
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
    } else if (type === 'month') {
        date.setDate(1);
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
    } else if (type === 'year') {
        date.setMonth(0);
        date.setDate(1);
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
    }
    return date;
};
axDateMethod.toObj = (obj, fillTime = false, type) => {
    let objType = axType(obj),
        date,
        result = '';
    if (objType === 'Object') {
        result = obj;
    } else if (objType === 'String' && !obj.trim().includes(' ') && obj.includes(':')) {
        let timeStrArr = obj.split(':');
        result = { hh: ~~timeStrArr[0], mm: ~~timeStrArr[1], ss: ~~timeStrArr[2] };
    } else {
        date = axDateMethod.toDate(obj);
        result = { YYYY: date.getFullYear(), MM: date.getMonth(), DD: date.getDate(), hh: date.getHours(), mm: date.getMinutes(), ss: date.getSeconds() }
    }
    if (fillTime) {
        !result.hasOwnProperty('hh') ? result.hh = 0 : null;
        !result.hasOwnProperty('mm') ? result.mm = 0 : null;
        !result.hasOwnProperty('ss') ? result.ss = 0 : null;
    }
    if (type === 'year') {
        Reflect.deleteProperty(result, 'MM');
        Reflect.deleteProperty(result, 'DD');
        Reflect.deleteProperty(result, 'hh');
        Reflect.deleteProperty(result, 'mm');
        Reflect.deleteProperty(result, 'ss');
    } else if (type === 'month') {
        Reflect.deleteProperty(result, 'DD');
        Reflect.deleteProperty(result, 'hh');
        Reflect.deleteProperty(result, 'mm');
        Reflect.deleteProperty(result, 'ss');
    } else if (type === 'date') {
        Reflect.deleteProperty(result, 'hh');
        Reflect.deleteProperty(result, 'mm');
        Reflect.deleteProperty(result, 'ss');
    }
    return result;
}
axDateMethod.strToTimeObj = (str) => {
    str = str.replace(' ', '');
    let arr = str.split(':');
    return { hh: ~~arr[0] || 0, mm: ~~arr[1] || 0, ss: ~~arr[2] || 0 }
}
axDateMethod.getDays = (dateObj) => {
    let curDate = axDateMethod.toDate(dateObj),
        curYear = curDate.getFullYear(),
        curMonth = curDate.getMonth();
    return new Date(curYear, curMonth + 1, 0).getDate();
}
axDateMethod.getChain = (dateObj, options = { YYYY: 0, MM: 0, DD: 0, hh: 0, mm: 0, ss: 0 }) => {
    let curDate = axDateMethod.toDate(dateObj);
    options.hasOwnProperty('ss') ? curDate.setDate(curDate.getSeconds() + options.ss) : null;
    options.hasOwnProperty('mm') ? curDate.setDate(curDate.getMinutes() + options.mm) : null;
    options.hasOwnProperty('hh') ? curDate.setDate(curDate.getHours() + options.hh) : null;
    options.hasOwnProperty('DD') ? curDate.setDate(curDate.getDate() + options.DD) : null;
    options.hasOwnProperty('MM') ? curDate.setMonth(curDate.getMonth() + options.MM) : null;
    options.hasOwnProperty('YYYY') ? curDate.setFullYear(curDate.getFullYear() + options.YYYY) : null;
    return curDate;
}
axDateMethod.fillZero = (obj) => {
    let num = ~~obj;
    return num < 10 ? '0' + num : num;
}
axDateMethod.fillFormat = (date, format) => {
    let YYYY, MM, DD, hh, mm, ss, WW, weeks = ['日', '一', '二', '三', '四', '五', '六'];
    if (date instanceof Date) {
        YYYY = date.getFullYear();
        MM = date.getMonth() + 1;
        DD = date.getDate();
        hh = date.getHours();
        mm = date.getMinutes();
        ss = date.getSeconds();
        WW = date.getDay();
    } else {
        YYYY = date.YYYY;
        MM = date.MM + 1;
        DD = date.DD;
        hh = date.hh;
        mm = date.mm;
        ss = date.ss;
        date.hasOwnProperty('DD') ? WW = new Date(date.YYYY, date.MM, date.DD).getDay() : null;
    }
    format.includes('YYYY') ? format = format.replace('YYYY', YYYY) : null;
    format.includes('MM') ? format = format.replace('MM', axDateMethod.fillZero(MM)) : null;
    format.includes('DD') ? format = format.replace('DD', axDateMethod.fillZero(DD)) : null;
    format.includes('hh') ? format = format.replace('hh', axDateMethod.fillZero(hh)) : null;
    format.includes('mm') ? format = format.replace('mm', axDateMethod.fillZero(mm)) : null;
    format.includes('ss') ? format = format.replace('ss', axDateMethod.fillZero(ss)) : null;
    format.includes('WW') && WW !== undefined ? format = format.replace('WW', weeks[WW]) : null;
    return format;
}
axDateMethod.sort = (data) => {
    return data.sort((a, b) => { return axDateMethod.toDate(a) - axDateMethod.toDate(b) });
}
axDateMethod.trim = (str) => {
    return str.trim().replace(/\s+/ig, ' ');
};
axDateMethod.type = (format) => {
    let type = '';
    if (RegExp(/^(?=.*YYYY)(?=.*MM)(?=.*DD)(?=.*hh).*$/).test(format)) {
        type = 'datetime';
    } else if (RegExp(/^(?=.*YYYY)(?=.*MM)(?=.*DD).*$/).test(format)) {
        type = 'date';
    } else if (RegExp(/^(?=.*YYYY)(?=.*MM).*$/).test(format)) {
        type = 'month';
    } else if (RegExp(/^(?=.*YYYY).*$/).test(format)) {
        type = 'year';
    } else if (RegExp(/^(?=.*hh).*$/).test(format)) {
        type = 'time';
    }
    return type;
};
axDateMethod.isSameDay = (a, b) => {
    let x = { ...a },
        y = { ...b };
    Reflect.deleteProperty(x, 'hh');
    Reflect.deleteProperty(x, 'mm');
    Reflect.deleteProperty(x, 'ss');
    Reflect.deleteProperty(y, 'hh');
    Reflect.deleteProperty(y, 'mm');
    Reflect.deleteProperty(y, 'ss');
    return JSON.stringify(x) == JSON.stringify(y);
}
/**
 * 判断是否在元素矩形区域之外
 */
const axIsOutside = (ev, id, ox, oy) => {
    if (!id) { return true }
    let elem = axIdToDom(id);
    if (!elem) { return true }
    let x = ev.clientX,
        y = ev.clientY,
        x1, y1, x2, y2;
    ox ? x1 = ox : x1 = elem.getBoundingClientRect().left;
    oy ? y1 = oy : y1 = elem.getBoundingClientRect().top;
    x2 = x1 + elem.offsetWidth;
    y2 = y1 + elem.offsetHeight;
    return (x < x1 || x > x2 || y < y1 || y > y2) ? true : false;
}
/**
 * 封装getComputedStyle方法
 */
const axStyle = (elem, pseudo) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    return document.defaultView.getComputedStyle(element, pseudo);
}
/**
 * 定义模板引擎
 */
const axTplEngine = (html, data) => {
    if (!html) { console.error('No html!'); return false; }
    let re = /<#([^#>]+)?#>/g,
        reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,
        code = 'let r=[];\n',
        cursor = 0;
    let match;
    let add = (line, js) => {
        js ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
            (code += line != '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
        return add;
    }
    while (match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += 'return r.join("");';
    return new Function(code.replace(/[\r\t\n]/g, '')).apply(data);
}
/**
 * 定义深度拷贝函数
 */
const axClone = (data) => {
    let cloneObj = (obj) => {
        if (obj === null) {
            return null;
        } else if (typeof obj !== 'object') {
            return obj;
        } else if (obj.constructor === Date) {
            return new Date(obj);
        } else {
            let newObj = {};
            for (let k in obj) {
                if (obj[k] == null) {
                    newObj[k] = null;
                } else if ((typeof obj[k]) == 'object' && !obj[k].nodeType) {
                    newObj[k] = axClone(obj[k]);
                    if (obj[k] instanceof Array) {
                        let newArray = [];
                        for (let i of obj[k]) {
                            newArray.push(axClone(i));
                        }
                        newObj[k] = newArray;
                    }
                } else {
                    newObj[k] = obj[k];
                }
            }
            return newObj;
        }
    }
    if (Array.isArray(data)) {
        return data.map(k => cloneObj(k));
    } else {
        return cloneObj(data);
    }
};
/**
 * 定义合并属性递归函数
 */
const axMerge = (target, source, option = { arrAppend: false, clone: false, attrAppend: true }) => {
    if (typeof target != 'object' || typeof source != 'object') {
        return source;
    }
    if (!source) {
        return target;
    }
    let obj = option.copy ? axClone(target) : target;
    for (let k in source) {
        if (source.hasOwnProperty(k) && obj.hasOwnProperty(k)) {
            if (axType(source[k]) != 'Array') {
                obj[k] = axMerge(obj[k], source[k], option);
            } else {
                if (option.arrAppend) {
                    obj[k].push(...source[k]);
                } else {
                    obj[k] = source[k];
                }
            }
        } else if (source.hasOwnProperty(k) && !obj.hasOwnProperty(k) && option.attrAppend) {
            obj[k] = source[k];
        }
    }
    return obj;
}
/**
 * 字符串转成数组，'[]'，'{"":""},{"":""}'，'a,b,c'均转成数组
 */
const axStrToArr = (string, dftAttr, dftValue) => {
    let array = [],
        dft = {};
    if (!axIsEmpty(dftAttr)) {
        dftAttr.forEach((item, index) => {
            dft[item] = !axIsEmpty(dftValue) ? dftValue[index] : '';
        })
    }
    if (string.substr(0, 1) == '[' && string.substr(-1) == ']') {
        array = JSON.parse(string);
    } else if (string.replace(/\s*/g, "").indexOf('},{') != -1) {
        array = JSON.parse('[' + string + ']');
    } else if (string.replace(/\s*/g, "").substr(0, 1) == '{' && string.replace(/\s*/g, "").substr(-1) == '}') {
        array = JSON.parse('[' + string + ']');
    } else {
        array = string.split(',');
        array.forEach((item, index) => {
            item = item.trim();
            if (typeof item == 'string' && !axIsEmpty(dftAttr)) {
                let obj = {};
                dftAttr.forEach((str, i) => {
                    if (i == 0) {
                        obj[str] = item;
                    } else {
                        obj[str] = '';
                    }
                });
                array.splice(index, 1, obj)
            }
        });
    }
    array.forEach(item => {
        if (!axIsEmpty(dft)) {
            for (let k in dft) {
                if (!item.hasOwnProperty(k)) {
                    item[k] = dft[k] ? dft[k] : '';
                } else if (item.hasOwnProperty(k) && !item[k]) {
                    item[k] = dft[k];
                }
            }
        }
    })
    return array;
}
/**
 * HTML模板转成数组，支持列表循环
 */
const axTplToArr = (template, roles, keys, itemNode, dft) => {
    let tplDom = axIdToDom(template),
        data = [];
    if (itemNode) {
        let items = tplDom.querySelectorAll(itemNode);
        items.forEach(item => {
            let obj = {};
            roles.forEach((i, index) => {
                let child = item.querySelector('[' + i + ']');
                if (child) {
                    obj[keys[index]] = child.getAttribute(i) ? child.getAttribute(i).trim() : child.innerHTML.trim();
                } else {
                    obj[keys[index]] = dft[index] || '';
                }
            })
            data.push(obj);
        })
    } else {
        let obj = {};
        roles.forEach((i, index) => {
            let child = tplDom.querySelector('[' + i + ']');
            if (child) {
                obj[keys[index]] = child.getAttribute(i) ? child.getAttribute(i).trim() : child.innerHTML.trim();
            } else {
                obj[keys[index]] = dft[index] || '';
            }
        })
        data.push(obj);
    }
    return data;
}
/**
 * 将元素data-*属性与对象合并为新对象；
 * 1、先将对象obj复制保存为copy；
 * 2、将复制的对象name全转成小写；
 * 3、将data-*属性存为三层结构的对象，name均为小写并与copy合并；
 * 4、将合并后的copy与原obj对照还原大写name，并最终输出合并后的obj
 */
const axDataset = (element, obj) => {
    let elem = element ? axIdToDom(element) : null;
    let integer = /^\d+(\.\d+)?$/; 
    let float = /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; 
    if (elem) {
        let attrs = [...elem.attributes].filter((child) => {
            return child.name.indexOf('data-') == 0;
        });
        if (!axIsEmpty(attrs)) {
            let lowerDft = axClone(obj);
            let loopLow = (arg) => {
                for (let k in arg) {
                    let lower = k.toLowerCase();
                    arg[lower] = arg[k];
                    if (axType(arg[k]) === 'Object') {
                        loopLow(arg[k]);
                    }
                    if (lower != k) {
                        delete arg[k];
                    }
                }
            }
            loopLow(lowerDft);
            for (let k = 0; k < attrs.length; k++) {
                let value = attrs[k].value.trim(),
                    name = attrs[k].name;
                if (value == 'true') {
                    value = JSON.parse('true');
                } else if (value == 'false') {
                    value = JSON.parse('false');
                } else if (value == 'null') {
                    value = null;
                } else if (value.substr(0, 1) == '[' && value.substr(-1) == ']') {
                    value = JSON.parse(value);
                } else if (value.replace(/\s*/g, "").indexOf('},{') != -1) {
                    value = JSON.parse('[' + value + ']');
                }
                if (typeof value == 'string' && (integer.test(value) || float.test(value))) {
                    value = Number(value);
                }
                let split = name.split('-');
                if (split.length - 1 == 1) {
                    lowerDft[split[1]] = value
                } else if (split.length - 1 == 2) {
                    lowerDft[split[1]][split[2]] = value
                } else if (split.length - 1 == 3) {
                    lowerDft[split[1]][split[2]][split[3]] = value
                } else {
                    console.error('Three levels are supported!');
                }
            }
            let loopBack = (arg, opt) => {
                for (let k in arg) {
                    let lower = k.toLowerCase();
                    if (axType(arg[k]) === 'Object') {
                        loopBack(arg[k], opt[lower]);
                    } else {
                        arg[k] = opt[lower];
                    }
                }
            }
            loopBack(obj, lowerDft);
        }
    }
    return obj;
}
/**
 * 将元素ax*属性值得字符串形式转为对象形式
 */
const axAttrToJson = (elem, attr) => {
    let dom = axIdToDom(elem);
    if (!dom) {
        console.warn('The attribute node does not exist!');
        return {};
    }
    let domAttr = dom.getAttribute(attr);
    if (!attr || !domAttr) {
        return {};
    }
    if (!domAttr.includes(':')) {
        return {};
    }
    let text = domAttr.trim();
    if (!text.startsWith('{')) {
        text = '{' + text + '}';
    }
    return new Function('return ' + text)();
}
/* let obj = {
    name: 'Mick',
    sex: 'male',
    school: {
        no: 'NO.5665',
        city: 'shenzhen',
        tel: '13800138000',
        zip: '518000'
    },
    teachers: {
        mathematics: {
            name: 'Lily',
            age: 29,
            sex: 'female',
        },
        physics: {
            name: 'Bob',
            age: 33,
            sex: 'male',
        },
    },
    callback: () => { },
} */
/**
 * 定义对象扩展
 * user属性可覆盖dft属性，并自动合并为新的dft 
 * DOM的data-*属性级别最高，使用短横“-”区分属性层级，最多允许使用三个短横
 * 举例说明： <button data-name="" data-school="" data-teachers-mathematics-name=""></button>
 */
const axExtend = (dft, user, element, attr) => {
    if (!dft) { console.error(axError.notExist); return false; }
    let elem = element ? axIdToDom(element) : null;
    axMerge(dft, user);
    elem ? axMerge(dft, axAttrToJson(elem, attr)) : null;
    return dft;
}
/**
 * 定义监听事件函数(观察者模式)
 */
const axAddPlan = (type, handler, instance) => {
    if (!instance.handlers.hasOwnProperty(type)) {
        instance.handlers[type] = [];
    }
    let strHandle = handler.toString().replace(/\s/g, '').replace(/\;/g, '').match(/{(\S*)}/)[1],
        strHandles = instance.handlers[type].toString().replace(/\s/g, '').replace(/\;/g, '');
    strHandles.indexOf(strHandle) > -1 ? null : instance.handlers[type].push(handler);
}
const axExePlan = (type, instance, ...params) => {
    if (!instance.handlers.hasOwnProperty(type)) {
        return console.warn(`The ${type} event is unregistered or unusable!`);
    }
    instance.handlers[type].forEach(handler => {
        handler.call(instance, ...params);
    });
}
const axDelPlan = (type, handler, instance) => {
    if (!instance.handlers.hasOwnProperty(type)) {
        return console.warn(`The ${type} event is invalid or unusable!`);
    }
    if (!handler) {
        delete instance.handlers[type];
    } else {
        let index = instance.handlers[type].findIndex(elem => elem === handler)
        if (index === undefined) {
            return console.warn(`The ${type} event is not bound!`);
        }
        instance.handlers[type].splice(index, 1);
        if (instance.handlers[type].length === 0) {
            delete instance.handlers[type];
        }
    }
}
/**
 * 新增一个节点元素
 */
const axAddElem = (node, options, content) => {
    node.toLowerCase();
    let _node = document.createElement(node);
    if (options) {
        for (let k in options) {
            _node.setAttribute(k, options[k])
        }
    }
    let loop = function (node, content) {
        if (!content) {
            return false;
        }
        if (Array.isArray(content)) {
            if (content.length > 0) {
                content.forEach(i => {
                    loop(node, i);
                });
            }
        } else {
            if (typeof content == 'object') {
                node.appendChild(content);
            } else {
                node.insertAdjacentHTML('beforeEnd', content);
            }
        }
    }
    loop(_node, content);
    return _node;
}
/**
 * 字符串转筛选语句返回筛选结果
 */
const axStrToFilter = (str, source, callback) => {
    let text = `source.filter(item =>${str})`,
        result = new Function('source', 'return ' + text)(source);
    callback && callback(result);
    return result;
}
/**
 * 替换字符串某位置的字符
 */
const axRangeReplace = (originText, replaceText, indexStart, indexStop, n) => {
    if (typeof originText !== 'string') {
        originText = JSON.stringify(originText);
    }
    if (typeof replaceText !== 'string') {
        originText = JSON.stringify(replaceText);
    }
    let result = '';
    if (!indexStart && !indexStop) {
        result = replaceText;
    } else if (!indexStop) {
        if (n) {
            result = originText.substring(0, indexStart) + replaceText + originText.substring(indexStart + n);
        } else {
            result = originText.substring(0, indexStart) + replaceText;
        }
    } else if (!indexStart) {
        if (n) {
            result = originText.substring(indexStop - n) + replaceText + originText.substring(0, indexStart);
        } else {
            result = replaceText + originText.substring(indexStop);
        }
    } else {
        result = originText.substring(0, indexStart) + replaceText + originText.substring(indexStop);
    }
    return result;
}
const axArrange = (origin, n, index = 0, splice = [], result = []) => {
    let arrayLen = origin.length
    if (index + n > arrayLen) {
        return;
    }
    for (let i = index; i < arrayLen; i++) {
        if (n === 1) {
            result.push([...splice, origin[i]])
            i + 1 < arrayLen && axArrange(origin, n, i + 1, splice, result)
            break;
        }
        axArrange(origin, n - 1, i + 1, [...splice, origin[i]], result)
    }
    return result;
}
/**
 * 定义AJAX函数，异步获取内容
 */
const axAjax = (option, elem, callback) => {
    if (!option) { console.error('There is no options!'); return false; }
    let label = axAddElem('SPAN', { 'ajax-message': '' }),
        dom = elem ? axIdToDom(elem) : null;
    dom ? dom.appendChild(label) : null;
    let dft = {
        url: '',
        selector: '',
        type: 'post',
        async: true,
        data: {},
        delay: 60000,
        contentType: '',
        headers: {},
        responseType: '',
        catchable: false,
        abort: () => {
            dom ? (label.innerHTML = '<i class="ax-color-warning">中止了请求！</i>', dom.setAttribute('ajax-result', 'abort')) : console.error('中止了请求！');
        },
        timeout: () => {
            dom ? (label.innerHTML = '<i class="ax-color-danger">请求超时了！</i>', dom.setAttribute('ajax-result', 'timeout')) : console.error('请求超时了！');
        },
        loading: '<span class="ax-loading"><i></i></span>',
        opened: '',
        before: (response) => {
            dom ? (label.innerHTML = response.content, dom.setAttribute('ajax-result', 'before')) : null;
        },
        downloading: () => { },
        uploading: () => { },
        success: (response) => {
            dom ? (dom.innerHTML = response.content, dom.setAttribute('ajax-result', 'success')) : null;
        },
        error: (response) => {
            dom ? (label.innerHTML = `<i class="ax-color-danger">错误状态：${response.status}</i>`, dom.setAttribute('ajax-result', 'error')) : console.error(`错误状态：${response.status}`);
        },
    };
    for (let k in option) {
        dft[k] = option[k];
    }
    let xhr = '';
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    }
    else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
    }
    let params = '';
    if (axType(dft.data) == 'FormData') {
        params = dft.data;
    } else if (axType(dft.data) == 'Object') {
        if (dft.contentType.includes('json')) {
            params = JSON.stringify(dft.data);
        } else {
            for (let k in dft.data) {
                params += '&' + k + '=' + dft.data[k];
            }
            dft.contentType = 'application/x-www-form-urlencoded';
        }
    } else {
        dft.data = dft.data.trim();
        params = !dft.data.startsWith('&') ? dft.data : dft.data.slice(1);
        dft.contentType = 'application/x-www-form-urlencoded';
    }
    dft.headers['Content-Type'] = dft.contentType;
    if (!dft.contentType.includes('urlencoded') && dft.type.toLowerCase() == 'get') {
        console.error('Please request data with post!');
        return false;
    }
    let setHeader = () => {
        for (let k in dft.headers) {
            dft.headers[k] ? xhr.setRequestHeader(k, dft.headers[k]) : null;
        }
    },
        timeoutFun;
    xhr.timeout = dft.delay;
    xhr.responseType = dft.responseType;
    let abort = () => {
        timeoutFun ? xhr.removeEventListener('timeout', timeoutFun) : null;
        xhr.abort();
        !axIsEmpty(dft.abort) ? dft.abort(dom, xhr) : null;
    }
    let promise = new Promise((resolve, reject) => {
        let progress = (e, callback) => {
            let current = e.loaded,
                total = e.total,
                ratio = 0,
                percent = 0,
                result = '0%',
                time = (new Date(e.timeStamp)).getTime();
            if (e.lengthComputable) {
                ratio = current / total;
                percent = Math.round(ratio * 100);
                result = percent + '%';
                callback && callback({ result, percent, current, total, ratio, time, dom });
            }
        }
        xhr.upload.onprogress = (e) => {
            progress(e, (data) => {
                !axIsEmpty(dft.uploading) ? dft.uploading(data) : null;
            });
        }
        xhr.onprogress = (e) => {
            progress(e, (data) => {
                !axIsEmpty(dft.downloading) ? dft.downloading(data) : null;
            });
        }
        xhr.onerror = (e) => {
            let response = { content: xhr.response, status: xhr.status, dom, xhr }
            !axIsEmpty(dft.error) ? dft.error(response) : null;
            dft.catchable ? reject(response) : null;
        }
        timeoutFun = () => {
            let response = { content: xhr.response, status: xhr.status, dom, xhr }
            dom ? dom.setAttribute('ajax-result', 'timeout') : null;
            !axIsEmpty(dft.timeout) ? dft.timeout(response) : null;
            dft.catchable ? reject(response) : null;
        };
        xhr.addEventListener('timeout', timeoutFun);
        xhr.onreadystatechange = function () {
            if (xhr.readyState < 4) {
                let response = { content: dft.loading, status: xhr.status, dom, xhr, abort }
                if (xhr.readyState === 1) {
                    !axIsEmpty(dft.opened) ? dft.opened(response) : null;
                }
                !axIsEmpty(dft.before) ? dft.before(response) : null;
                callback && callback(response);
            } else {
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                    if (!dft.responseType || xhr.responseType == 'text') {
                        let div = document.createElement('div'),
                            content = '',
                            reg = /(<head\b[^<]*(?:(?!<\/head>)<[^<]*)*<\/head>)|(<\/?html.*?>)|(<\!DOCTYPE.*?html.*?>)|(<\/?body.*?>)/gi,
                            strEnd = axStrEnd(dft.url, '#'),
                            selector = dft.selector || strEnd;
                        div.innerHTML = xhr.responseText;
                        if (selector && div.querySelector(selector)) {
                            content = div.querySelector(selector).innerHTML;
                        } else if (selector && !div.querySelector(selector)) {
                            console.warn(`The node of "${selector}" is not exist!`);
                            content = xhr.responseText.replace(reg, '').trim();
                        } else {
                            if (xhr.responseText.trim().substr(0, 1) == "{" || xhr.responseText.trim().substr(0, 1) == "[") {
                                content = JSON.parse(xhr.responseText.trim());
                            } else {
                                content = xhr.responseText.replace(reg, '').trim();
                            }
                        }
                        dom ? dom.setAttribute('ajax-result', 'success') : null;
                        let response = { content, status: xhr.status, dom, xhr }
                        !axIsEmpty(dft.success) ? dft.success(response) : null;
                        resolve(response);
                    } else {
                        dom ? dom.setAttribute('ajax-result', 'success') : null;
                        let response = { content: xhr.response, status: xhr.status, dom, xhr }
                        !axIsEmpty(dft.success) ? dft.success(response) : null;
                        resolve(response);
                    }
                }
                else {
                    let response = { content: xhr.response, status: xhr.status, dom, xhr }
                    !axIsEmpty(dft.error) ? dft.error(response) : null;
                    dft.catchable ? reject(response) : null;
                }
            }
        };
        if (dft.type.toLowerCase() == 'get') {
            xhr.open('get', dft.url + '?now=' + new Date().getTime() + '&' + params, dft.async);
            setHeader();
            xhr.send();
        } else if (dft.type.toLowerCase() == 'post') {
            xhr.open('post', dft.url, dft.async);
            setHeader();
            xhr.send(params);
        }
    });
    promise.xhr = xhr;
    promise.abort = abort;
    return promise;
};
/**
 * ajax提交表单封装
 * url是异步提交地址，必填项
 * outer是form表单节点，必填项
 * target是点击的按钮，选填项
 * loading是缓冲加载显示位置，button是指在按钮上转圈（要求填写target），parent是指在form表单上转圈，选填项
 * type是指异步表单提交方式，默认post，可选择get，选填项
 * delay是指多久超时，单位毫秒，默认60秒
 * header是指设定请求头，数组格式，支持两种格式：['content-Type','']和[{name:'',value:''},...]
 * before是成功返回前的回调函数，选填项
 * success是成功返回后的回调函数，选填项
 */
const axAjaxSubmit = (url, outer, target, options = { type, success, loading, delay, before, error, opended, other }) => {
    if (!url) { console.error('Url is required!'); return false; }
    if (!outer) { console.error('Form node is required!'); return false; }
    options.type = options.type || 'post';
    options.other = options.other || {};
    let parentDom = axIdToDom(outer),
        targetDom = target ? axIdToDom(target) : null,
        targetText = targetDom ? targetDom.innerHTML : '',
        mode = options.loading || 'button',
        opt = Object.assign(options.other, {
            formClass: 'ax-form-submitting',
            buttonClass: 'ax-button-submitting',
            buttonText: '正在提交',
            overlayClass: 'ax-form-overlay',
            overlayShowClass: 'ax-show',
            successText: '恭喜！提交成功！',
            errorText: '对不起，提交失败！',
        }),
        overlayDom = parentDom.querySelector('.ax-form-overlay') ? parentDom.querySelector('.ax-form-overlay') : axAddElem('div', { class: 'ax-form-overlay' });
    if (parentDom.classList.contains(opt.formClass)) {
        return false;
    }
    if (targetDom && targetDom.classList.contains(opt.buttonClass)) {
        return false;
    }
    let formData = {}, promise;
    parentDom.querySelectorAll('[name]').forEach(function (item) {
        formData[item.getAttribute('name')] = item.value.trim();
    });
    promise = axAjax({
        url: url,
        data: formData,
        type: options.type,
        before: (response) => {
            options.opened && options.opened(response);
        },
        before: (response) => {
            parentDom.classList.add(opt.formClass);
            targetDom ? targetDom.classList.add(opt.buttonClass) : null;
            if (mode == 'button' && targetDom) {
                targetDom.innerHTML = opt.buttonText;
                targetDom.insertAdjacentHTML('afterbegin', '<i class="ax-btn-loading"></i>');
            } else {
                overlayDom.innerHTML = response.content;
                overlayDom.classList.add(opt.overlayClass);
                if (!parentDom.querySelector('.ax-form-overlay')) {
                    parentDom.appendChild(overlayDom);
                }
            }
            options.before && options.before(response);
        },
        success: (response) => {
            setTimeout(() => {
                parentDom.classList.remove(opt.formClass);
                targetDom ? targetDom.classList.remove(opt.buttonClass) : null;
                if (mode == 'button' && targetDom) {
                    targetDom.innerHTML = targetText;
                } else {
                    overlayDom.classList.remove(opt.overlayClass);
                }
                new axMessage({
                    content: opt.successText,
                    result: 'success',
                    iconShow: true,
                });
                options.success && options.success(response);
            }, options.delay === 0 ? 0 : options.delay || 1000);
        },
        error: (response) => {
            if (mode == 'button' && targetDom) {
                targetDom.innerHTML = targetText;
            } else {
                overlayDom.classList.remove(opt.overlayClass);
            }
            new axMessage({
                content: opt.errorText,
                result: 'error',
                iconShow: true,
            });
            options.error && options.error(response);
        }
    });
    return promise;
}
/**
 * 获取距离body的上偏移和左偏移
 */
const axOffset = (elem) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let totalLeft,
        totalTop,
        scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft,
        scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop,
        targetDom = axIdToDom(elem);
    totalLeft = targetDom.getBoundingClientRect().left + scrollLeft;
    totalTop = targetDom.getBoundingClientRect().top + scrollTop;
    return {
        left: totalLeft,
        top: totalTop
    }
}
/**
 * 获得元素真实宽度，宽度构成包括：margin、padding、borderWidth、width
 */
const axWidth = (elem, type) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth } = getComputedStyle(_elem);
    width = parseInt(width, 10);
    paddingLeft = parseInt(paddingLeft, 10);
    paddingRight = parseInt(paddingRight, 10);
    marginLeft = parseInt(marginLeft, 10);
    marginRight = parseInt(marginRight, 10);
    borderLeftWidth = parseInt(borderLeftWidth, 10);
    borderRightWidth = parseInt(borderRightWidth, 10);
    if (type == 'inner') {
        return width + paddingLeft + paddingRight;
    } else if (type == 'outer') {
        return width + paddingLeft + paddingRight + marginLeft + marginRight + borderLeftWidth + borderRightWidth;
    } else {
        return width;
    }
}
/**
 * 获得元素真实高度，宽度构成包括：margin、padding、borderWidth、height
 */
const axHeight = (elem, type) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth } = getComputedStyle(_elem);
    height = parseInt(height, 10);
    paddingTop = parseInt(paddingTop, 10);
    paddingBottom = parseInt(paddingBottom, 10);
    marginTop = parseInt(marginTop, 10);
    marginBottom = parseInt(marginBottom, 10);
    borderTopWidth = parseInt(borderTopWidth, 10);
    borderBottomWidth = parseInt(borderBottomWidth, 10);
    if (type == 'inner') {
        return height + paddingTop + paddingBottom;
    } else if (type == 'outer') {
        return height + paddingTop + paddingBottom + marginTop + marginBottom + borderTopWidth + borderBottomWidth;
    } else {
        return height;
    }
}
/**
 * 获得元素高度构成部分，包括：height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth
 */
const axArrHeight = (elem) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth } = getComputedStyle(_elem);
    height = parseInt(height, 10);
    paddingTop = parseInt(paddingTop, 10);
    paddingBottom = parseInt(paddingBottom, 10);
    marginTop = parseInt(marginTop, 10);
    marginBottom = parseInt(marginBottom, 10);
    borderTopWidth = parseInt(borderTopWidth, 10);
    borderBottomWidth = parseInt(borderBottomWidth, 10);
    return { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth };
};
/**
 * 获得元素宽度构成部分，包括：width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeft, borderRight
 */
/* const axArrWidth = (elem) => {
    let { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth } = getComputedStyle(elem);
    width = parseInt(width, 10);
    paddingLeft = parseInt(paddingLeft, 10);
    paddingRight = parseInt(paddingRight, 10);
    marginLeft = parseInt(marginLeft, 10);
    marginRight = parseInt(marginRight, 10);
    borderLeft = parseInt(borderLeftWidth, 10);
    borderRight = parseInt(borderRightWidth, 10);
    return { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeft, borderRight };
}; */
/**
 *  判断是否选择了已知元素 ,返回 ture 或 false
 */
const axSelector = (elem, selector) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let result = true;
    if (selector) {
        selector = String(selector).replace(/\s+/g, '');
        selector = String(selector).split(',');
        for (let i = 0; i < selector.length; i++) {
            if (!selector[i]) {
                result = true;
                break;
            } else if (axStrType(selector[i]) == 'class') {
                let string = selector[i].replace('.', '');
                if (_elem.classList.contains(string)) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else if (axStrType(selector[i]) == 'id') {
                let string = selector[i].replace('#', '');
                if (_elem.getAttribute('id') == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else {
                let string = selector[i].toUpperCase();
                if (_elem.nodeName == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            }
        }
    } else {
        result = true;
    }
    return result;
}
/**
 * 判断是否排除了已知元素 ,返回 ture 或 false
 */
const axNot = (elem, selector) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let result = true;
    if (selector) {
        selector = String(selector).replace(/\s+/g, '');
        selector = String(selector).split(',');
        for (let i = 0; i < selector.length; i++) {
            if (axStrType(selector[i]) == 'class') {
                let string = selector[i].replace('.', '');
                if (_elem.classList.contains(string)) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            }
            else if (axStrType(selector[i]) == 'id') {
                let string = selector[i].replace('#', '');
                if (_elem.getAttribute('id') == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else if (selector) {
                let string = selector[i].toUpperCase();
                if (_elem.nodeName == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else {
                result = false;
            }
        }
    } else {
        result = false;
    }
    return result;
}
/**
 * 选择兄弟元素
 * element：选择的Dom
 * self：是否包含自己，默认false
 * selector：从指定的选择器中选择兄弟元素
 * ignore：不选择的兄弟元素
 * 举例：axSiblings(elem,'#my','.disabled')
 */
const axSiblings = (element, self, selector, ignore) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    return [...elem.parentNode.children].filter((child) => {
        if (!self) {
            return child !== elem && axSelector(child, selector) && !axNot(child, ignore);
        } else {
            return axSelector(child, selector) && !axNot(child, ignore);
        }
    });
}
/**
 * 选择子元素
 * element：选择的Dom
 * selector：从指定的选择器中选择兄弟元素
 * ignore：不选择的兄弟元素
 * 举例：axChildren(elem,'.item','.disabled')
 */
const axChildren = (element, selector, ignore) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    return [...elem.children].filter((child) => {
        return axSelector(child, selector) && !axNot(child, ignore);
    });
}
/**
 * 定义取得嫡系父层函数。
 * start：根节点
 * end：终节点
 * containStart：是否包含根节点
 * containEnd：是否包含终节点
 * parents：父节点数组
 */
const axParents = (start, end, containStart, containEnd, parents = []) => {
    if (!start) { console.error('No node to start!'); return false; }
    let _start = axIdToDom(start),
        _end = end ? axIdToDom(end) : null;
    if (_start.parentElement.nodeName !== 'BODY') {
        (containStart && parents.indexOf(_start) < 0) ? parents.push(_start) : null;
        if (_end) {
            (containEnd && parents.indexOf(_end) < 0) ? parents.push(_end) : null;
            if (_start.parentElement !== _end) {
                parents.push(_start.parentElement);
                return axParents(_start.parentElement, _end, containStart, containEnd, parents)
            } else {
                return parents;
            }
        } else {
            parents.push(_start.parentElement);
            return axParents(_start.parentElement, _end, containStart, containEnd, parents)
        }
    } else {
        return parents;
    }
}
/**
 * 定义动画曲线
 * 举例：axCurves.easeOutIn(0.3)
 */
const axCurves = {
    linear(t) { return t; },
    easeIn(t) { return t * t * t; },
    easeOut(t) { return (t - 1) * (t - 1) * (t - 1) + 1; },
    easeInOut(t) { return t < 0.5 ? 2 * t * t : -2(t - 1) * (t - 1) + 1; },
    easeOutIn(t) { return t < 0.5 ? Math.sqrt(0.5 * t) : -Math.sqrt(0.5 * (-t + 1)) + 1; }
};
/**
 * 定义axSlideDown动画
 * 举例：axSlideDown(elem)
 */
const axSlideDown = (elem, display, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        dftTime = height => height / 3 + 250,
        rawStyle = element.style.cssText;
    display = display || 'block';
    if (window.getComputedStyle(element).display === "none") {
        element.style.cssText = `${rawStyle}display: ${display};`;
        const { height, paddingTop, paddingBottom, marginTop, marginBottom } = axArrHeight(element);
        let time;
        if (duration !== undefined && typeof duration === 'number') {
            time = duration;
        } else {
            time = dftTime(height);
        }
        element.style.cssText = `${rawStyle}display: ${display}; padding-top: 0; padding-bottom: 0;margin-top: 0; margin-bottom: 0;`;
        const initTime = new Date().getTime();
        const repeat = () => {
            const newTime = new Date().getTime() - initTime;
            const timestep = newTime / time;
            const timefactor = axCurves[curve](timestep);
            const step = 0 + height * timefactor;
            const stepPaddingT = 0 + (paddingTop * timefactor);
            const stepPaddingB = 0 + (paddingBottom * timefactor);
            const stepMarginT = 0 + (marginTop * timefactor);
            const stepMarginB = 0 + (marginBottom * timefactor);
            if (newTime <= time && Math.ceil(step) < height) {
                element.style.cssText = `${rawStyle}overflow:hidden;display: ${display}; padding-top: ${stepPaddingT}px; padding-bottom: ${stepPaddingB}px;margin-top: ${stepMarginT}px; margin-bottom: ${stepMarginB}px; height: ${step}px`;
            } else {
                element.style.cssText = `${rawStyle}display: ${display};`;
            }
            const repeatLoop = requestAnimationFrame(repeat);
            if (Math.ceil(step) >= height || !height) {
                cancelAnimationFrame(repeatLoop);
                callback && callback();
            }
        };
        repeat();
    }
    return element;
};
/**
 * 不判断元素是否隐藏的下拉展开动画
 */
const axHeightDown = (elem, arrHeight, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        dftTime = height => height / 3 + 250;
    const height = (arrHeight && arrHeight.height) ? arrHeight.height : axArrHeight(element).height,
        paddingTop = (arrHeight && arrHeight.paddingTop) ? arrHeight.paddingTop : axArrHeight(element).paddingTop,
        paddingBottom = (arrHeight && arrHeight.paddingBottom) ? arrHeight.paddingBottom : axArrHeight(element).paddingBottom,
        marginTop = (arrHeight && arrHeight.marginTop) ? arrHeight.marginTop : axArrHeight(element).marginTop,
        marginBottom = (arrHeight && arrHeight.marginBottom) ? arrHeight.marginBottom : axArrHeight(element).marginBottom;
    let time;
    if (duration !== undefined && typeof duration === 'number') {
        time = duration;
    } else {
        time = dftTime(height);
    }
    element.style.overflow = 'hidden';
    element.style.height = 0;
    paddingTop ? element.style.paddingTop = 0 : null;
    paddingBottom ? element.style.paddingBottom = 0 : null;
    marginTop ? element.style.marginTop = 0 : null;
    marginBottom ? element.style.marginBottom = 0 : null;
    const initTime = new Date().getTime();
    const repeat = () => {
        const newTime = new Date().getTime() - initTime;
        const timestep = newTime / time;
        const timefactor = axCurves[curve](timestep);
        const step = 0 + height * timefactor;
        const stepPaddingT = 0 + (paddingTop * timefactor);
        const stepPaddingB = 0 + (paddingBottom * timefactor);
        const stepMarginT = 0 + (marginTop * timefactor);
        const stepMarginB = 0 + (marginBottom * timefactor);
        if (newTime <= time && Math.ceil(step) < height) {
            element.style.height = step + 'px';
            paddingTop ? element.style.paddingTop = stepPaddingT + 'px' : null;
            paddingBottom ? element.style.paddingBottom = stepPaddingB + 'px' : null;
            marginTop ? element.style.marginTop = stepMarginT + 'px' : null;
            marginBottom ? element.style.marginBottom = stepMarginB + 'px' : null;
        } else {
            element.style.height = height + 'px';
            paddingTop ? element.style.paddingTop = paddingTop + 'px' : null;
            paddingBottom ? element.style.paddingBottom = paddingBottom + 'px' : null;
            marginTop ? element.style.marginTop = marginTop + 'px' : null;
            marginBottom ? element.style.marginBottom = marginBottom + 'px' : null;
        }
        const repeatLoop = requestAnimationFrame(repeat);
        if (Math.ceil(step) >= height || !height) {
            cancelAnimationFrame(repeatLoop);
            callback && callback();
        }
    };
    repeat();
    return element;
};
/**
 * 定义axSlideUp动画
 * 举例：axSlideUp(elem)
 */
const axSlideUp = (elem, display, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        dftTime = height => height / 3 + 250,
        rawStyle = element.style.cssText;
    display = display || 'block';
    if (window.getComputedStyle(element).display !== "none") {
        const { height, paddingTop, paddingBottom, marginTop, marginBottom } = axArrHeight(element);
        let time;
        if (duration !== undefined && typeof duration === 'number') {
            time = duration;
        } else {
            time = dftTime(height);
        }
        element.style.cssText = `${rawStyle}display: ${display}; padding-top: 0; padding-bottom: 0;margin-top: 0; margin-bottom: 0;`;
        const initTime = new Date().getTime();
        const repeat = () => {
            const newTime = new Date().getTime() - initTime;
            const timestep = newTime / time;
            const timefactor = axCurves[curve](timestep);
            const step = height + -height * timefactor;
            const stepPaddingT = paddingTop + (-paddingTop * timefactor);
            const stepPaddingB = paddingBottom + (-paddingBottom * timefactor);
            const stepMarginT = marginTop + (-marginTop * timefactor);
            const stepMarginB = marginBottom + (-marginBottom * timefactor);
            if (newTime <= time && Math.floor(step) > 0) {
                element.style.cssText = `${rawStyle}overflow:hidden;display: ${display}; padding-top: ${stepPaddingT}px; padding-bottom: ${stepPaddingB}px;margin-top: ${stepMarginT}px; margin-bottom: ${stepMarginB}px; height: ${step}px`;
            } else {
                element.style.cssText = `${rawStyle}display: none`;
            }
            const repeatLoop = requestAnimationFrame(repeat);
            if (Math.floor(step) <= 0 || !height) {
                cancelAnimationFrame(repeatLoop);
                callback && callback();
            }
        };
        repeat();
    }
    return element;
};
/**
 * 不判断元素是否隐藏的上拉隐藏动画
 */
const axHeightUp = (elem, arrHeight, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    let dftTime = height => height / 3 + 250;
    const height = (arrHeight && arrHeight.height) ? arrHeight.height : axArrHeight(element).height,
        paddingTop = (arrHeight && arrHeight.paddingTop) ? arrHeight.paddingTop : axArrHeight(element).paddingTop,
        paddingBottom = (arrHeight && arrHeight.paddingBottom) ? arrHeight.paddingBottom : axArrHeight(element).paddingBottom,
        marginTop = (arrHeight && arrHeight.marginTop) ? arrHeight.marginTop : axArrHeight(element).marginTop,
        marginBottom = (arrHeight && arrHeight.marginBottom) ? arrHeight.marginBottom : axArrHeight(element).marginBottom;
    let time;
    if (duration !== undefined && typeof duration === 'number') {
        time = duration;
    } else {
        time = dftTime(height);
    }
    element.style.overflow = 'hidden';
    const initTime = new Date().getTime();
    const repeat = () => {
        const newTime = new Date().getTime() - initTime;
        const timestep = newTime / time;
        const timefactor = axCurves[curve](timestep);
        const step = height + -height * timefactor;
        const stepPaddingT = paddingTop + (-paddingTop * timefactor);
        const stepPaddingB = paddingBottom + (-paddingBottom * timefactor);
        const stepMarginT = marginTop + (-marginTop * timefactor);
        const stepMarginB = marginBottom + (-marginBottom * timefactor);
        if (newTime <= time && Math.floor(step) > 0) {
            element.style.height = step + 'px';
            paddingTop ? element.style.paddingTop = stepPaddingT + 'px' : null;
            paddingBottom ? element.style.paddingBottom = stepPaddingB + 'px' : null;
            marginTop ? element.style.marginTop = stepMarginT + 'px' : null;
            marginBottom ? element.style.marginBottom = stepMarginB + 'px' : null;
        } else {
            element.style.height = 0;
            paddingTop ? element.style.paddingTop = 0 : null;
            paddingBottom ? element.style.paddingBottom = 0 : null;
            marginTop ? element.style.marginTop = 0 : null;
            marginBottom ? element.style.marginBottom = 0 : null;
        }
        const repeatLoop = requestAnimationFrame(repeat);
        if (Math.floor(step) <= 0 || !height) {
            cancelAnimationFrame(repeatLoop);
            callback && callback();
        }
    };
    repeat();
    return element;
};
/**
 * 定义axSlideToggle动画
 * 举例：axSlideToggle(elem)
 */
const axSlideToggle = (elem, display, downCallback, upCallback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    display = display || 'block';
    if (window.getComputedStyle(element).display === 'none') {
        axSlideDown(element, display, downCallback, duration, curve);
    } else {
        axSlideUp(element, display, upCallback, duration, curve);
    }
    return element;
}
/**
 * 定义axFadeIn动画
 * 举例：axFadeIn(elem)
 */
const axFadeIn = (elem, show, callback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    show = show || 'block';
    if (element) {
        let display = window.getComputedStyle(element).display,
            opacity = window.getComputedStyle(element).opacity;
        if (display === 'none') {
            element.style.display = show;
            element.style.opacity = 0;
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = axCurves[curve](timestep);
                if (newTime <= duration && step <= 1) {
                    element.style.opacity = step;
                } else {
                    element.style.opacity = 1;
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step >= 1) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        } else if (display !== 'none' && Number(opacity) !== 1) {
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = axCurves[curve](timestep) + Number(opacity);
                if (newTime <= duration && step <= 1) {
                    element.style.opacity = step;
                } else {
                    element.style.opacity = 1;
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step >= 1) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        }
    }
    callback && callback();
    return element;
};
/**
 * 定义axFadeOut动画
 * 举例：axFadeOut(elem)
 */
const axFadeOut = (elem, callback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display,
            opacity = window.getComputedStyle(element).opacity;
        if (display !== 'none' || Number(opacity) !== 0) {
            element.style.opacity = opacity;
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = Number(opacity) - axCurves[curve](timestep);
                if (newTime <= duration && step > 0) {
                    element.style.opacity = step;
                } else {
                    element.style.opacity = 0;
                    element.style.display = 'none';
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step <= 0) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        }
    }
    callback && callback();
    return element;
};
/**
 * 定义axFadeToggle动画
 * 举例：axFadeToggle(elem)
 */
const axFadeToggle = (elem, show, inCallback, outCallback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display;
        let opacity = window.getComputedStyle(element).opacity;
        if (display === 'none') {
            axFadeIn(element, show, inCallback, duration, curve);
        } else if (Number(opacity) <= 0.5) {
            axFadeIn(element, show, inCallback, duration, curve);
        } else if (Number(opacity) > 0.5) {
            axFadeOut(element, outCallback, duration, curve);
        } else {
            axFadeOut(element, outCallback, duration, curve);
        }
    }
    return element;
}
/**
 * 定义axShow动画（元素显示），因为有些元素显示方式可以是inline-block、block、visible或box，所以需要使用show来设定，如果不填则优先使用block
 * 举例：axShow(elem,show,callback)
 */
const axShow = (element, show, callback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    if (show == 'visible') {
        elem.style.visibility = 'visible';
    } else if (show) {
        elem.style.display = show;
    } else {
        elem.style.display = 'block';
    }
    callback && callback();
}
/**
 * 定义axHide动画(元素隐藏)，根据实际情况选择隐藏方式来设置hide参数，可选none和hidden，如果不填则优先使用none
 * 举例：axHide(elem,hide,callback)
 */
const axHide = (element, hide, callback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    if (hide == 'hidden') {
        elem.style.visibility = 'hidden';
    } else {
        elem.style.display = 'none';
    }
    callback && callback();
}
/**
 * 元素显示隐藏切换，show和hide参数如上面两个函数所述
 * 举例: axToggle(elem,show,hide)
 */
const axToggle = (element, show, hide, showCallback, hideCallback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    axIsVisible(elem) ? axHide(elem, hide, hideCallback) : axShow(elem, show, showCallback);
}
/**
 * 页面锚记滚动
 * 举例：axScrollTo(elem,target,2000,'easeOut')
 */
const axScrollTo = (element, options = {}) => {
    let parentDom = options.parent ? axIdToDom(options.parent) : null,
        scrollParent = parentDom || window,
        scrollOffset = ~~options.offset || 0,
        curve = options.curve || 'easeOut',
        anchorDom = typeof element === 'number' ? '' : axIdToDom(element),
        bodyScrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop,
        offsetScrolled = parentDom ? parentDom.scrollTop : bodyScrollTop,
        initTime = new Date().getTime(),
        offsetClient;
    if (parentDom && axStyle(document.querySelector('#spys01')).position === 'static') {
        parentDom.style.position = 'relative';
    }
    if (anchorDom) {
        offsetClient = parentDom ? anchorDom.offsetTop - parentDom.scrollTop : anchorDom.getBoundingClientRect().top;
    } else {
        offsetClient = typeof element === 'number' ? element - offsetScrolled : -offsetScrolled;
    }
    let duration = !options.duration || typeof options.duration !== 'number' ? Math.abs(offsetClient) / 4 + 1000 : options.duration,
        repeat = () => {
            let newTime = new Date().getTime() - initTime,
                timestep = newTime / duration,
                step = offsetScrolled + (offsetClient - scrollOffset) * axCurves[curve](timestep);
            scrollParent.scrollTo(0, step);
            repeat.timer = requestAnimationFrame(repeat);
            if (newTime >= duration) {
                scrollParent.scrollTo(0, step);
                cancelAnimationFrame(repeat.timer);
            }
        };
    repeat();
    return element;
};
/**
 * 定义常用图标
 */
const axIcon = {
    font: {
        success: '<i class="ax-iconfont ax-icon-check-o"></i>',
        error: '<i class="ax-iconfont ax-icon-close-o"></i>',
        warning: '<i class="ax-iconfont ax-icon-warning-o"></i>',
        info: '<i class="ax-iconfont ax-icon-info-o"></i>',
        question: '<i class="ax-iconfont ax-icon-question-o"></i>',
        successFill: '<i class="ax-iconfont ax-icon-check-o-f"></i>',
        errorFill: '<i class="ax-iconfont ax-icon-close-o-f"></i>',
        warningFill: '<i class="ax-iconfont ax-icon-warning-o-f"></i>',
        infoFill: '<i class="ax-iconfont ax-icon-info-o-f"></i>',
        questionFill: '<i class="ax-iconfont ax-icon-question-o-f"></i>',
    },
    svg: {
        success: '<svg class="svg-success" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M26.316,42.859L37.9984,54.5414L60.3826,32.1572"></path></svg>',
        error: '<svg class="svg-error" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M28.774,57.9246L57.9247,28.7739"></path><path class="svg-line svg-in-2" d="M57.9246,57.9246L28.7739,28.7739"></path></svg>',
        warning: '<svg class="svg-warning" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M43.4611 7.24c2.8081,0.0924 4.39,1.7 5.3045,3.1159l17.4543 29.9414 17.3445 29.7538c0.5448,1.0193 1.596,4.0544 0.1109,6.4168 -1.4849,2.3626 -3.6815,2.9155 -5.3768,2.992l-34.9082 0.0002 -34.6892 -0.0002c-1.1636,-0.0421 -4.3433,-0.6583 -5.6666,-3.1131 -1.3232,-2.4549 -0.7085,-4.6157 0.0723,-6.1078l17.454 -29.9417 17.3449 -29.7537c0.6185,-0.977 2.7471,-3.396 5.5554,-3.3036z"></path><path class="svg-line svg-out" d="M43.4611 7.24c2.8081,0.0924 4.39,1.7 5.3045,3.1159l17.4543 29.9414 17.3445 29.7538c0.5448,1.0193 1.596,4.0544 0.1109,6.4168 -1.4849,2.3626 -3.6815,2.9155 -5.3768,2.992l-34.9082 0.0002 -34.6892 -0.0002c-1.1636,-0.0421 -4.3433,-0.6583 -5.6666,-3.1131 -1.3232,-2.4549 -0.7085,-4.6157 0.0723,-6.1078l17.454 -29.9417 17.3449 -29.7537c0.6185,-0.977 2.7471,-3.396 5.5554,-3.3036z"></path><path class="svg-line svg-in-1" d="M43.3493,27.8713L43.3493,57.2858"></path><circle class="svg-circle svg-in-2" cx="43.3492" cy="64.3337" r="2.1166"></circle></svg>',
        info: '<svg class="svg-info" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M43.3493,65.0602L43.3493,30.9723"></path><circle class="svg-circle svg-in-2" cx="43.3492" cy="23.5856" r="2.1166"></circle></svg>',
        question: '<svg class="svg-question" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M32.3757 35.7255c-0.2203,-11.823 12.5789,-14.1087 18.4056,-9.4189 5.4663,4.3995 4.7426,12.804 -3.1088,17.9938 -3.0015,1.9839 -3.0003,3.8403 -3.0003,10.1707"></path><circle class="svg-circle svg-in-2" cx="44.6612" cy="60.5502" r="2.1166"></circle></svg>',
    },
};
/**
 * 定义结果函数
 */
const axResult = (elem, state) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let dom = axIdToDom(elem),
        svg = '';
    switch (state) {
        case 'success':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M26.316,42.859L37.9984,54.5414L60.3826,32.1572"></path>`;
            dom.querySelector('svg').classList.add('svg-success');
            break;
        case 'error':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M28.774,57.9246L57.9247,28.7739"></path>
            <path class="svg-line svg-in-2" d="M57.9246,57.9246L28.7739,28.7739"></path>`;
            dom.querySelector('svg').classList.add('svg-error');
            break;
        case 'question':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M32.3757 35.7255c-0.2203,-11.823 12.5789,-14.1087 18.4056,-9.4189 5.4663,4.3995 4.7426,12.804 -3.1088,17.9938 -3.0015,1.9839 -3.0003,3.8403 -3.0003,10.1707"></path>
            <circle class="svg-circle svg-in-2" cx="44.6612" cy="60.5502" r="2.1166"></circle>`;
            dom.querySelector('svg').classList.add('svg-question');
            break;
        case 'info':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M43.3493,65.0602L43.3493,30.9723"></path>
            <circle class="svg-circle svg-in-2" cx="43.3492" cy="23.5856" r="2.1166"></circle>`;
            dom.querySelector('svg').classList.add('svg-info');
            break;
    }
    dom.classList.add('ax-result-show');
    if (dom.querySelector('svg').innerHTML.indexOf('svg-in-1') == -1) {
        dom.querySelector('svg').insertAdjacentHTML('beforeend', svg);
    }
}
/**
 * 获取主体内容，适用于dialog|drawer|popup
 */
const axCreateContent = (options, instance, callback) => {
    let content = options.content, promise = {}, result;
    if (options.url) {
        if (options.type === 'async') {
            let ajaxUrl = '', ajaxSelector = '';
            if (axStrType(options.url) == 'id') {
                ajaxUrl = options.url.match(/(\S*)\#/)[1];
                ajaxSelector = '#' + options.url.match(/\#(\S*)/)[1];
            } else {
                ajaxUrl = options.url;
            }
            promise = axAjax({
                url: ajaxUrl,
                selector: ajaxSelector,
                type: options.ajaxType || 'post',
                opened: (data) => {
                    instance.contentXhr = data.xhr;
                },
                before: (data) => {
                    result = data.content;
                },
                success: (data) => {
                    if (typeof content === 'function') {
                        result = content(data.content);
                    } else {
                        result = data.content;
                    }
                    callback && callback.call(instance, result);
                }
            });
        } else {
            if (options.type === 'iframe') {
                result = `<iframe src="${options.url}" frameborder="0" width="100%" height="100%"></iframe>`;
                options.footerShow = false;
            } else if (options.type === 'picture') {
                result = `
            <div class="ax-media-container"><img src="${options.url}" /></div>
            <div class="ax-media-title">${options.name}</div>
            ${content}
            `;
            } else if (options.type === 'video') {
                result = `
                <div class="ax-media-container"><video src="${options.url}" controls="controls" ></video></div>
                <div class="ax-media-title">${options.name}</div>
                ${content}
                `;
            } else if (options.type === 'audio') {
                result = `
                <div class="ax-media-container"><audio src="${options.url}" controls="controls" ></audio></div>
                <div class="ax-media-title">${options.name}</div>
                ${content}
                `;
            }
            callback && callback.call(instance, result);
        }
    } else {
        if (options.type == 'html') {
            if (typeof content === 'string' && axStrType(content) == 'id') {
                result = document.querySelector(content).innerHTML;
            } else if (typeof content === 'function') {
                result = content.call(instance);
            } else {
                result = content;
            }
        } else {
            result = content || '没有任何内容！';
        }
        callback && callback.call(instance, result);
    }
    promise.content = result;
    callback && callback(result);
    return promise;
}
/**
 * 获取底部内容，适用于dialog|drawer|popup
 */
const axFooterBtns = (options) => {
    let lineBreak = options.footerBreak ? `<div class="ax-break-line"></div>` : '';
    let footer = '';
    options.note ? options.note = `<div class="ax-note">${options.note}</div>` : null
    if (!options.footerShow) {
        footer = '';
    } else if (options.footerType == 'right') {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-btn ax-primary ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-btn ax-text ax-ignore ${options.cancel.classname}"  cancel>${options.cancel.icon}${options.cancel.text}</a>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-btn ax-text ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-btn ax-text ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a>`;
        }
        footer = `
                                        ${lineBreak}
                                        <div class="ax-padding">
                                              <div class="ax-row">
                                                  <div class="ax-col">
                                                  ${options.note}
                                                  </div>
                                                  <div class="ax-btns">${btnDiy}${btnCancel}${btnConfirm}</div>
                                              </div>
                                          </div>
                          `;
    } else if (options.footerType == 'line') {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-col ax-col-12 ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-col ax-col-12 ${options.cancel.classname}"  cancel>${options.cancel.icon}${options.cancel.text}</a><span class="ax-gutter-line"></span>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-col ax-col-12 ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a><span class="ax-gutter-line"></span>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-col ax-col-12 ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a><span class="ax-gutter-line"></span>`;
        }
        footer = `
                          <div class="ax-break-line"></div>
                          <div class="ax-row">${btnDiy}${btnCancel}${btnConfirm}</div>${options.note}
                          `
    } else {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-btn ax-primary ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-btn ax-ignore ${options.cancel.classname}" cancel>${options.cancel.icon}${options.cancel.text}</a>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-btn ${options.diy.classname}" diy>${options.diy.icon}${options.diy.text}</a>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-btn ${options.diy.classname}" diy>${options.diy.icon}${options.diy.text}</a>`;
        }
        footer = `
                                        ${lineBreak}
                                         <div class="ax-padding ax-align-center">${btnDiy}${btnCancel}${btnConfirm}</div>
                                         <div class="ax-break"></div>${options.note}
                         `
    }
    return footer;
}
/**
 * 日期时间均转成本地时间戳
 * 类似2021-1-12和2021-01-12字符“-”均转成“/”分隔
 * axLocalTime('2070-1-20') - new Date(axLocalTime('2070-1-20')).getTimezoneOffset() * 60000) % 86400000 = 0 （能整除）
 * new Date('2070-01-20 12:11:13').getTime() == new Date('2070-1-20 12:11:13').getTime() == axLocalTime('2070-1-20 12:11:13')
 * new Date('2070/1/20').getTime() == new Date('2070-01-20').getTime() == axLocalTime('2070-1-20',true)
 * new Date('2070-1-20').getTime() == axLocalTime('2070-1-20')
 * axLocalTime('2070-1-20')和new Date(axLocalTime('2070-1-20'))可以互转
*/
const axLocalTime = (date, utc) => {
    let para, localDate, flag, loacalTime, localOffset;
    if (date) {
        date = date.trim();
        localDate = new Date(date);
        flag = localDate instanceof Date && !isNaN(localDate.getTime());
        if (!flag) {
            return console.error('Date format must be "YYYY-MM-DD" or "YYYY/MM/DD"');
        }
        para = date.replace(/-/g, "/");
        loacalTime = new Date(para).getTime();
        if (para.indexOf(':') !== -1) {
            localOffset = 0
        } else {
            localOffset = new Date(para).getTimezoneOffset() * 60000;
        }
    } else {
        loacalTime = new Date().getTime();
        localOffset = 0;
    }
    if (utc) {
        return loacalTime - localOffset;
    } else {
        return loacalTime;
    }
}
/**
 * 将元素内容转成数组[{x:'',y:'',z:''}],主要用于axLightbox
 */
const axCreateData = (
    src,
    roles = ['src', 'cover', 'caption', 'type'],
    keys = ['media', 'cover', 'caption', 'type'],
    node = 'figure',
    dft = ['', '', '', 'image'],
    callback
) => {
    let data = [],
        string = '';
    /* 
        if (axTypeIs('Array', src)) {
            string = JSON.stringify(src);
        } else if (axTypeIs('Object', src)) {
            string = JSON.stringify(src)
        } else if (axTypeIs('String', src)) {
            if (src.substr(0, 1) == '#') {
                data = axTplToArr(src, roles, keys, node, dft)
            } else {
                data = axStrToArr(src, keys, dft);
            }
        } */
    if (axType(src) === 'String' && axStrType(src) == 'id') {
        data = axTplToArr(src, roles, keys, node, dft);
    } else {
        if (axType(src) === 'Array' || axType(src) === 'Object') {
            string = JSON.stringify(src);
        } else if (axType(src) === 'String') {
            string = src;
        }
        data = axStrToArr(string, keys, dft);
    }
    data = data.filter(i => i[keys[0]]);
    callback && callback(data);
    return data;
}
/**
 * 数组多重排序，已用在axList和axSheet插件中
*/
const axSort = (data, sorts, type) => {
    let sortsArr = [];
    if (!Array.isArray(sorts)) {
        sorts.order ? sortsArr.push(sorts) : null;
    } else {
        sortsArr = sorts.filter(k => k.order);
    }
    let orders = (a, b, fields) => {
        if (fields.length == 0) {
            return 0;
        }
        let field = fields.shift(),
            col = field.col,
            order = field.order,
            attr = field.attr || 'label',
            flag,
            left,
            right;
        if (type == 'table') {
            if (typeof col == 'number') {
                left = a.children.filter(i => i.index === col)[0][attr];
                right = b.children.filter(i => i.index === col)[0][attr];
            } else {
                left = a.children.find(i => i.name === col)[attr];
                right = b.children.find(i => i.name === col)[attr];
            }
        } else {
            left = a[col];
            right = b[col]
        }
        if (isNaN(left - right)) {
            flag = (order === 'desc') ? right.localeCompare(left, 'zh-CN-u-kf-lower') : left.localeCompare(right, 'zh-CN-u-kf-lower');
        } else {
            flag = (order === 'desc') ? right - left : left - right;
        }
        return left === right ? orders(a, b, fields) : flag;
    }
    return data.sort((a, b) => {
        return orders(a, b, [...sortsArr]);
    });
}
/*!
 * 插件：表单序列化；使用方法：new axSerialize('#id')
 * 支持将表单值序列化为以“&”连接的字符串，和对象数组[{name:'',value:''},...]
 */
const axSerialize = (element, type = "string", separator = ',') => {
    let inputs,
        items = [],
        output;
    if (Array.isArray(element)) {
        inputs = element;
    } else {
        inputs = [...axIdToDom(element).querySelectorAll('[name]')].filter(i => ['INPUT', 'SELECT', 'TEXTAREA'].includes(i.nodeName) && i.name && !i.name.includes('_ax_alt'));
    }
    inputs.forEach(i => {
        let have = items.find(k => k.name == i.name);
        if (have) {
            if (i.type == 'checkbox' || i.type == 'radio') {
                have.dom.push(i);
            }
        } else {
            items.push({ name: i.name, type: i.type, dom: [i] })
        }
    });
    items.forEach(i => {
        if (i.type == 'file') {
            i.value = axMultiValues(i.dom[0], 'file', 'array');
        } else if (i.type == 'checkbox') {
            i.value = axMultiValues(i.dom, 'checkbox', 'string', '', separator);
        } else if (i.type == 'radio') {
            i.value = axMultiValues(i.dom, 'radio', 'string');
        } else if (i.type.includes('select')) {
            i.value = axMultiValues(i.dom[0], 'select', 'string', '', separator);
        } else {
            i.value = i.dom[0].value;
        }
    });
    if (type == 'string') {
        let str = '';
        items.forEach(k => {
            str += '&' + k.name + '=' + k.value;
        });
        output = str;
    } else if (type == 'json') {
        let obj = {}
        items.forEach(k => {
            obj[k.name] = k.value;
        });
        output = obj;
    } else if (type == 'array') {
        items.forEach(k => {
            delete k.type;
            delete k.dom;
        })
        output = items;
    }
    return output;
}
/*!
 * 通过多个关键字从数组中检索数据，获得每一项的权重
 * 支持多关键字检索
 * 支持多属性检索
 * 支持根据权重进行重排
 * 支持输出指定length数组，0表示不截取
 */
const axArrSearch = (keys, props, source, options) => {
    if (axIsEmpty(keys) || axIsEmpty(props) || !source || source.length === 0) {
        return [];
    }
    let searchOpt = Object.assign({ fuzzy: true, separator: ' ', limit: 0, reorder: false, ignore: true }, options),
        keyArr = axSplitToArr(keys, searchOpt.separator),
        propsArr = axSplitToArr(props, ','),
        crudeArr = [],
        regStr = '(' + keyArr.join('|') + ')',
        regExp = new RegExp(regStr, `${searchOpt.ignore ? 'i' : ''}g`);
    for (let v of source) {
        let valueStr = propsArr.map(k => v[k]).join('■'),
            valueMatch = valueStr.match(regExp),
            valueObj = {};
        if (valueMatch) {
            valueObj = { source: v, weight: valueMatch.length, keys: [...new Set(valueMatch)] };
            if (!searchOpt.fuzzy) {
                if ([...new Set(valueMatch)].length === keyArr.length) {
                    crudeArr.push(valueObj);
                }
            } else {
                crudeArr.push(valueObj);
            }
        }
    }
    if (searchOpt.reorder) {
        crudeArr.sort((a, b) => { return b.weight - a.weight });
    }
    if (searchOpt.limit && crudeArr.length > searchOpt.limit) {
        crudeArr.splice(searchOpt.limit)
    }
    return crudeArr;
}
/*!
 * 插件：代理监听；使用方法：new axObserve (obj, options)
 * 基于Proxy监听数组和对象的变化
 */
class axObserve {
    constructor(obj, options) {
        this.dataType = axType(obj);
        if (this.dataType !== 'Object' && this.dataType !== 'Array') {
            return { instance: this, proxy: obj };
        }
        this.options = axExtend({
            deep: false,
            accept: true,
            once: false,
            methods: ['set', 'deleteProperty'],
            callback: '',
        }, options);
        this.handlers = {};
        this.completeIndex = 0;
        this.reacts = 0;
        this.proxys = [];
        this.data = obj;
        this.fullMethods = {
            get: (target, key, proxy) => {
                let value = target[key];
                this.options.callback && this.options.callback({ target, key, proxy, value, type: 'get' });
                this.handlers.hasOwnProperty(key) ? this.emit(key, { target, key, proxy, value, type: 'get' }) : null;
                return Reflect.get(target, key, proxy);
            },
            set: (target, key, value, proxy) => {
                if (JSON.stringify(target[key]) == JSON.stringify(value)) {
                    return true
                }
                let valueType = axType(value),
                    raw = target[key],
                    handleType = target[key] === undefined ? 'add' : 'edit';
                if ((valueType === 'Object' || valueType === 'Array') && this.options.deep) {
                    value = this.proxy(value);
                }
                if (this.options.accept) {
                    Reflect.set(target, key, value, proxy);
                }
                this.options.callback && this.options.callback({ target, key, proxy, value, raw, type: handleType });
                this.handlers.hasOwnProperty(key) ? this.emit(key, { target, key, proxy, value, raw, type: handleType }) : null;
                this.reacts++;
                this.complete(this.reacts);
                return true;
            },
            deleteProperty: (target, key) => {
                let value = target[key];
                if (this.options.accept) {
                    Reflect.deleteProperty(target, key);
                }
                this.options.callback && this.options.callback({ target, key, value, type: 'delete' });
                this.handlers.hasOwnProperty(key) ? this.emit(key, { target, key, value, type: 'delete' }) : null;
                this.reacts++;
                this.complete(this.reacts);
                return true;
            }
        }
        this.methods = {};
        this.options.methods.forEach(k => {
            this.methods[k] = this.fullMethods[k]
        });
        if (this.options.deep) {
            for (let k in obj) {
                if (obj.hasOwnProperty(k)) {
                    let keyType = axType(obj[k]);
                    if (keyType === 'Object' || keyType === 'Array') {
                        obj[k] = this.proxy(obj[k]);
                    }
                }
            }
        }
        return { instance: this, proxy: this.proxy(obj) };
    }
    complete(nowReact) {
        setTimeout(() => {
            if (nowReact === this.reacts) {
                if (this.options.once && this.completeIndex !== 0) {
                    return false;
                }
                this.options.callback && this.options.callback({ target: this.data, proxy: this.proxys[0], type: 'complete' });
                this.handlers.hasOwnProperty('complete') ? this.emit('complete', { target: this.data, proxy: this.proxys[0], type: 'complete' }) : null;
                this.completeIndex++;
            }
        }, 0);
    }
    proxy(obj) {
        let proxy = new Proxy(obj, this.methods);
        if (this.proxys.length === 0) {
            this.proxys.push(proxy);
        }
        return proxy;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
 * 轮播插件axSwipe，使用方法：new axSwipe('#id',{参数})。源自Swiper v8.1.4 from https://swiperjs.com | AXUI做了部分修改
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.axSwiper = factory());
/*     document.querySelectorAll('[axSwiper]').forEach(element => {
        new axSwiper(element,axAttrToJson(element, 'axSwiper'));
    }); */
})(this, (function () {
    'use strict';
    /**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */
    /* eslint-disable no-param-reassign */
    function isObject$1(obj) {
        return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }
    function extend$1(target, src) {
        if (target === void 0) {
            target = {};
        }
        if (src === void 0) {
            src = {};
        }
        Object.keys(src).forEach(key => {
            if (typeof target[key] === 'undefined') target[key] = src[key]; else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
                extend$1(target[key], src[key]);
            }
        });
    }
    const ssrDocument = {
        body: {},
        addEventListener() { },
        removeEventListener() { },
        activeElement: {
            blur() { },
            nodeName: ''
        },
        querySelector() {
            return null;
        },
        querySelectorAll() {
            return [];
        },
        getElementById() {
            return null;
        },
        createEvent() {
            return {
                initEvent() { }
            };
        },
        createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute() { },
                getElementsByTagName() {
                    return [];
                }
            };
        },
        createElementNS() {
            return {};
        },
        importNode() {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        }
    };
    function getDocument() {
        const doc = typeof document !== 'undefined' ? document : {};
        extend$1(doc, ssrDocument);
        return doc;
    }
    const ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: ''
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        },
        history: {
            replaceState() { },
            pushState() { },
            go() { },
            back() { }
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener() { },
        removeEventListener() { },
        getComputedStyle() {
            return {
                getPropertyValue() {
                    return '';
                }
            };
        },
        Image() { },
        Date() { },
        screen: {},
        setTimeout() { },
        clearTimeout() { },
        matchMedia() {
            return {};
        },
        requestAnimationFrame(callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame(id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        }
    };
    function getWindow() {
        const win = typeof window !== 'undefined' ? window : {};
        extend$1(win, ssrWindow);
        return win;
    }
    /**
     * Dom7 4.0.4
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2022, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: January 11, 2022
     */
    /* eslint-disable no-proto */
    function makeReactive(obj) {
        const proto = obj.__proto__;
        Object.defineProperty(obj, '__proto__', {
            get() {
                return proto;
            },
            set(value) {
                proto.__proto__ = value;
            }
        });
    }
    class Dom7 extends Array {
        constructor(items) {
            if (typeof items === 'number') {
                super(items);
            } else {
                super(...(items || []));
                makeReactive(this);
            }
        }
    }
    function arrayFlat(arr) {
        if (arr === void 0) {
            arr = [];
        }
        const res = [];
        arr.forEach(el => {
            if (Array.isArray(el)) {
                res.push(...arrayFlat(el));
            } else {
                res.push(el);
            }
        });
        return res;
    }
    function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
        const uniqueArray = [];
        for (let i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
        }
        return uniqueArray;
    }
    function qsa(selector, context) {
        if (typeof selector !== 'string') {
            return [selector];
        }
        const a = [];
        const res = context.querySelectorAll(selector);
        for (let i = 0; i < res.length; i += 1) {
            a.push(res[i]);
        }
        return a;
    }
    function $(selector, context) {
        const window = getWindow();
        const document = getDocument();
        let arr = [];
        if (!context && selector instanceof Dom7) {
            return selector;
        }
        if (!selector) {
            return new Dom7(arr);
        }
        if (typeof selector === 'string') {
            const html = selector.trim();
            if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                let toCreate = 'div';
                if (html.indexOf('<li') === 0) toCreate = 'ul';
                if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                if (html.indexOf('<tbody') === 0) toCreate = 'table';
                if (html.indexOf('<option') === 0) toCreate = 'select';
                const tempParent = document.createElement(toCreate);
                tempParent.innerHTML = html;
                for (let i = 0; i < tempParent.childNodes.length; i += 1) {
                    arr.push(tempParent.childNodes[i]);
                }
            } else {
                arr = qsa(selector.trim(), context || document);
            } 
        } else if (selector.nodeType || selector === window || selector === document) {
            arr.push(selector);
        } else if (Array.isArray(selector)) {
            if (selector instanceof Dom7) return selector;
            arr = selector;
        }
        return new Dom7(arrayUnique(arr));
    }
    $.fn = Dom7.prototype; 
    function addClass() {
        for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
            classes[_key] = arguments[_key];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            el.classList.add(...classNames);
        });
        return this;
    }
    function removeClass() {
        for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            classes[_key2] = arguments[_key2];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            el.classList.remove(...classNames);
        });
        return this;
    }
    function toggleClass() {
        for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            classes[_key3] = arguments[_key3];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            classNames.forEach(className => {
                el.classList.toggle(className);
            });
        });
    }
    function hasClass() {
        for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            classes[_key4] = arguments[_key4];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        return arrayFilter(this, el => {
            return classNames.filter(className => el.classList.contains(className)).length > 0;
        }).length > 0;
    }
    function attr(attrs, value) {
        if (arguments.length === 1 && typeof attrs === 'string') {
            if (this[0]) return this[0].getAttribute(attrs);
            return undefined;
        } 
        for (let i = 0; i < this.length; i += 1) {
            if (arguments.length === 2) {
                this[i].setAttribute(attrs, value);
            } else {
                for (const attrName in attrs) {
                    this[i][attrName] = attrs[attrName];
                    this[i].setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        return this;
    }
    function removeAttr(attr) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].removeAttribute(attr);
        }
        return this;
    }
    function transform(transform) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.transform = transform;
        }
        return this;
    }
    function transition$1(duration) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
        }
        return this;
    }
    function on() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
        }
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        function handleLiveEvent(e) {
            const target = e.target;
            if (!target) return;
            const eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) listener.apply(target, eventData); else {
                const parents = $(target).parents(); 
                for (let k = 0; k < parents.length; k += 1) {
                    if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
                }
            }
        }
        function handleEvent(e) {
            const eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            listener.apply(this, eventData);
        }
        const events = eventType.split(' ');
        let j;
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (!targetSelector) {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7Listeners) el.dom7Listeners = {};
                    if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
                    el.dom7Listeners[event].push({
                        listener,
                        proxyListener: handleEvent
                    });
                    el.addEventListener(event, handleEvent, capture);
                }
            } else {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                    if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
                    el.dom7LiveListeners[event].push({
                        listener,
                        proxyListener: handleLiveEvent
                    });
                    el.addEventListener(event, handleLiveEvent, capture);
                }
            }
        }
        return this;
    }
    function off() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
        }
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        const events = eventType.split(' ');
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                let handlers;
                if (!targetSelector && el.dom7Listeners) {
                    handlers = el.dom7Listeners[event];
                } else if (targetSelector && el.dom7LiveListeners) {
                    handlers = el.dom7LiveListeners[event];
                }
                if (handlers && handlers.length) {
                    for (let k = handlers.length - 1; k >= 0; k -= 1) {
                        const handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
        }
        return this;
    }
    function trigger() {
        const window = getWindow();
        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
        }
        const events = args[0].split(' ');
        const eventData = args[1];
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                if (window.CustomEvent) {
                    const evt = new window.CustomEvent(event, {
                        detail: eventData,
                        bubbles: true,
                        cancelable: true
                    });
                    el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
                    el.dispatchEvent(evt);
                    el.dom7EventData = [];
                    delete el.dom7EventData;
                }
            }
        }
        return this;
    }
    function transitionEnd$1(callback) {
        const dom = this;
        function fireCallBack(e) {
            if (e.target !== this) return;
            callback.call(this, e);
            dom.off('transitionend', fireCallBack);
        }
        if (callback) {
            dom.on('transitionend', fireCallBack);
        }
        return this;
    }
    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
            }
            return this[0].offsetWidth;
        }
        return null;
    }
    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
            }
            return this[0].offsetHeight;
        }
        return null;
    }
    function offset() {
        if (this.length > 0) {
            const window = getWindow();
            const document = getDocument();
            const el = this[0];
            const box = el.getBoundingClientRect();
            const body = document.body;
            const clientTop = el.clientTop || body.clientTop || 0;
            const clientLeft = el.clientLeft || body.clientLeft || 0;
            const scrollTop = el === window ? window.scrollY : el.scrollTop;
            const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
            return {
                top: box.top + scrollTop - clientTop,
                left: box.left + scrollLeft - clientLeft
            };
        }
        return null;
    }
    function styles() {
        const window = getWindow();
        if (this[0]) return window.getComputedStyle(this[0], null);
        return {};
    }
    function css(props, value) {
        const window = getWindow();
        let i;
        if (arguments.length === 1) {
            if (typeof props === 'string') {
                if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
            } else {
                for (i = 0; i < this.length; i += 1) {
                    for (const prop in props) {
                        this[i].style[prop] = props[prop];
                    }
                }
                return this;
            }
        }
        if (arguments.length === 2 && typeof props === 'string') {
            for (i = 0; i < this.length; i += 1) {
                this[i].style[props] = value;
            }
            return this;
        }
        return this;
    }
    function each(callback) {
        if (!callback) return this;
        this.forEach((el, index) => {
            callback.apply(el, [el, index]);
        });
        return this;
    }
    function filter(callback) {
        const result = arrayFilter(this, callback);
        return $(result);
    }
    function html(html) {
        if (typeof html === 'undefined') {
            return this[0] ? this[0].innerHTML : null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].innerHTML = html;
        }
        return this;
    }
    function text(text) {
        if (typeof text === 'undefined') {
            return this[0] ? this[0].textContent.trim() : null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].textContent = text;
        }
        return this;
    }
    function is(selector) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        let compareWith;
        let i;
        if (!el || typeof selector === 'undefined') return false;
        if (typeof selector === 'string') {
            if (el.matches) return el.matches(selector);
            if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
            if (el.msMatchesSelector) return el.msMatchesSelector(selector);
            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        if (selector === document) {
            return el === document;
        }
        if (selector === window) {
            return el === window;
        }
        if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [selector] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        return false;
    }
    function index() {
        let child = this[0];
        let i;
        if (child) {
            i = 0; 
            while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1) i += 1;
            }
            return i;
        }
        return undefined;
    }
    function eq(index) {
        if (typeof index === 'undefined') return this;
        const length = this.length;
        if (index > length - 1) {
            return $([]);
        }
        if (index < 0) {
            const returnIndex = length + index;
            if (returnIndex < 0) return $([]);
            return $([this[returnIndex]]);
        }
        return $([this[index]]);
    }
    function append() {
        let newChild;
        const document = getDocument();
        for (let k = 0; k < arguments.length; k += 1) {
            newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
            for (let i = 0; i < this.length; i += 1) {
                if (typeof newChild === 'string') {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) {
                        this[i].appendChild(tempDiv.firstChild);
                    }
                } else if (newChild instanceof Dom7) {
                    for (let j = 0; j < newChild.length; j += 1) {
                        this[i].appendChild(newChild[j]);
                    }
                } else {
                    this[i].appendChild(newChild);
                }
            }
        }
        return this;
    }
    function prepend(newChild) {
        const document = getDocument();
        let i;
        let j;
        for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                    this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                }
            } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j += 1) {
                    this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                }
            } else {
                this[i].insertBefore(newChild, this[i].childNodes[0]);
            }
        }
        return this;
    }
    function next(selector) {
        if (this.length > 0) {
            if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                    return $([this[0].nextElementSibling]);
                }
                return $([]);
            }
            if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
            return $([]);
        }
        return $([]);
    }
    function nextAll(selector) {
        const nextEls = [];
        let el = this[0];
        if (!el) return $([]);
        while (el.nextElementSibling) {
            const next = el.nextElementSibling; 
            if (selector) {
                if ($(next).is(selector)) nextEls.push(next);
            } else nextEls.push(next);
            el = next;
        }
        return $(nextEls);
    }
    function prev(selector) {
        if (this.length > 0) {
            const el = this[0];
            if (selector) {
                if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                    return $([el.previousElementSibling]);
                }
                return $([]);
            }
            if (el.previousElementSibling) return $([el.previousElementSibling]);
            return $([]);
        }
        return $([]);
    }
    function prevAll(selector) {
        const prevEls = [];
        let el = this[0];
        if (!el) return $([]);
        while (el.previousElementSibling) {
            const prev = el.previousElementSibling; 
            if (selector) {
                if ($(prev).is(selector)) prevEls.push(prev);
            } else prevEls.push(prev);
            el = prev;
        }
        return $(prevEls);
    }
    function parent(selector) {
        const parents = []; 
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode !== null) {
                if (selector) {
                    if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                } else {
                    parents.push(this[i].parentNode);
                }
            }
        }
        return $(parents);
    }
    function parents(selector) {
        const parents = []; 
        for (let i = 0; i < this.length; i += 1) {
            let parent = this[i].parentNode; 
            while (parent) {
                if (selector) {
                    if ($(parent).is(selector)) parents.push(parent);
                } else {
                    parents.push(parent);
                }
                parent = parent.parentNode;
            }
        }
        return $(parents);
    }
    function closest(selector) {
        let closest = this; 
        if (typeof selector === 'undefined') {
            return $([]);
        }
        if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
        }
        return closest;
    }
    function find(selector) {
        const foundElements = [];
        for (let i = 0; i < this.length; i += 1) {
            const found = this[i].querySelectorAll(selector);
            for (let j = 0; j < found.length; j += 1) {
                foundElements.push(found[j]);
            }
        }
        return $(foundElements);
    }
    function children(selector) {
        const children = []; 
        for (let i = 0; i < this.length; i += 1) {
            const childNodes = this[i].children;
            for (let j = 0; j < childNodes.length; j += 1) {
                if (!selector || $(childNodes[j]).is(selector)) {
                    children.push(childNodes[j]);
                }
            }
        }
        return $(children);
    }
    function remove() {
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
        }
        return this;
    }
    const Methods = {
        addClass,
        removeClass,
        hasClass,
        toggleClass,
        attr,
        removeAttr,
        transform,
        transition: transition$1,
        on,
        off,
        trigger,
        transitionEnd: transitionEnd$1,
        outerWidth,
        outerHeight,
        styles,
        offset,
        css,
        each,
        html,
        text,
        is,
        index,
        eq,
        append,
        prepend,
        next,
        nextAll,
        prev,
        prevAll,
        parent,
        parents,
        closest,
        find,
        children,
        filter,
        remove
    };
    Object.keys(Methods).forEach(methodName => {
        Object.defineProperty($.fn, methodName, {
            value: Methods[methodName],
            writable: true
        });
    });
    function deleteProps(obj) {
        const object = obj;
        Object.keys(object).forEach(key => {
            try {
                object[key] = null;
            } catch (e) {
            }
            try {
                delete object[key];
            } catch (e) {
            }
        });
    }
    function nextTick(callback, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setTimeout(callback, delay);
    }
    function now() {
        return Date.now();
    }
    function getComputedStyle$1(el) {
        const window = getWindow();
        let style;
        if (window.getComputedStyle) {
            style = window.getComputedStyle(el, null);
        }
        if (!style && el.currentStyle) {
            style = el.currentStyle;
        }
        if (!style) {
            style = el.style;
        }
        return style;
    }
    function getTranslate(el, axis) {
        if (axis === void 0) {
            axis = 'x';
        }
        const window = getWindow();
        let matrix;
        let curTransform;
        let transformMatrix;
        const curStyle = getComputedStyle$1(el);
        if (window.WebKitCSSMatrix) {
            curTransform = curStyle.transform || curStyle.webkitTransform;
            if (curTransform.split(',').length > 6) {
                curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
            } 
            transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
        } else {
            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
            matrix = transformMatrix.toString().split(',');
        }
        if (axis === 'x') {
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; 
            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); 
            else curTransform = parseFloat(matrix[4]);
        }
        if (axis === 'y') {
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; 
            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); 
            else curTransform = parseFloat(matrix[5]);
        }
        return curTransform || 0;
    }
    function isObject(o) {
        return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }
    function isNode(node) {
        if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
            return node instanceof HTMLElement;
        }
        return node && (node.nodeType === 1 || node.nodeType === 11);
    }
    function extend() {
        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
        const noExtend = ['__proto__', 'constructor', 'prototype'];
        for (let i = 1; i < arguments.length; i += 1) {
            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
                const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                    const nextKey = keysArray[nextIndex];
                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                    if (desc !== undefined && desc.enumerable) {
                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                            if (nextSource[nextKey].__swiper__) {
                                to[nextKey] = nextSource[nextKey];
                            } else {
                                extend(to[nextKey], nextSource[nextKey]);
                            }
                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) {
                                to[nextKey] = nextSource[nextKey];
                            } else {
                                extend(to[nextKey], nextSource[nextKey]);
                            }
                        } else {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
        }
        return to;
    }
    function setCSSProperty(el, varName, varValue) {
        el.style.setProperty(varName, varValue);
    }
    function animateCSSModeScroll(_ref) {
        let {
            swiper,
            targetPosition,
            side
        } = _ref;
        const window = getWindow();
        const startPosition = -swiper.translate;
        let startTime = null;
        let time;
        const duration = swiper.params.speed;
        swiper.wrapperEl.style.scrollSnapType = 'none';
        window.cancelAnimationFrame(swiper.cssModeFrameID);
        const dir = targetPosition > startPosition ? 'next' : 'prev';
        const isOutOfBound = (current, target) => {
            return dir === 'next' && current >= target || dir === 'prev' && current <= target;
        };
        const animate = () => {
            time = new Date().getTime();
            if (startTime === null) {
                startTime = time;
            }
            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
            if (isOutOfBound(currentPosition, targetPosition)) {
                currentPosition = targetPosition;
            }
            swiper.wrapperEl.scrollTo({
                [side]: currentPosition
            });
            if (isOutOfBound(currentPosition, targetPosition)) {
                swiper.wrapperEl.style.overflow = 'hidden';
                swiper.wrapperEl.style.scrollSnapType = '';
                setTimeout(() => {
                    swiper.wrapperEl.style.overflow = '';
                    swiper.wrapperEl.scrollTo({
                        [side]: currentPosition
                    });
                });
                window.cancelAnimationFrame(swiper.cssModeFrameID);
                return;
            }
            swiper.cssModeFrameID = window.requestAnimationFrame(animate);
        };
        animate();
    }
    let support;
    function calcSupport() {
        const window = getWindow();
        const document = getDocument();
        return {
            smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
            touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
            passiveListener: function checkPassiveListener() {
                let supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, 'passive', {
                        get() {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                } catch (e) {
                }
                return supportsPassive;
            }(),
            gestures: function checkGestures() {
                return 'ongesturestart' in window;
            }()
        };
    }
    function getSupport() {
        if (!support) {
            support = calcSupport();
        }
        return support;
    }
    let deviceCached;
    function calcDevice(_temp) {
        let {
            userAgent
        } = _temp === void 0 ? {} : _temp;
        const support = getSupport();
        const window = getWindow();
        const platform = window.navigator.platform;
        const ua = userAgent || window.navigator.userAgent;
        const device = {
            ios: false,
            android: false
        };
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); 
        let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        const windows = platform === 'Win32';
        let macos = platform === 'MacIntel'; 
        const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
            ipad = ua.match(/(Version)\/([\d.]+)/);
            if (!ipad) ipad = [0, 1, '13_0_0'];
            macos = false;
        } 
        if (android && !windows) {
            device.os = 'android';
            device.android = true;
        }
        if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
        } 
        return device;
    }
    function getDevice(overrides) {
        if (overrides === void 0) {
            overrides = {};
        }
        if (!deviceCached) {
            deviceCached = calcDevice(overrides);
        }
        return deviceCached;
    }
    let browser;
    function calcBrowser() {
        const window = getWindow();
        function isSafari() {
            const ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
        }
        return {
            isSafari: isSafari(),
            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
        };
    }
    function getBrowser() {
        if (!browser) {
            browser = calcBrowser();
        }
        return browser;
    }
    function Resize(_ref) {
        let {
            swiper,
            on,
            emit
        } = _ref;
        const window = getWindow();
        let observer = null;
        let animationFrame = null;
        const resizeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('beforeResize');
            emit('resize');
        };
        const createObserver = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            observer = new ResizeObserver(entries => {
                animationFrame = window.requestAnimationFrame(() => {
                    const {
                        width,
                        height
                    } = swiper;
                    let newWidth = width;
                    let newHeight = height;
                    entries.forEach(_ref2 => {
                        let {
                            contentBoxSize,
                            contentRect,
                            target
                        } = _ref2;
                        if (target && target !== swiper.el) return;
                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                    });
                    if (newWidth !== width || newHeight !== height) {
                        resizeHandler();
                    }
                });
            });
            observer.observe(swiper.el);
        };
        const removeObserver = () => {
            if (animationFrame) {
                window.cancelAnimationFrame(animationFrame);
            }
            if (observer && observer.unobserve && swiper.el) {
                observer.unobserve(swiper.el);
                observer = null;
            }
        };
        const orientationChangeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('orientationchange');
        };
        on('init', () => {
            if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
                createObserver();
                return;
            }
            window.addEventListener('resize', resizeHandler);
            window.addEventListener('orientationchange', orientationChangeHandler);
        });
        on('destroy', () => {
            removeObserver();
            window.removeEventListener('resize', resizeHandler);
            window.removeEventListener('orientationchange', orientationChangeHandler);
        });
    }
    function Observer(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const observers = [];
        const window = getWindow();
        const attach = function (target, options) {
            if (options === void 0) {
                options = {};
            }
            const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            const observer = new ObserverFunc(mutations => {
                if (mutations.length === 1) {
                    emit('observerUpdate', mutations[0]);
                    return;
                }
                const observerUpdate = function observerUpdate() {
                    emit('observerUpdate', mutations[0]);
                };
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(observerUpdate);
                } else {
                    window.setTimeout(observerUpdate, 0);
                }
            });
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
            observers.push(observer);
        };
        const init = () => {
            if (!swiper.params.observer) return;
            if (swiper.params.observeParents) {
                const containerParents = swiper.$el.parents();
                for (let i = 0; i < containerParents.length; i += 1) {
                    attach(containerParents[i]);
                }
            } 
            attach(swiper.$el[0], {
                childList: swiper.params.observeSlideChildren
            }); 
            attach(swiper.$wrapperEl[0], {
                attributes: false
            });
        };
        const destroy = () => {
            observers.forEach(observer => {
                observer.disconnect();
            });
            observers.splice(0, observers.length);
        };
        extendParams({
            observer: false,
            observeParents: false,
            observeSlideChildren: false
        });
        on('init', init);
        on('destroy', destroy);
    }
    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
        on(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            events.split(' ').forEach(event => {
                if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                self.eventsListeners[event][method](handler);
            });
            return self;
        },
        once(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            function onceHandler() {
                self.off(events, onceHandler);
                if (onceHandler.__emitterProxy) {
                    delete onceHandler.__emitterProxy;
                }
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }
                handler.apply(self, args);
            }
            onceHandler.__emitterProxy = handler;
            return self.on(events, onceHandler, priority);
        },
        onAny(handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            if (self.eventsAnyListeners.indexOf(handler) < 0) {
                self.eventsAnyListeners[method](handler);
            }
            return self;
        },
        offAny(handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsAnyListeners) return self;
            const index = self.eventsAnyListeners.indexOf(handler);
            if (index >= 0) {
                self.eventsAnyListeners.splice(index, 1);
            }
            return self;
        },
        off(events, handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            events.split(' ').forEach(event => {
                if (typeof handler === 'undefined') {
                    self.eventsListeners[event] = [];
                } else if (self.eventsListeners[event]) {
                    self.eventsListeners[event].forEach((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                            self.eventsListeners[event].splice(index, 1);
                        }
                    });
                }
            });
            return self;
        },
        emit() {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            let events;
            let data;
            let context;
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }
            if (typeof args[0] === 'string' || Array.isArray(args[0])) {
                events = args[0];
                data = args.slice(1, args.length);
                context = self;
            } else {
                events = args[0].events;
                data = args[0].data;
                context = args[0].context || self;
            }
            data.unshift(context);
            const eventsArray = Array.isArray(events) ? events : events.split(' ');
            eventsArray.forEach(event => {
                if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                    self.eventsAnyListeners.forEach(eventHandler => {
                        eventHandler.apply(context, [event, ...data]);
                    });
                }
                if (self.eventsListeners && self.eventsListeners[event]) {
                    self.eventsListeners[event].forEach(eventHandler => {
                        eventHandler.apply(context, data);
                    });
                }
            });
            return self;
        }
    };
    function updateSize() {
        const swiper = this;
        let width;
        let height;
        const $el = swiper.$el;
        if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
            width = swiper.params.width;
        } else {
            width = $el[0].clientWidth;
        }
        if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
            height = swiper.params.height;
        } else {
            height = $el[0].clientHeight;
        }
        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
            return;
        } 
        width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
        height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
        if (Number.isNaN(width)) width = 0;
        if (Number.isNaN(height)) height = 0;
        Object.assign(swiper, {
            width,
            height,
            size: swiper.isHorizontal() ? width : height
        });
    }
    function updateSlides() {
        const swiper = this;
        function getDirectionLabel(property) {
            if (swiper.isHorizontal()) {
                return property;
            } 
            return {
                'width': 'height',
                'margin-top': 'margin-left',
                'margin-bottom ': 'margin-right',
                'margin-left': 'margin-top',
                'margin-right': 'margin-bottom',
                'padding-left': 'padding-top',
                'padding-right': 'padding-bottom',
                'marginRight': 'marginBottom'
            }[property];
        }
        function getDirectionPropertyValue(node, label) {
            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
        }
        const params = swiper.params;
        const {
            $wrapperEl,
            size: swiperSize,
            rtlTranslate: rtl,
            wrongRTL
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        let snapGrid = [];
        const slidesGrid = [];
        const slidesSizesGrid = [];
        let offsetBefore = params.slidesOffsetBefore;
        if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
        }
        let offsetAfter = params.slidesOffsetAfter;
        if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
        }
        const previousSnapGridLength = swiper.snapGrid.length;
        const previousSlidesGridLength = swiper.slidesGrid.length;
        let spaceBetween = params.spaceBetween;
        let slidePosition = -offsetBefore;
        let prevSlideSize = 0;
        let index = 0;
        if (typeof swiperSize === 'undefined') {
            return;
        }
        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
        }
        swiper.virtualSize = -spaceBetween; 
        if (rtl) slides.css({
            marginLeft: '',
            marginBottom: '',
            marginTop: ''
        }); else slides.css({
            marginRight: '',
            marginBottom: '',
            marginTop: ''
        }); 
        if (params.centeredSlides && params.cssMode) {
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
        }
        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
        if (gridEnabled) {
            swiper.grid.initSlides(slidesLength);
        } 
        let slideSize;
        const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
            return typeof params.breakpoints[key].slidesPerView !== 'undefined';
        }).length > 0;
        for (let i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            const slide = slides.eq(i);
            if (gridEnabled) {
                swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
            }
            if (slide.css('display') === 'none') continue; 
            if (params.slidesPerView === 'auto') {
                if (shouldResetSlideSize) {
                    slides[i].style[getDirectionLabel('width')] = ``;
                }
                const slideStyles = getComputedStyle(slide[0]);
                const currentTransform = slide[0].style.transform;
                const currentWebKitTransform = slide[0].style.webkitTransform;
                if (currentTransform) {
                    slide[0].style.transform = 'none';
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = 'none';
                }
                if (params.roundLengths) {
                    slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                } else {
                    const width = getDirectionPropertyValue(slideStyles, 'width');
                    const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
                    const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
                    const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
                    const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
                    const boxSizing = slideStyles.getPropertyValue('box-sizing');
                    if (boxSizing && boxSizing === 'border-box') {
                        slideSize = width + marginLeft + marginRight;
                    } else {
                        const {
                            clientWidth,
                            offsetWidth
                        } = slide[0];
                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                    }
                }
                if (currentTransform) {
                    slide[0].style.transform = currentTransform;
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = currentWebKitTransform;
                }
                if (params.roundLengths) slideSize = Math.floor(slideSize);
            } else {
                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                if (params.roundLengths) slideSize = Math.floor(slideSize);
                if (slides[i]) {
                    slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
                }
            }
            if (slides[i]) {
                slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
            if (params.centeredSlides) {
                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
            } else {
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
            }
            swiper.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index += 1;
        }
        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            $wrapperEl.css({
                width: `${swiper.virtualSize + params.spaceBetween}px`
            });
        }
        if (params.setWrapperSize) {
            $wrapperEl.css({
                [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
            });
        }
        if (gridEnabled) {
            swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
        } 
        if (!params.centeredSlides) {
            const newSlidesGrid = [];
            for (let i = 0; i < snapGrid.length; i += 1) {
                let slidesGridItem = snapGrid[i];
                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                    newSlidesGrid.push(slidesGridItem);
                }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                snapGrid.push(swiper.virtualSize - swiperSize);
            }
        }
        if (snapGrid.length === 0) snapGrid = [0];
        if (params.spaceBetween !== 0) {
            const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
            slides.filter((_, slideIndex) => {
                if (!params.cssMode) return true;
                if (slideIndex === slides.length - 1) {
                    return false;
                }
                return true;
            }).css({
                [key]: `${spaceBetween}px`
            });
        }
        if (params.centeredSlides && params.centeredSlidesBounds) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            const maxSnap = allSlidesSize - swiperSize;
            snapGrid = snapGrid.map(snap => {
                if (snap < 0) return -offsetBefore;
                if (snap > maxSnap) return maxSnap + offsetAfter;
                return snap;
            });
        }
        if (params.centerInsufficientSlides) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            if (allSlidesSize < swiperSize) {
                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                snapGrid.forEach((snap, snapIndex) => {
                    snapGrid[snapIndex] = snap - allSlidesOffset;
                });
                slidesGrid.forEach((snap, snapIndex) => {
                    slidesGrid[snapIndex] = snap + allSlidesOffset;
                });
            }
        }
        Object.assign(swiper, {
            slides,
            snapGrid,
            slidesGrid,
            slidesSizesGrid
        });
        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
            const addToSnapGrid = -swiper.snapGrid[0];
            const addToSlidesGrid = -swiper.slidesGrid[0];
            swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
            swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
        }
        if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
        }
        if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) swiper.checkOverflow();
            swiper.emit('snapGridLengthChange');
        }
        if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
        }
        if (params.watchSlidesProgress) {
            swiper.updateSlidesOffset();
        }
        if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
            const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
            if (slidesLength <= params.maxBackfaceHiddenSlides) {
                if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
            } else if (hasClassBackfaceClassAdded) {
                swiper.$el.removeClass(backFaceHiddenClass);
            }
        }
    }
    function updateAutoHeight(speed) {
        const swiper = this;
        const activeSlides = [];
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let newHeight = 0;
        let i;
        if (typeof speed === 'number') {
            swiper.setTransition(speed);
        } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
        }
        const getSlideByIndex = index => {
            if (isVirtual) {
                return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
            }
            return swiper.slides.eq(index)[0];
        }; 
        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            if (swiper.params.centeredSlides) {
                swiper.visibleSlides.each(slide => {
                    activeSlides.push(slide);
                });
            } else {
                for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                    const index = swiper.activeIndex + i;
                    if (index > swiper.slides.length && !isVirtual) break;
                    activeSlides.push(getSlideByIndex(index));
                }
            }
        } else {
            activeSlides.push(getSlideByIndex(swiper.activeIndex));
        } 
        for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
        } 
        if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }
    function updateSlidesOffset() {
        const swiper = this;
        const slides = swiper.slides;
        for (let i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
    }
    function updateSlidesProgress(translate) {
        if (translate === void 0) {
            translate = this && this.translate || 0;
        }
        const swiper = this;
        const params = swiper.params;
        const {
            slides,
            rtlTranslate: rtl,
            snapGrid
        } = swiper;
        if (slides.length === 0) return;
        if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
        let offsetCenter = -translate;
        if (rtl) offsetCenter = translate; 
        slides.removeClass(params.slideVisibleClass);
        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];
        for (let i = 0; i < slides.length; i += 1) {
            const slide = slides[i];
            let slideOffset = slide.swiperSlideOffset;
            if (params.cssMode && params.centeredSlides) {
                slideOffset -= slides[0].swiperSlideOffset;
            }
            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            const slideBefore = -(offsetCenter - slideOffset);
            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
            if (isVisible) {
                swiper.visibleSlides.push(slide);
                swiper.visibleSlidesIndexes.push(i);
                slides.eq(i).addClass(params.slideVisibleClass);
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
        }
        swiper.visibleSlides = $(swiper.visibleSlides);
    }
    function updateProgress(translate) {
        const swiper = this;
        if (typeof translate === 'undefined') {
            const multiplier = swiper.rtlTranslate ? -1 : 1; 
            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
        }
        const params = swiper.params;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        let {
            progress,
            isBeginning,
            isEnd
        } = swiper;
        const wasBeginning = isBeginning;
        const wasEnd = isEnd;
        if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
        } else {
            progress = (translate - swiper.minTranslate()) / translatesDiff;
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
        }
        Object.assign(swiper, {
            progress,
            isBeginning,
            isEnd
        });
        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
        if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
        }
        if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
        }
        if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
            swiper.emit('fromEdge');
        }
        swiper.emit('progress', progress);
    }
    function updateSlidesClasses() {
        const swiper = this;
        const {
            slides,
            params,
            $wrapperEl,
            activeIndex,
            realIndex
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
        let activeSlide;
        if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
        } else {
            activeSlide = slides.eq(activeIndex);
        } 
        activeSlide.addClass(params.slideActiveClass);
        if (params.loop) {
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            }
        } 
        let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
        if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
        } 
        let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
        if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
        }
        if (params.loop) {
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            }
        }
        swiper.emitSlidesClasses();
    }
    function updateActiveIndex(newActiveIndex) {
        const swiper = this;
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        const {
            slidesGrid,
            snapGrid,
            params,
            activeIndex: previousIndex,
            realIndex: previousRealIndex,
            snapIndex: previousSnapIndex
        } = swiper;
        let activeIndex = newActiveIndex;
        let snapIndex;
        if (typeof activeIndex === 'undefined') {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                        activeIndex = i;
                    } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                        activeIndex = i + 1;
                    }
                } else if (translate >= slidesGrid[i]) {
                    activeIndex = i;
                }
            } 
            if (params.normalizeSlideIndex) {
                if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
            }
        }
        if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
        } else {
            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
        }
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
                swiper.snapIndex = snapIndex;
                swiper.emit('snapIndexChange');
            }
            return;
        } 
        const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
        Object.assign(swiper, {
            snapIndex,
            realIndex,
            previousIndex,
            activeIndex
        });
        swiper.emit('activeIndexChange');
        swiper.emit('snapIndexChange');
        if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
        }
        if (swiper.initialized || swiper.params.runCallbacksOnInit) {
            swiper.emit('slideChange');
        }
    }
    function updateClickedSlide(e) {
        const swiper = this;
        const params = swiper.params;
        const slide = $(e).closest(`.${params.slideClass}`)[0];
        let slideFound = false;
        let slideIndex;
        if (slide) {
            for (let i = 0; i < swiper.slides.length; i += 1) {
                if (swiper.slides[i] === slide) {
                    slideFound = true;
                    slideIndex = i;
                    break;
                }
            }
        }
        if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
                swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
            } else {
                swiper.clickedIndex = slideIndex;
            }
        } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
        }
        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
        }
    }
    var update = {
        updateSize,
        updateSlides,
        updateAutoHeight,
        updateSlidesOffset,
        updateSlidesProgress,
        updateProgress,
        updateSlidesClasses,
        updateActiveIndex,
        updateClickedSlide
    };
    function getSwiperTranslate(axis) {
        if (axis === void 0) {
            axis = this.isHorizontal() ? 'x' : 'y';
        }
        const swiper = this;
        const {
            params,
            rtlTranslate: rtl,
            translate,
            $wrapperEl
        } = swiper;
        if (params.virtualTranslate) {
            return rtl ? -translate : translate;
        }
        if (params.cssMode) {
            return translate;
        }
        let currentTranslate = getTranslate($wrapperEl[0], axis);
        if (rtl) currentTranslate = -currentTranslate;
        return currentTranslate || 0;
    }
    function setTranslate(translate, byController) {
        const swiper = this;
        const {
            rtlTranslate: rtl,
            params,
            $wrapperEl,
            wrapperEl,
            progress
        } = swiper;
        let x = 0;
        let y = 0;
        const z = 0;
        if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
        } else {
            y = translate;
        }
        if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
        }
        if (params.cssMode) {
            wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
        } else if (!params.virtualTranslate) {
            $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
        }
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y; 
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== progress) {
            swiper.updateProgress(translate);
        }
        swiper.emit('setTranslate', swiper.translate, byController);
    }
    function minTranslate() {
        return -this.snapGrid[0];
    }
    function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
    }
    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
        if (translate === void 0) {
            translate = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (translateBounds === void 0) {
            translateBounds = true;
        }
        const swiper = this;
        const {
            params,
            wrapperEl
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
        }
        const minTranslate = swiper.minTranslate();
        const maxTranslate = swiper.maxTranslate();
        let newTranslate;
        if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate; 
        swiper.updateProgress(newTranslate);
        if (params.cssMode) {
            const isH = swiper.isHorizontal();
            if (speed === 0) {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            } else {
                if (!swiper.support.smoothScroll) {
                    animateCSSModeScroll({
                        swiper,
                        targetPosition: -newTranslate,
                        side: isH ? 'left' : 'top'
                    });
                    return true;
                }
                wrapperEl.scrollTo({
                    [isH ? 'left' : 'top']: -newTranslate,
                    behavior: 'smooth'
                });
            }
            return true;
        }
        if (speed === 0) {
            swiper.setTransition(0);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
                swiper.emit('beforeTransitionStart', speed, internal);
                swiper.emit('transitionEnd');
            }
        } else {
            swiper.setTransition(speed);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
                swiper.emit('beforeTransitionStart', speed, internal);
                swiper.emit('transitionStart');
            }
            if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onTranslateToWrapperTransitionEnd) {
                    swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) {
                            swiper.emit('transitionEnd');
                        }
                    };
                }
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            }
        }
        return true;
    }
    var translate = {
        getTranslate: getSwiperTranslate,
        setTranslate,
        minTranslate,
        maxTranslate,
        translateTo
    };
    function setTransition(duration, byController) {
        const swiper = this;
        if (!swiper.params.cssMode) {
            swiper.$wrapperEl.transition(duration);
        }
        swiper.emit('setTransition', duration, byController);
    }
    function transitionEmit(_ref) {
        let {
            swiper,
            runCallbacks,
            direction,
            step
        } = _ref;
        const {
            activeIndex,
            previousIndex
        } = swiper;
        let dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) dir = 'next'; else if (activeIndex < previousIndex) dir = 'prev'; else dir = 'reset';
        }
        swiper.emit(`transition${step}`);
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit(`slideResetTransition${step}`);
                return;
            }
            swiper.emit(`slideChangeTransition${step}`);
            if (dir === 'next') {
                swiper.emit(`slideNextTransition${step}`);
            } else {
                swiper.emit(`slidePrevTransition${step}`);
            }
        }
    }
    function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params
        } = swiper;
        if (params.cssMode) return;
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'Start'
        });
    }
    function transitionEnd(runCallbacks, direction) {
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params
        } = swiper;
        swiper.animating = false;
        if (params.cssMode) return;
        swiper.setTransition(0);
        transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'End'
        });
    }
    var transition = {
        setTransition,
        transitionStart,
        transitionEnd
    };
    function slideTo(index, speed, runCallbacks, internal, initial) {
        if (index === void 0) {
            index = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (typeof index !== 'number' && typeof index !== 'string') {
            throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
        }
        if (typeof index === 'string') {
            /**
             * The `index` argument converted from `string` to `number`.
             * @type {number}
             */
            const indexAsNumber = parseInt(index, 10);
            /**
             * Determines whether the `index` argument is a valid `number`
             * after being converted from the `string` type.
             * @type {boolean}
             */
            const isValidNumber = isFinite(indexAsNumber);
            if (!isValidNumber) {
                throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
            } 
            index = indexAsNumber;
        }
        const swiper = this;
        let slideIndex = index;
        if (slideIndex < 0) slideIndex = 0;
        const {
            params,
            snapGrid,
            slidesGrid,
            previousIndex,
            activeIndex,
            rtlTranslate: rtl,
            wrapperEl,
            enabled
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
            return false;
        }
        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
        }
        const translate = -snapGrid[snapIndex]; 
        swiper.updateProgress(translate); 
        if (params.normalizeSlideIndex) {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                        slideIndex = i;
                    } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                        slideIndex = i + 1;
                    }
                } else if (normalizedTranslate >= normalizedGrid) {
                    slideIndex = i;
                }
            }
        } 
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
                return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) return false;
            }
        }
        let direction;
        if (slideIndex > activeIndex) direction = 'next'; else if (slideIndex < activeIndex) direction = 'prev'; else direction = 'reset'; 
        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
            swiper.updateActiveIndex(slideIndex); 
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
                swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
                swiper.transitionStart(runCallbacks, direction);
                swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
        }
        if (params.cssMode) {
            const isH = swiper.isHorizontal();
            const t = rtl ? translate : -translate;
            if (speed === 0) {
                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                if (isVirtual) {
                    swiper.wrapperEl.style.scrollSnapType = 'none';
                    swiper._immediateVirtual = true;
                }
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                if (isVirtual) {
                    requestAnimationFrame(() => {
                        swiper.wrapperEl.style.scrollSnapType = '';
                        swiper._swiperImmediateVirtual = false;
                    });
                }
            } else {
                if (!swiper.support.smoothScroll) {
                    animateCSSModeScroll({
                        swiper,
                        targetPosition: t,
                        side: isH ? 'left' : 'top'
                    });
                    return true;
                }
                wrapperEl.scrollTo({
                    [isH ? 'left' : 'top']: t,
                    behavior: 'smooth'
                });
            }
            return true;
        }
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        if (speed === 0) {
            swiper.transitionEnd(runCallbacks, direction);
        } else if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onSlideToWrapperTransitionEnd) {
                swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
            }
            swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
        return true;
    }
    function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) {
            index = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        let newIndex = index;
        if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
        }
        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            animating,
            enabled,
            params
        } = swiper;
        if (!enabled) return swiper;
        let perGroup = params.slidesPerGroup;
        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
        }
        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
        if (params.loop) {
            if (animating && params.loopPreventsSlide) return false;
            swiper.loopFix(); 
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        if (params.rewind && swiper.isEnd) {
            return swiper.slideTo(0, speed, runCallbacks, internal);
        }
        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params,
            animating,
            snapGrid,
            slidesGrid,
            rtlTranslate,
            enabled
        } = swiper;
        if (!enabled) return swiper;
        if (params.loop) {
            if (animating && params.loopPreventsSlide) return false;
            swiper.loopFix(); 
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        const translate = rtlTranslate ? swiper.translate : -swiper.translate;
        function normalize(val) {
            if (val < 0) return -Math.floor(Math.abs(val));
            return Math.floor(val);
        }
        const normalizedTranslate = normalize(translate);
        const normalizedSnapGrid = snapGrid.map(val => normalize(val));
        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        if (typeof prevSnap === 'undefined' && params.cssMode) {
            let prevSnapIndex;
            snapGrid.forEach((snap, snapIndex) => {
                if (normalizedTranslate >= snap) {
                    prevSnapIndex = snapIndex;
                }
            });
            if (typeof prevSnapIndex !== 'undefined') {
                prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
        }
        let prevIndex = 0;
        if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
                prevIndex = Math.max(prevIndex, 0);
            }
        }
        if (params.rewind && swiper.isBeginning) {
            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (threshold === void 0) {
            threshold = 0.5;
        }
        const swiper = this;
        let index = swiper.activeIndex;
        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        if (translate >= swiper.snapGrid[snapIndex]) {
            const currentSnap = swiper.snapGrid[snapIndex];
            const nextSnap = swiper.snapGrid[snapIndex + 1];
            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
                index += swiper.params.slidesPerGroup;
            }
        } else {
            const prevSnap = swiper.snapGrid[snapIndex - 1];
            const currentSnap = swiper.snapGrid[snapIndex];
            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
                index -= swiper.params.slidesPerGroup;
            }
        }
        index = Math.max(index, 0);
        index = Math.min(index, swiper.slidesGrid.length - 1);
        return swiper.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
        const swiper = this;
        const {
            params,
            $wrapperEl
        } = swiper;
        const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        let slideToIndex = swiper.clickedIndex;
        let realIndex;
        if (params.loop) {
            if (swiper.animating) return;
            realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    nextTick(() => {
                        swiper.slideTo(slideToIndex);
                    });
                } else {
                    swiper.slideTo(slideToIndex);
                }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                nextTick(() => {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else {
            swiper.slideTo(slideToIndex);
        }
    }
    var slide = {
        slideTo,
        slideToLoop,
        slideNext,
        slidePrev,
        slideReset,
        slideToClosest,
        slideToClickedSlide
    };
    function loopCreate() {
        const swiper = this;
        const document = getDocument();
        const {
            params,
            $wrapperEl
        } = swiper; 
        const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
        $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
        let slides = $selector.children(`.${params.slideClass}`);
        if (params.loopFillGroupWithBlank) {
            const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
            if (blankSlidesNum !== params.slidesPerGroup) {
                for (let i = 0; i < blankSlidesNum; i += 1) {
                    const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                    $selector.append(blankNode);
                }
                slides = $selector.children(`.${params.slideClass}`);
            }
        }
        if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
        swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
        swiper.loopedSlides += params.loopAdditionalSlides;
        if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
        }
        const prependSlides = [];
        const appendSlides = [];
        slides.each((el, index) => {
            const slide = $(el);
            if (index < swiper.loopedSlides) {
                appendSlides.push(el);
            }
            if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
                prependSlides.push(el);
            }
            slide.attr('data-swiper-slide-index', index);
        });
        for (let i = 0; i < appendSlides.length; i += 1) {
            $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
            $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
    }
    function loopFix() {
        const swiper = this;
        swiper.emit('beforeLoopFix');
        const {
            activeIndex,
            slides,
            loopedSlides,
            allowSlidePrev,
            allowSlideNext,
            snapGrid,
            rtlTranslate: rtl
        } = swiper;
        let newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        const snapTranslate = -snapGrid[activeIndex];
        const diff = snapTranslate - swiper.getTranslate(); 
        if (activeIndex < loopedSlides) {
            newIndex = slides.length - loopedSlides * 3 + activeIndex;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        } else if (activeIndex >= slides.length - loopedSlides) {
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit('loopFix');
    }
    function loopDestroy() {
        const swiper = this;
        const {
            $wrapperEl,
            params,
            slides
        } = swiper;
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
        slides.removeAttr('data-swiper-slide-index');
    }
    var loop = {
        loopCreate,
        loopFix,
        loopDestroy
    };
    function setGrabCursor(moving) {
        const swiper = this;
        if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
        const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
        el.style.cursor = 'move';
        el.style.cursor = moving ? 'grabbing' : 'grab';
    }
    function unsetGrabCursor() {
        const swiper = this;
        if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
            return;
        }
        swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }
    var grabCursor = {
        setGrabCursor,
        unsetGrabCursor
    };
    function closestElement(selector, base) {
        if (base === void 0) {
            base = this;
        }
        function __closestFrom(el) {
            if (!el || el === getDocument() || el === getWindow()) return null;
            if (el.assignedSlot) el = el.assignedSlot;
            const found = el.closest(selector);
            return found || __closestFrom(el.getRootNode().host);
        }
        return __closestFrom(base);
    }
    function onTouchStart(event) {
        const swiper = this;
        const document = getDocument();
        const window = getWindow();
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            enabled
        } = swiper;
        if (!enabled) return;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return;
        }
        if (!swiper.animating && params.cssMode && params.loop) {
            swiper.loopFix();
        }
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        let $targetEl = $(e.target);
        if (params.touchEventsTarget === 'wrapper') {
            if (!$targetEl.closest(swiper.wrapperEl).length) return;
        }
        data.isTouchEvent = e.type === 'touchstart';
        if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
        if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
        if (data.isTouched && data.isMoved) return; 
        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
        if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
            $targetEl = $(event.path[0]);
        }
        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
        const isTargetShadow = !!(e.target && e.target.shadowRoot); 
        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
            swiper.allowClick = true;
            return;
        }
        if (params.swipeHandler) {
            if (!$targetEl.closest(params.swipeHandler)[0]) return;
        }
        touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        const startX = touches.currentX;
        const startY = touches.currentY; 
        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
            if (edgeSwipeDetection === 'prevent') {
                axPreventDefault(event);
            } else {
                return;
            }
        }
        Object.assign(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined
        });
        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) data.allowThresholdMove = false;
        if (e.type !== 'touchstart') {
            let preventDefault = true;
            if ($targetEl.is(data.focusableElements)) {
                preventDefault = false;
                if ($targetEl[0].nodeName === 'SELECT') {
                    data.isTouched = false;
                }
            }
            if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
                document.activeElement.blur();
            }
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
                axPreventDefault(e);
            }
        }
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
            swiper.freeMode.onTouchStart();
        }
        swiper.emit('touchStart', e);
    }
    function onTouchMove(event) {
        const document = getDocument();
        const swiper = this;
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            rtlTranslate: rtl,
            enabled
        } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
                swiper.emit('touchMoveOpposite', e);
            }
            return;
        }
        if (data.isTouchEvent && e.type !== 'touchmove') return;
        const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
        const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
        if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
        }
        if (!swiper.allowTouchMove) {
            if (!$(e.target).is(data.focusableElements)) {
                swiper.allowClick = false;
            }
            if (data.isTouched) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY
                });
                data.touchStartTime = now();
            }
            return;
        }
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
                return;
            }
        }
        if (data.isTouchEvent && document.activeElement) {
            if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
        }
        if (data.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
        }
        if (e.targetTouches && e.targetTouches.length > 1) return;
        touches.currentX = pageX;
        touches.currentY = pageY;
        const diffX = touches.currentX - touches.startX;
        const diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
        if (typeof data.isScrolling === 'undefined') {
            let touchAngle;
            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
                data.isScrolling = false;
            } else {
                if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
        }
        if (data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
        }
        if (typeof data.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                data.startMoving = true;
            }
        }
        if (data.isScrolling) {
            data.isTouched = false;
            return;
        }
        if (!data.startMoving) {
            return;
        }
        swiper.allowClick = false;
        if (!params.cssMode && e.cancelable) {
            axPreventDefault(e);
        }
        if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
        }
        if (!data.isMoved) {
            if (params.loop && !params.cssMode) {
                swiper.loopFix();
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
                swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
            }
            data.allowMomentumBounce = false; 
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
        }
        swiper.emit('sliderMove', e);
        data.isMoved = true;
        let diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;
        if (rtl) diff = -diff;
        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
        data.currentTranslate = diff + data.startTranslate;
        let disableParentSwiper = true;
        let resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
        }
        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
        if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
        } 
        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
            data.currentTranslate = data.startTranslate;
        } 
        if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
        }
        if (!params.followFinger || params.cssMode) return; 
        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
            swiper.freeMode.onTouchMove();
        } 
        swiper.updateProgress(data.currentTranslate); 
        swiper.setTranslate(data.currentTranslate);
    }
    function onTouchEnd(event) {
        const swiper = this;
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            rtlTranslate: rtl,
            slidesGrid,
            enabled
        } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (data.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
        }
        data.allowTouchCallbacks = false;
        if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
                swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
        } 
        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
        } 
        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime; 
        if (swiper.allowClick) {
            const pathTree = e.path || e.composedPath && e.composedPath();
            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
            swiper.emit('tap click', e);
            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
                swiper.emit('doubleTap doubleClick', e);
            }
        }
        data.lastClickTime = now();
        nextTick(() => {
            if (!swiper.destroyed) swiper.allowClick = true;
        });
        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        let currentPos;
        if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
            currentPos = -data.currentTranslate;
        }
        if (params.cssMode) {
            return;
        }
        if (swiper.params.freeMode && params.freeMode.enabled) {
            swiper.freeMode.onTouchEnd({
                currentPos
            });
            return;
        } 
        let stopIndex = 0;
        let groupSize = swiper.slidesSizesGrid[0];
        for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (typeof slidesGrid[i + increment] !== 'undefined') {
                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                    stopIndex = i;
                    groupSize = slidesGrid[i + increment] - slidesGrid[i];
                }
            } else if (currentPos >= slidesGrid[i]) {
                stopIndex = i;
                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
        }
        let rewindFirstIndex = null;
        let rewindLastIndex = null;
        if (params.rewind) {
            if (swiper.isBeginning) {
                rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            } else if (swiper.isEnd) {
                rewindFirstIndex = 0;
            }
        } 
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
            }
            if (swiper.swipeDirection === 'prev') {
                if (ratio > 1 - params.longSwipesRatio) {
                    swiper.slideTo(stopIndex + increment);
                } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                    swiper.slideTo(rewindLastIndex);
                } else {
                    swiper.slideTo(stopIndex);
                }
            }
        } else {
            if (!params.shortSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
            if (!isNavButtonTarget) {
                if (swiper.swipeDirection === 'next') {
                    swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                }
                if (swiper.swipeDirection === 'prev') {
                    swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                }
            } else if (e.target === swiper.navigation.nextEl) {
                swiper.slideTo(stopIndex + increment);
            } else {
                swiper.slideTo(stopIndex);
            }
        }
    }
    function onResize() {
        const swiper = this;
        const {
            params,
            el
        } = swiper;
        if (el && el.offsetWidth === 0) return; 
        if (params.breakpoints) {
            swiper.setBreakpoint();
        } 
        const {
            allowSlideNext,
            allowSlidePrev,
            snapGrid
        } = swiper; 
        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateSlidesClasses();
        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
            swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
            swiper.autoplay.run();
        } 
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
    }
    function onClick(e) {
        const swiper = this;
        if (!swiper.enabled) return;
        if (!swiper.allowClick) {
            if (swiper.params.preventClicks){
                axPreventDefault(e);
            }
            if (swiper.params.preventClicksPropagation && swiper.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
    }
    function onScroll() {
        const swiper = this;
        const {
            wrapperEl,
            rtlTranslate,
            enabled
        } = swiper;
        if (!enabled) return;
        swiper.previousTranslate = swiper.translate;
        if (swiper.isHorizontal()) {
            swiper.translate = -wrapperEl.scrollLeft;
        } else {
            swiper.translate = -wrapperEl.scrollTop;
        } 
        if (swiper.translate === 0) swiper.translate = 0;
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== swiper.progress) {
            swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
        }
        swiper.emit('setTranslate', swiper.translate, false);
    }
    let dummyEventAttached = false;
    function dummyEventListener() { }
    const events = (swiper, method) => {
        const document = getDocument();
        const {
            params,
            touchEvents,
            el,
            wrapperEl,
            device,
            support
        } = swiper;
        const capture = !!params.nested;
        const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
        const swiperMethod = method; 
        if (!support.touch) {
            el[domMethod](touchEvents.start, swiper.onTouchStart, false);
            document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
            document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
        } else {
            const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
            el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                passive: false,
                capture
            } : capture);
            el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
        } 
        if (params.preventClicks || params.preventClicksPropagation) {
            el[domMethod]('click', swiper.onClick, true);
        }
        if (params.cssMode) {
            wrapperEl[domMethod]('scroll', swiper.onScroll);
        } 
        if (params.updateOnWindowResize) {
            swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
        } else {
            swiper[swiperMethod]('observerUpdate', onResize, true);
        }
    };
    function attachEvents() {
        const swiper = this;
        const document = getDocument();
        const {
            params,
            support
        } = swiper;
        swiper.onTouchStart = onTouchStart.bind(swiper);
        swiper.onTouchMove = onTouchMove.bind(swiper);
        swiper.onTouchEnd = onTouchEnd.bind(swiper);
        if (params.cssMode) {
            swiper.onScroll = onScroll.bind(swiper);
        }
        swiper.onClick = onClick.bind(swiper);
        if (support.touch && !dummyEventAttached) {
            document.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
        }
        events(swiper, 'on');
    }
    function detachEvents() {
        const swiper = this;
        events(swiper, 'off');
    }
    var _events = {
        attachEvents,
        detachEvents
    };
    const isGridEnabled = (swiper, params) => {
        return swiper.grid && params.grid && params.grid.rows > 1;
    };
    function setBreakpoint() {
        const swiper = this;
        const {
            activeIndex,
            initialized,
            loopedSlides = 0,
            params,
            $el
        } = swiper;
        const breakpoints = params.breakpoints;
        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; 
        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
        const breakpointParams = breakpointOnlyParams || swiper.originalParams;
        const wasMultiRow = isGridEnabled(swiper, params);
        const isMultiRow = isGridEnabled(swiper, breakpointParams);
        const wasEnabled = params.enabled;
        if (wasMultiRow && !isMultiRow) {
            $el.removeClass(`${params.containerModifierClass}grids ${params.containerModifierClass}grid-column`);
            swiper.emitContainerClasses();
        } else if (!wasMultiRow && isMultiRow) {
            $el.addClass(`${params.containerModifierClass}grids`);
            if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
                $el.addClass(`${params.containerModifierClass}grid-column`);
            }
            swiper.emitContainerClasses();
        }
        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
        if (directionChanged && initialized) {
            swiper.changeDirection();
        }
        extend(swiper.params, breakpointParams);
        const isEnabled = swiper.params.enabled;
        Object.assign(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev
        });
        if (wasEnabled && !isEnabled) {
            swiper.disable();
        } else if (!wasEnabled && isEnabled) {
            swiper.enable();
        }
        swiper.currentBreakpoint = breakpoint;
        swiper.emit('_beforeBreakpoint', breakpointParams);
        if (needsReLoop && initialized) {
            swiper.loopDestroy();
            swiper.loopCreate();
            swiper.updateSlides();
            swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
        }
        swiper.emit('breakpoint', breakpointParams);
    }
    function getBreakpoint(breakpoints, base, containerEl) {
        if (base === void 0) {
            base = 'window';
        }
        if (!breakpoints || base === 'container' && !containerEl) return undefined;
        let breakpoint = false;
        const window = getWindow();
        const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
        const points = Object.keys(breakpoints).map(point => {
            if (typeof point === 'string' && point.indexOf('@') === 0) {
                const minRatio = parseFloat(point.substr(1));
                const value = currentHeight * minRatio;
                return {
                    value,
                    point
                };
            }
            return {
                value: point,
                point
            };
        });
        points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
        for (let i = 0; i < points.length; i += 1) {
            const {
                point,
                value
            } = points[i];
            if (base === 'window') {
                if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                    breakpoint = point;
                }
            } else if (value <= containerEl.clientWidth) {
                breakpoint = point;
            }
        }
        return breakpoint || 'max';
    }
    var breakpoints = {
        setBreakpoint,
        getBreakpoint
    };
    function prepareClasses(entries, prefix) {
        const resultClasses = [];
        entries.forEach(item => {
            if (typeof item === 'object') {
                Object.keys(item).forEach(classNames => {
                    if (item[classNames]) {
                        resultClasses.push(prefix + classNames);
                    }
                });
            } else if (typeof item === 'string') {
                resultClasses.push(prefix + item);
            }
        });
        return resultClasses;
    }
    function addClasses() {
        const swiper = this;
        const {
            classNames,
            params,
            rtl,
            $el,
            device,
            support
        } = swiper; 
        const suffixes = prepareClasses(['initialized', params.direction, {
            'pointer-events': !support.touch
        }, {
                'free-mode': swiper.params.freeMode && params.freeMode.enabled
            }, {
                'autoheight': params.autoHeight
            }, {
                'rtl': rtl
            }, {
                'grids': params.grid && params.grid.rows > 1
            }, {
                'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
            }, {
                'android': device.android
            }, {
                'ios': device.ios
            }, {
                'css-mode': params.cssMode
            }, {
                'centered': params.cssMode && params.centeredSlides
            }, {
                'watch-progress': params.watchSlidesProgress
            }], params.containerModifierClass);
        classNames.push(...suffixes);
        $el.addClass([...classNames].join(' '));
        swiper.emitContainerClasses();
    }
    function removeClasses() {
        const swiper = this;
        const {
            $el,
            classNames
        } = swiper;
        $el.removeClass(classNames.join(' '));
        swiper.emitContainerClasses();
    }
    var classes = {
        addClasses,
        removeClasses
    };
    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        const window = getWindow();
        let image;
        function onReady() {
            if (callback) callback();
        }
        const isPicture = $(imageEl).parent('picture')[0];
        if (!isPicture && (!imageEl.complete || !checkForComplete)) {
            if (src) {
                image = new window.Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) {
                    image.sizes = sizes;
                }
                if (srcset) {
                    image.srcset = srcset;
                }
                if (src) {
                    image.src = src;
                }
            } else {
                onReady();
            }
        } else {
            onReady();
        }
    }
    function preloadImages() {
        const swiper = this;
        swiper.imagesToLoad = swiper.$el.find('img');
        function onReady() {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
            if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                if (swiper.params.updateOnImagesReady) swiper.update();
                swiper.emit('imagesReady');
            }
        }
        for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
            const imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
        }
    }
    var images = {
        loadImage,
        preloadImages
    };
    function checkOverflow() {
        const swiper = this;
        const {
            isLocked: wasLocked,
            params
        } = swiper;
        const {
            slidesOffsetBefore
        } = params;
        if (slidesOffsetBefore) {
            const lastSlideIndex = swiper.slides.length - 1;
            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
            swiper.isLocked = swiper.size > lastSlideRightEdge;
        } else {
            swiper.isLocked = swiper.snapGrid.length === 1;
        }
        if (params.allowSlideNext === true) {
            swiper.allowSlideNext = !swiper.isLocked;
        }
        if (params.allowSlidePrev === true) {
            swiper.allowSlidePrev = !swiper.isLocked;
        }
        if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
        }
        if (wasLocked !== swiper.isLocked) {
            swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
        }
    }
    var checkOverflow$1 = {
        checkOverflow
    };
    var defaults = {
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'wrapper',
        initialSlide: 0,
        speed: 300,
        cssMode: false,
        updateOnWindowResize: true,
        resizeObserver: true,
        nested: false,
        createElements: false,
        enabled: true,
        focusableElements: 'input, select, option, textarea, button, video, label',
        width: null,
        height: null,
        preventInteractionOnTransition: false,
        userAgent: null,
        url: null,
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        autoHeight: false,
        setWrapperSize: false,
        virtualTranslate: false,
        effect: 'slide',
        breakpoints: undefined,
        breakpointsBase: 'window',
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: false,
        centeredSlides: false,
        centeredSlidesBounds: false,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,
        watchOverflow: true,
        roundLengths: false,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: false,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,
        uniqueNavElements: true,
        resistance: true,
        resistanceRatio: 0.85,
        watchSlidesProgress: false,
        grabCursor: false,
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        preloadImages: true,
        updateOnImagesReady: true,
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        loopPreventsSlide: true,
        rewind: false,
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        noSwiping: true,
        noSwipingClass: 'ax-no-swiping',
        noSwipingSelector: null,
        passiveListeners: true,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: 'ax-',
        slideClass: 'ax-slide',
        slideBlankClass: 'ax-slide-invisible-blank',
        slideActiveClass: 'ax-slide-active',
        slideDuplicateActiveClass: 'ax-slide-duplicate-active',
        slideVisibleClass: 'ax-slide-visible',
        slideDuplicateClass: 'ax-slide-duplicate',
        slideNextClass: 'ax-slide-next',
        slideDuplicateNextClass: 'ax-slide-duplicate-next',
        slidePrevClass: 'ax-slide-prev',
        slideDuplicatePrevClass: 'ax-slide-duplicate-prev',
        wrapperClass: 'ax-wrapper',
        runCallbacksOnInit: true,
        _emitClasses: false
    };
    function moduleExtendParams(params, allModulesParams) {
        return function extendParams(obj) {
            if (obj === void 0) {
                obj = {};
            }
            const moduleParamName = Object.keys(obj)[0];
            const moduleParams = obj[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) {
                extend(allModulesParams, obj);
                return;
            }
            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
                params[moduleParamName] = {
                    auto: true
                };
            }
            if (!(moduleParamName in params && 'enabled' in moduleParams)) {
                extend(allModulesParams, obj);
                return;
            }
            if (params[moduleParamName] === true) {
                params[moduleParamName] = {
                    enabled: true
                };
            }
            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
                params[moduleParamName].enabled = true;
            }
            if (!params[moduleParamName]) params[moduleParamName] = {
                enabled: false
            };
            extend(allModulesParams, obj);
        };
    }
    /* eslint no-param-reassign: "off" */
    const prototypes = {
        eventsEmitter,
        update,
        translate,
        transition,
        slide,
        loop,
        grabCursor,
        events: _events,
        breakpoints,
        checkOverflow: checkOverflow$1,
        classes,
        images
    };
    const extendedDefaults = {};
    class Swiper {
        constructor() {
            let el;
            let params;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
                params = args[0];
            } else {
                [el, params] = args;
            }
            if (!params) params = {};
            params = extend({}, params);
            if (el && !params.el) params.el = el;
            if (params.el && $(params.el).length > 1) {
                const swipers = [];
                $(params.el).each(containerEl => {
                    const newParams = extend({}, params, {
                        el: containerEl
                    });
                    swipers.push(new Swiper(newParams));
                });
                return swipers;
            } 
            const swiper = this;
            swiper.__swiper__ = true;
            swiper.support = getSupport();
            swiper.device = getDevice({
                userAgent: params.userAgent
            });
            swiper.browser = getBrowser();
            swiper.eventsListeners = {};
            swiper.eventsAnyListeners = [];
            swiper.modules = [...swiper.__modules__];
            if (params.modules && Array.isArray(params.modules)) {
                swiper.modules.push(...params.modules);
            }
            const allModulesParams = {};
            swiper.modules.forEach(mod => {
                mod({
                    swiper,
                    extendParams: moduleExtendParams(params, allModulesParams),
                    on: swiper.on.bind(swiper),
                    once: swiper.once.bind(swiper),
                    off: swiper.off.bind(swiper),
                    emit: swiper.emit.bind(swiper)
                });
            }); 
            const swiperParams = extend({}, defaults, allModulesParams); 
            swiper.params = extend({}, swiperParams, extendedDefaults, params);
            if (typeof params.el == 'string') {
                if (swiper.params.navigation.prevEl == '.ax-prev') {
                    swiper.params.navigation.prevEl = document.querySelector(params.el + ' .ax-prev');
                }
                if (swiper.params.navigation.nextEl == '.ax-next') {
                    swiper.params.navigation.nextEl = document.querySelector(params.el + ' .ax-next');
                }
            } else {
                if (swiper.params.navigation.prevEl == '.ax-prev') {
                    swiper.params.navigation.prevEl = params.el.querySelector('.ax-prev');
                }
                if (swiper.params.navigation.nextEl == '.ax-next') {
                    swiper.params.navigation.nextEl = params.el.querySelector('.ax-next');
                }
            }
            swiper.originalParams = extend({}, swiper.params);
            swiper.passedParams = extend({}, params); 
            if (swiper.params && swiper.params.on) {
                Object.keys(swiper.params.on).forEach(eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                });
            }
            if (swiper.params && swiper.params.onAny) {
                swiper.onAny(swiper.params.onAny);
            } 
            swiper.$ = $; 
            Object.assign(swiper, {
                enabled: swiper.params.enabled,
                el,
                classNames: [],
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal() {
                    return swiper.params.direction === 'horizontal';
                },
                isVertical() {
                    return swiper.params.direction === 'vertical';
                },
                activeIndex: 0,
                realIndex: 0,
                isBeginning: true,
                isEnd: false,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: false,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: function touchEvents() {
                    const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
                    const desktop = ['pointerdown', 'pointermove', 'pointerup'];
                    swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                        cancel: touch[3]
                    };
                    swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2]
                    };
                    return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }(),
                touchEventsData: {
                    isTouched: undefined,
                    isMoved: undefined,
                    allowTouchCallbacks: undefined,
                    touchStartTime: undefined,
                    isScrolling: undefined,
                    currentTranslate: undefined,
                    startTranslate: undefined,
                    allowThresholdMove: undefined,
                    focusableElements: swiper.params.focusableElements,
                    lastClickTime: now(),
                    clickTimeout: undefined,
                    velocities: [],
                    allowMomentumBounce: undefined,
                    isTouchEvent: undefined,
                    startMoving: undefined
                },
                allowClick: true,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            });
            swiper.emit('_swiper'); 
            if (swiper.params.init) { 
                swiper.init();
            } 
            return swiper;
        }
        enable() {
            const swiper = this;
            if (swiper.enabled) return;
            swiper.enabled = true;
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }
            swiper.emit('enable');
        }
        disable() {
            const swiper = this;
            if (!swiper.enabled) return;
            swiper.enabled = false;
            if (swiper.params.grabCursor) {
                swiper.unsetGrabCursor();
            }
            swiper.emit('disable');
        }
        setProgress(progress, speed) {
            const swiper = this;
            progress = Math.min(Math.max(progress, 0), 1);
            const min = swiper.minTranslate();
            const max = swiper.maxTranslate();
            const current = (max - min) * progress + min;
            swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        emitContainerClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const cls = swiper.el.className.split(' ').filter(className => {
                return className.indexOf('ax') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
            });
            swiper.emit('_containerClasses', cls.join(' '));
        }
        getSlideClasses(slideEl) {
            const swiper = this;
            if (swiper.destroyed) return '';
            return slideEl.className.split(' ').filter(className => {
                return className.indexOf('ax-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
            }).join(' ');
        }
        emitSlidesClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const updates = [];
            swiper.slides.each(slideEl => {
                const classNames = swiper.getSlideClasses(slideEl);
                updates.push({
                    slideEl,
                    classNames
                });
                swiper.emit('_slideClass', slideEl, classNames);
            });
            swiper.emit('_slideClasses', updates);
        }
        slidesPerViewDynamic(view, exact) {
            if (view === void 0) {
                view = 'current';
            }
            if (exact === void 0) {
                exact = false;
            }
            const swiper = this;
            const {
                params,
                slides,
                slidesGrid,
                slidesSizesGrid,
                size: swiperSize,
                activeIndex
            } = swiper;
            let spv = 1;
            if (params.centeredSlides) {
                let slideSize = slides[activeIndex].swiperSlideSize;
                let breakLoop;
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
            } else {
                if (view === 'current') {
                    for (let i = activeIndex + 1; i < slides.length; i += 1) {
                        const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                        if (slideInView) {
                            spv += 1;
                        }
                    }
                } else {
                    for (let i = activeIndex - 1; i >= 0; i -= 1) {
                        const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                        if (slideInView) {
                            spv += 1;
                        }
                    }
                }
            }
            return spv;
        }
        update() {
            const swiper = this;
            if (!swiper || swiper.destroyed) return;
            const {
                snapGrid,
                params
            } = swiper; 
            if (params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            function setTranslate() {
                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            let translated;
            if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                setTranslate();
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            } else {
                if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                    translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                }
                if (!translated) {
                    setTranslate();
                }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                swiper.checkOverflow();
            }
            swiper.emit('update');
        }
        changeDirection(newDirection, needUpdate) {
            if (needUpdate === void 0) {
                needUpdate = true;
            }
            const swiper = this;
            const currentDirection = swiper.params.direction;
            if (!newDirection) {
                newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
            }
            if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
                return swiper;
            }
            swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
            swiper.emitContainerClasses();
            swiper.params.direction = newDirection;
            swiper.slides.each(slideEl => {
                if (newDirection === 'vertical') {
                    slideEl.style.width = '';
                } else {
                    slideEl.style.height = '';
                }
            });
            swiper.emit('changeDirection');
            if (needUpdate) swiper.update();
            return swiper;
        }
        mount(el) {
            const swiper = this;
            if (swiper.mounted) return true; 
            const $el = $(el || swiper.params.el);
            el = $el[0];
            if (!el) {
                return false;
            }
            el.swiper = swiper;
            const getWrapperSelector = () => {
                return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
            };
            const getWrapper = () => {
                if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                    const res = $(el.shadowRoot.querySelector(getWrapperSelector())); 
                    res.children = options => $el.children(options);
                    return res;
                }
                return $el.children(getWrapperSelector());
            }; 
            let $wrapperEl = getWrapper();
            if ($wrapperEl.length === 0 && swiper.params.createElements) {
                const document = getDocument();
                const wrapper = document.createElement('div');
                $wrapperEl = $(wrapper);
                wrapper.className = swiper.params.wrapperClass;
                $el.append(wrapper);
                $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
                    $wrapperEl.append(slideEl);
                });
            }
            Object.assign(swiper, {
                $el,
                el,
                $wrapperEl,
                wrapperEl: $wrapperEl[0],
                mounted: true,
                rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
                rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
                wrongRTL: $wrapperEl.css('display') === '-webkit-box'
            });
            return true;
        }
        init(el) {
            const swiper = this;
            if (swiper.initialized) return swiper;
            const mounted = swiper.mount(el);
            if (mounted === false) return swiper;
            swiper.emit('beforeInit'); 
            if (swiper.params.breakpoints) {
                swiper.setBreakpoint();
            } 
            swiper.addClasses(); 
            if (swiper.params.loop) {
                swiper.loopCreate();
            } 
            swiper.updateSize(); 
            swiper.updateSlides();
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            } 
            if (swiper.params.grabCursor && swiper.enabled) {
                swiper.setGrabCursor();
            }
            if (swiper.params.preloadImages) {
                swiper.preloadImages();
            } 
            if (swiper.params.loop) {
                swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
            } else {
                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
            } 
            swiper.attachEvents(); 
            swiper.initialized = true; 
            swiper.emit('init');
            swiper.emit('afterInit');
            return swiper;
        }
        destroy(deleteInstance, cleanStyles) {
            if (deleteInstance === void 0) {
                deleteInstance = true;
            }
            if (cleanStyles === void 0) {
                cleanStyles = true;
            }
            const swiper = this;
            const {
                params,
                $el,
                $wrapperEl,
                slides
            } = swiper;
            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                return null;
            }
            swiper.emit('beforeDestroy'); 
            swiper.initialized = false; 
            swiper.detachEvents(); 
            if (params.loop) {
                swiper.loopDestroy();
            } 
            if (cleanStyles) {
                swiper.removeClasses();
                $el.removeAttr('style');
                $wrapperEl.removeAttr('style');
                if (slides && slides.length) {
                    slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
                }
            }
            swiper.emit('destroy'); 
            Object.keys(swiper.eventsListeners).forEach(eventName => {
                swiper.off(eventName);
            });
            if (deleteInstance !== false) {
                swiper.$el[0].swiper = null;
                deleteProps(swiper);
            }
            swiper.destroyed = true;
            return null;
        }
        static extendDefaults(newDefaults) {
            extend(extendedDefaults, newDefaults);
        }
        static get extendedDefaults() {
            return extendedDefaults;
        }
        static get defaults() {
            return defaults;
        }
        static installModule(mod) {
            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
            const modules = Swiper.prototype.__modules__;
            if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
                modules.push(mod);
            }
        }
        static use(module) {
            if (Array.isArray(module)) {
                module.forEach(m => Swiper.installModule(m));
                return Swiper;
            }
            Swiper.installModule(module);
            return Swiper;
        }
    }
    Object.keys(prototypes).forEach(prototypeGroup => {
        Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        });
    });
    Swiper.use([Resize, Observer]);
    function Virtual(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            virtual: {
                enabled: false,
                slides: [],
                cache: true,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: true,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        let cssModeTimeout;
        swiper.virtual = {
            cache: {},
            from: undefined,
            to: undefined,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
        function renderSlide(slide, index) {
            const params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
                return swiper.virtual.cache[index];
            }
            const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
            if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
            if (params.cache) swiper.virtual.cache[index] = $slideEl;
            return $slideEl;
        }
        function update(force) {
            const {
                slidesPerView,
                slidesPerGroup,
                centeredSlides
            } = swiper.params;
            const {
                addSlidesBefore,
                addSlidesAfter
            } = swiper.params.virtual;
            const {
                from: previousFrom,
                to: previousTo,
                slides,
                slidesGrid: previousSlidesGrid,
                offset: previousOffset
            } = swiper.virtual;
            if (!swiper.params.cssMode) {
                swiper.updateActiveIndex();
            }
            const activeIndex = swiper.activeIndex || 0;
            let offsetProp;
            if (swiper.rtlTranslate) offsetProp = 'right'; else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
            let slidesAfter;
            let slidesBefore;
            if (centeredSlides) {
                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
            } else {
                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
                slidesBefore = slidesPerGroup + addSlidesBefore;
            }
            const from = Math.max((activeIndex || 0) - slidesBefore, 0);
            const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            Object.assign(swiper.virtual, {
                from,
                to,
                offset,
                slidesGrid: swiper.slidesGrid
            });
            function onRendered() {
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                if (swiper.lazy && swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
                emit('virtualUpdate');
            }
            if (previousFrom === from && previousTo === to && !force) {
                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                    swiper.slides.css(offsetProp, `${offset}px`);
                }
                swiper.updateProgress();
                emit('virtualUpdate');
                return;
            }
            if (swiper.params.virtual.renderExternal) {
                swiper.params.virtual.renderExternal.call(swiper, {
                    offset,
                    from,
                    to,
                    slides: function getSlides() {
                        const slidesToRender = [];
                        for (let i = from; i <= to; i += 1) {
                            slidesToRender.push(slides[i]);
                        }
                        return slidesToRender;
                    }()
                });
                if (swiper.params.virtual.renderExternalUpdate) {
                    onRendered();
                } else {
                    emit('virtualUpdate');
                }
                return;
            }
            const prependIndexes = [];
            const appendIndexes = [];
            if (force) {
                swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
            } else {
                for (let i = previousFrom; i <= previousTo; i += 1) {
                    if (i < from || i > to) {
                        swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                if (i >= from && i <= to) {
                    if (typeof previousTo === 'undefined' || force) {
                        appendIndexes.push(i);
                    } else {
                        if (i > previousTo) appendIndexes.push(i);
                        if (i < previousFrom) prependIndexes.push(i);
                    }
                }
            }
            appendIndexes.forEach(index => {
                swiper.$wrapperEl.append(renderSlide(slides[index], index));
            });
            prependIndexes.sort((a, b) => b - a).forEach(index => {
                swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
            swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
            onRendered();
        }
        function appendSlide(slides) {
            if (typeof slides === 'object' && 'length' in slides) {
                for (let i = 0; i < slides.length; i += 1) {
                    if (slides[i]) swiper.virtual.slides.push(slides[i]);
                }
            } else {
                swiper.virtual.slides.push(slides);
            }
            update(true);
        }
        function prependSlide(slides) {
            const activeIndex = swiper.activeIndex;
            let newActiveIndex = activeIndex + 1;
            let numberOfNewSlides = 1;
            if (Array.isArray(slides)) {
                for (let i = 0; i < slides.length; i += 1) {
                    if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
                }
                newActiveIndex = activeIndex + slides.length;
                numberOfNewSlides = slides.length;
            } else {
                swiper.virtual.slides.unshift(slides);
            }
            if (swiper.params.virtual.cache) {
                const cache = swiper.virtual.cache;
                const newCache = {};
                Object.keys(cache).forEach(cachedIndex => {
                    const $cachedEl = cache[cachedIndex];
                    const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
                    if (cachedElIndex) {
                        $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
                    }
                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
                });
                swiper.virtual.cache = newCache;
            }
            update(true);
            swiper.slideTo(newActiveIndex, 0);
        }
        function removeSlide(slidesIndexes) {
            if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
            let activeIndex = swiper.activeIndex;
            if (Array.isArray(slidesIndexes)) {
                for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                    swiper.virtual.slides.splice(slidesIndexes[i], 1);
                    if (swiper.params.virtual.cache) {
                        delete swiper.virtual.cache[slidesIndexes[i]];
                    }
                    if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                    activeIndex = Math.max(activeIndex, 0);
                }
            } else {
                swiper.virtual.slides.splice(slidesIndexes, 1);
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes];
                }
                if (slidesIndexes < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
            }
            update(true);
            swiper.slideTo(activeIndex, 0);
        }
        function removeAllSlides() {
            swiper.virtual.slides = [];
            if (swiper.params.virtual.cache) {
                swiper.virtual.cache = {};
            }
            update(true);
            swiper.slideTo(0, 0);
        }
        on('beforeInit', () => {
            if (!swiper.params.virtual.enabled) return;
            swiper.virtual.slides = swiper.params.virtual.slides;
            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
            if (!swiper.params.initialSlide) {
                update();
            }
        });
        on('setTranslate', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode && !swiper._immediateVirtual) {
                clearTimeout(cssModeTimeout);
                cssModeTimeout = setTimeout(() => {
                    update();
                }, 100);
            } else {
                update();
            }
        });
        on('init update resize', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode) {
                setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
            }
        });
        Object.assign(swiper.virtual, {
            appendSlide,
            prependSlide,
            removeSlide,
            removeAllSlides,
            update
        });
    }
    /* eslint-disable consistent-return */
    function Keyboard(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const document = getDocument();
        const window = getWindow();
        swiper.keyboard = {
            enabled: false
        };
        extendParams({
            keyboard: {
                enabled: false,
                onlyInViewport: true,
                pageUpDown: true
            }
        });
        function handle(event) {
            if (!swiper.enabled) return;
            const {
                rtlTranslate: rtl
            } = swiper;
            let e = event;
            if (e.originalEvent) e = e.originalEvent; 
            const kc = e.keyCode || e.charCode;
            const pageUpDown = swiper.params.keyboard.pageUpDown;
            const isPageUp = pageUpDown && kc === 33;
            const isPageDown = pageUpDown && kc === 34;
            const isArrowLeft = kc === 37;
            const isArrowRight = kc === 39;
            const isArrowUp = kc === 38;
            const isArrowDown = kc === 40; 
            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
                return false;
            }
            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return undefined;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
                let inView = false; 
                if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
                    return undefined;
                }
                const $el = swiper.$el;
                const swiperWidth = $el[0].clientWidth;
                const swiperHeight = $el[0].clientHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const swiperOffset = swiper.$el.offset();
                if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
                const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
                for (let i = 0; i < swiperCoord.length; i += 1) {
                    const point = swiperCoord[i];
                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                        if (point[0] === 0 && point[1] === 0) continue; 
                        inView = true;
                    }
                }
                if (!inView) return undefined;
            }
            if (swiper.isHorizontal()) {
                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                    axPreventDefault(e);
                }
                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
            } else {
                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                    axPreventDefault(e);
                }
                if (isPageDown || isArrowDown) swiper.slideNext();
                if (isPageUp || isArrowUp) swiper.slidePrev();
            }
            emit('keyPress', kc);
            return undefined;
        }
        function enable() {
            if (swiper.keyboard.enabled) return;
            $(document).on('keydown', handle);
            swiper.keyboard.enabled = true;
        }
        function disable() {
            if (!swiper.keyboard.enabled) return;
            $(document).off('keydown', handle);
            swiper.keyboard.enabled = false;
        }
        on('init', () => {
            if (swiper.params.keyboard.enabled) {
                enable();
            }
        });
        on('destroy', () => {
            if (swiper.keyboard.enabled) {
                disable();
            }
        });
        Object.assign(swiper.keyboard, {
            enable,
            disable
        });
    }
    /* eslint-disable consistent-return */
    function Mousewheel(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const window = getWindow();
        extendParams({
            mousewheel: {
                enabled: false,
                releaseOnEdges: false,
                invert: false,
                forceToAxis: false,
                sensitivity: 1,
                eventsTarget: 'container',
                thresholdDelta: null,
                thresholdTime: null
            }
        });
        swiper.mousewheel = {
            enabled: false
        };
        let timeout;
        let lastScrollTime = now();
        let lastEventBeforeSnap;
        const recentWheelEvents = [];
        function normalize(e) {
            const PIXEL_STEP = 10;
            const LINE_HEIGHT = 40;
            const PAGE_HEIGHT = 800;
            let sX = 0;
            let sY = 0; 
            let pX = 0;
            let pY = 0; 
            if ('detail' in e) {
                sY = e.detail;
            }
            if ('wheelDelta' in e) {
                sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
                sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
                sX = -e.wheelDeltaX / 120;
            } 
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
            if ('deltaY' in e) {
                pY = e.deltaY;
            }
            if ('deltaX' in e) {
                pX = e.deltaX;
            }
            if (e.shiftKey && !pX) {
                pX = pY;
                pY = 0;
            }
            if ((pX || pY) && e.deltaMode) {
                if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            } 
            if (pX && !sX) {
                sX = pX < 1 ? -1 : 1;
            }
            if (pY && !sY) {
                sY = pY < 1 ? -1 : 1;
            }
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }
        function handleMouseEnter() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = true;
        }
        function handleMouseLeave() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = false;
        }
        function animateSlider(newEvent) {
            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
                return false;
            }
            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
                return false;
            } 
            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
                return true;
            } 
            if (newEvent.direction < 0) {
                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                    swiper.slideNext();
                    emit('scroll', newEvent.raw);
                }
            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                swiper.slidePrev();
                emit('scroll', newEvent.raw);
            } 
            lastScrollTime = new window.Date().getTime(); 
            return false;
        }
        function releaseScroll(newEvent) {
            const params = swiper.params.mousewheel;
            if (newEvent.direction < 0) {
                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                    return true;
                }
            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
                return true;
            }
            return false;
        }
        function handle(event) {
            let e = event;
            let disableParentSwiper = true;
            if (!swiper.enabled) return;
            const params = swiper.params.mousewheel;
            if (swiper.params.cssMode) {
                axPreventDefault(e);
            }
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarget);
            }
            if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
            if (e.originalEvent) e = e.originalEvent; 
            let delta = 0;
            const rtlFactor = swiper.rtlTranslate ? -1 : 1;
            const data = normalize(e);
            if (params.forceToAxis) {
                if (swiper.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true;
                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true;
            } else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }
            if (delta === 0) return true;
            if (params.invert) delta = -delta; 
            let positions = swiper.getTranslate() + delta * params.sensitivity;
            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); 
            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta),
                    raw: event
                }; 
                if (recentWheelEvents.length >= 2) {
                    recentWheelEvents.shift(); 
                }
                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                recentWheelEvents.push(newEvent); 
                if (prevEvent) {
                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                        animateSlider(newEvent);
                    }
                } else {
                    animateSlider(newEvent);
                } 
                if (releaseScroll(newEvent)) {
                    return true;
                }
            } else {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta)
                };
                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                if (!ignoreWheelEvents) {
                    lastEventBeforeSnap = undefined;
                    if (swiper.params.loop) {
                        swiper.loopFix();
                    }
                    let position = swiper.getTranslate() + delta * params.sensitivity;
                    const wasBeginning = swiper.isBeginning;
                    const wasEnd = swiper.isEnd;
                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                    swiper.setTransition(0);
                    swiper.setTranslate(position);
                    swiper.updateProgress();
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                        swiper.updateSlidesClasses();
                    }
                    if (swiper.params.freeMode.sticky) {
                        clearTimeout(timeout);
                        timeout = undefined;
                        if (recentWheelEvents.length >= 15) {
                            recentWheelEvents.shift(); 
                        }
                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                        const firstEvent = recentWheelEvents[0];
                        recentWheelEvents.push(newEvent);
                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                            recentWheelEvents.splice(0);
                        } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                            lastEventBeforeSnap = newEvent;
                            recentWheelEvents.splice(0);
                            timeout = nextTick(() => {
                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                            }, 0); 
                        }
                        if (!timeout) {
                            timeout = nextTick(() => {
                                const snapToThreshold = 0.5;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                            }, 500);
                        }
                    } 
                    if (!ignoreWheelEvents) emit('scroll', e); 
                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); 
                    if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
                }
            }
            axPreventDefault(e);
            return false;
        }
        function events(method) {
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarget);
            }
            target[method]('mouseenter', handleMouseEnter);
            target[method]('mouseleave', handleMouseLeave);
            target[method]('wheel', handle);
        }
        function enable() {
            if (swiper.params.cssMode) {
                swiper.wrapperEl.removeEventListener('wheel', handle);
                return true;
            }
            if (swiper.mousewheel.enabled) return false;
            events('on');
            swiper.mousewheel.enabled = true;
            return true;
        }
        function disable() {
            if (swiper.params.cssMode) {
                swiper.wrapperEl.addEventListener(event, handle);
                return true;
            }
            if (!swiper.mousewheel.enabled) return false;
            events('off');
            swiper.mousewheel.enabled = false;
            return true;
        }
        on('init', () => {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                disable();
            }
            if (swiper.params.mousewheel.enabled) enable();
        });
        on('destroy', () => {
            if (swiper.params.cssMode) {
                enable();
            }
            if (swiper.mousewheel.enabled) disable();
        });
        Object.assign(swiper.mousewheel, {
            enable,
            disable
        });
    }
    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
        const document = getDocument();
        if (swiper.params.createElements) {
            Object.keys(checkProps).forEach(key => {
                if (!params[key] && params.auto === true) {
                    let element = swiper.$el.children(`.${checkProps[key]}`)[0];
                    if (!element) {
                        element = document.createElement('div');
                        element.className = checkProps[key];
                        swiper.$el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            });
        }
        return params;
    }
    function Navigation(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            navigation: {
                nextEl: '.ax-next',
                prevEl: '.ax-prev',
                hideOnClick: false,
                disabledClass: 'ax-disabled',
                hiddenClass: 'ax-hidden',
                lockClass: 'ax-lock'
            }
        });
        swiper.navigation = {
            nextEl: null,
            $nextEl: null,
            prevEl: null,
            $prevEl: null
        };
        function getEl(el) {
            let $el;
            if (el) {
                $el = $(el);
                if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
                    $el = swiper.$el.find(el);
                }
            }
            return $el;
        }
        function toggleEl($el, disabled) {
            const params = swiper.params.navigation;
            if ($el && $el.length > 0) {
                $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
                if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
                if (swiper.params.watchOverflow && swiper.enabled) {
                    $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
                }
            }
        }
        function update() {
            if (swiper.params.loop) return;
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
            toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
        }
        function onPrevClick(e) {
            axPreventDefault(e);
            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slidePrev();
        }
        function onNextClick(e) {
            axPreventDefault(e);
            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slideNext();
        }
        function init() {
            const params = swiper.params.navigation;
            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                nextEl: 'ax-next',
                prevEl: 'ax-prev'
            });
            if (!(params.nextEl || params.prevEl)) return;
            const $nextEl = getEl(params.nextEl);
            const $prevEl = getEl(params.prevEl);
            if ($nextEl && $nextEl.length > 0) {
                $nextEl.on('click', onNextClick);
            }
            if ($prevEl && $prevEl.length > 0) {
                $prevEl.on('click', onPrevClick);
            }
            Object.assign(swiper.navigation, {
                $nextEl,
                nextEl: $nextEl && $nextEl[0],
                $prevEl,
                prevEl: $prevEl && $prevEl[0]
            });
            if (!swiper.enabled) {
                if ($nextEl) $nextEl.addClass(params.lockClass);
                if ($prevEl) $prevEl.addClass(params.lockClass);
            }
        }
        function destroy() {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($nextEl && $nextEl.length) {
                $nextEl.off('click', onNextClick);
                $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
                $prevEl.off('click', onPrevClick);
                $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
        }
        on('init', () => {
            init();
            update();
        });
        on('toEdge fromEdge lock unlock', () => {
            update();
        });
        on('destroy', () => {
            destroy();
        });
        on('enable disable', () => {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($nextEl) {
                $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
            }
            if ($prevEl) {
                $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
            }
        });
        on('click', (_s, e) => {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            const targetEl = e.target;
            if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                let isHidden;
                if ($nextEl) {
                    isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                } else if ($prevEl) {
                    isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                }
                if (isHidden === true) {
                    emit('navigationShow');
                } else {
                    emit('navigationHide');
                }
                if ($nextEl) {
                    $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
                if ($prevEl) {
                    $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }
        });
        Object.assign(swiper.navigation, {
            update,
            init,
            destroy
        });
    }
    function classesToSelector(classes) {
        if (classes === void 0) {
            classes = '';
        }
        return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') 
            .replace(/ /g, '.')}`;
    }
    function Pagination(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const pfx = 'ax-pages';
        extendParams({
            pagination: {
                el: '.' + pfx,
                bulletElement: 'i',
                clickable: true,
                hideOnClick: false,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: false,
                type: 'bullets',
                dynamicBullets: false,
                dynamicMainBullets: 1,
                formatFractionCurrent: number => number,
                formatFractionTotal: number => number,
                bulletClass: `${pfx}-bullet`,
                bulletActiveClass: `${pfx}-bullet-active`,
                modifierClass: `${pfx}-`,
                currentClass: `${pfx}-current`,
                totalClass: `${pfx}-total`,
                hiddenClass: `${pfx}-hidden`,
                progressbarFillClass: `${pfx}-progressbar-fill`,
                progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                clickableClass: `${pfx}-clickable`,
                lockClass: `${pfx}-lock`,
                horizontalClass: `${pfx}-horizontal`,
                verticalClass: `${pfx}-vertical`
            }
        });
        swiper.pagination = {
            el: null,
            $el: null,
            bullets: []
        };
        let bulletSize;
        let dynamicBulletIndex = 0;
        function isPaginationDisabled() {
            return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
        }
        function setSideBullets($bulletEl, position) {
            const {
                bulletActiveClass
            } = swiper.params.pagination;
            $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
        }
        function update() {
            const rtl = swiper.rtl;
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el; 
            let current;
            const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
                current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
                    current -= slidesLength - swiper.loopedSlides * 2;
                }
                if (current > total - 1) current -= total;
                if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
            } else if (typeof swiper.snapIndex !== 'undefined') {
                current = swiper.snapIndex;
            } else {
                current = swiper.activeIndex || 0;
            } 
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                const bullets = swiper.pagination.bullets;
                let firstIndex;
                let lastIndex;
                let midIndex;
                if (params.dynamicBullets) {
                    bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
                    $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);
                    if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                        dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                            dynamicBulletIndex = params.dynamicMainBullets - 1;
                        } else if (dynamicBulletIndex < 0) {
                            dynamicBulletIndex = 0;
                        }
                    }
                    firstIndex = Math.max(current - dynamicBulletIndex, 0);
                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                    midIndex = (lastIndex + firstIndex) / 2;
                }
                bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));
                if ($el.length > 1) {
                    bullets.each(bullet => {
                        const $bullet = $(bullet);
                        const bulletIndex = $bullet.index();
                        if (bulletIndex === current) {
                            $bullet.addClass(params.bulletActiveClass);
                        }
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                $bullet.addClass(`${params.bulletActiveClass}-main`);
                            }
                            if (bulletIndex === firstIndex) {
                                setSideBullets($bullet, 'prev');
                            }
                            if (bulletIndex === lastIndex) {
                                setSideBullets($bullet, 'next');
                            }
                        }
                    });
                } else {
                    const $bullet = bullets.eq(current);
                    const bulletIndex = $bullet.index();
                    $bullet.addClass(params.bulletActiveClass);
                    if (params.dynamicBullets) {
                        const $firstDisplayedBullet = bullets.eq(firstIndex);
                        const $lastDisplayedBullet = bullets.eq(lastIndex);
                        for (let i = firstIndex; i <= lastIndex; i += 1) {
                            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                        }
                        if (swiper.params.loop) {
                            if (bulletIndex >= bullets.length) {
                                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                                }
                                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                            } else {
                                setSideBullets($firstDisplayedBullet, 'prev');
                                setSideBullets($lastDisplayedBullet, 'next');
                            }
                        } else {
                            setSideBullets($firstDisplayedBullet, 'prev');
                            setSideBullets($lastDisplayedBullet, 'next');
                        }
                    }
                }
                if (params.dynamicBullets) {
                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                    const offsetProp = rtl ? 'right' : 'left';
                    bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
                }
            }
            if (params.type === 'fraction') {
                $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
                $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
            }
            if (params.type === 'progressbar') {
                let progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                } else {
                    progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                }
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === 'horizontal') {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
            }
            if (params.type === 'custom' && params.renderCustom) {
                $el.html(params.renderCustom(swiper, current + 1, total));
                emit('paginationRender', $el[0]);
            } else {
                emit('paginationUpdate', $el[0]);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
        }
        function render() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el;
            let paginationHTML = '';
            if (params.type === 'bullets') {
                let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
                    numberOfBullets = slidesLength;
                }
                for (let i = 0; i < numberOfBullets; i += 1) {
                    if (params.renderBullet) {
                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                    } else {
                        paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
                    }
                }
                $el.html(paginationHTML);
                swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
            }
            if (params.type === 'fraction') {
                if (params.renderFraction) {
                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                } else {
                    paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type === 'progressbar') {
                if (params.renderProgressbar) {
                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                } else {
                    paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type !== 'custom') {
                emit('paginationRender', swiper.pagination.$el[0]);
            }
        }
        function init() {
            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                el: 'ax-pages'
            });
            const params = swiper.params.pagination;
            if (!params.el) return;
            let $el = $(params.el);
            if ($el.length === 0) return;
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
                $el = swiper.$el.find(params.el); 
                if ($el.length > 1) {
                    $el = $el.filter(el => {
                        if ($(el).parents('.swiper')[0] !== swiper.el) return false;
                        return true;
                    });
                }
            }
            if (params.type === 'bullets' && params.clickable) {
                $el.addClass(params.clickableClass);
            }
            $el.addClass(params.modifierClass + params.type);
            $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (params.type === 'bullets' && params.dynamicBullets) {
                $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
                dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === 'progressbar' && params.progressbarOpposite) {
                $el.addClass(params.progressbarOppositeClass);
            }
            if (params.clickable) {
                $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
                    axPreventDefault(e);
                    let index = $(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) index += swiper.loopedSlides;
                    swiper.slideTo(index);
                });
            }
            Object.assign(swiper.pagination, {
                $el,
                el: $el[0]
            });
            if (!swiper.enabled) {
                $el.addClass(params.lockClass);
            }
        }
        function destroy() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const $el = swiper.pagination.$el;
            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
            if (params.clickable) {
                $el.off('click', classesToSelector(params.bulletClass));
            }
        }
        on('init', () => {
            init();
            render();
            update();
        });
        on('activeIndexChange', () => {
            if (swiper.params.loop) {
                update();
            } else if (typeof swiper.snapIndex === 'undefined') {
                update();
            }
        });
        on('snapIndexChange', () => {
            if (!swiper.params.loop) {
                update();
            }
        });
        on('slidesLengthChange', () => {
            if (swiper.params.loop) {
                render();
                update();
            }
        });
        on('snapGridLengthChange', () => {
            if (!swiper.params.loop) {
                render();
                update();
            }
        });
        on('destroy', () => {
            destroy();
        });
        on('enable disable', () => {
            const {
                $el
            } = swiper.pagination;
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
            }
        });
        on('lock unlock', () => {
            update();
        });
        on('click', (_s, e) => {
            const targetEl = e.target;
            const {
                $el
            } = swiper.pagination;
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
                if (isHidden === true) {
                    emit('paginationShow');
                } else {
                    emit('paginationHide');
                }
                $el.toggleClass(swiper.params.pagination.hiddenClass);
            }
        });
        Object.assign(swiper.pagination, {
            render,
            update,
            init,
            destroy
        });
    }
    function Scrollbar(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const document = getDocument();
        let isTouched = false;
        let timeout = null;
        let dragTimeout = null;
        let dragStartPos;
        let dragSize;
        let trackSize;
        let divider;
        extendParams({
            scrollbar: {
                el: '.ax-scrollbar',
                dragSize: 'auto',
                hide: true,
                draggable: true,
                snapOnRelease: true,
                lockClass: 'ax-scrollbar-lock',
                dragClass: 'ax-scrollbar-drag'
            }
        });
        swiper.scrollbar = {
            el: null,
            dragEl: null,
            $el: null,
            $dragEl: null
        };
        function setTranslate() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar,
                rtlTranslate: rtl,
                progress
            } = swiper;
            const {
                $dragEl,
                $el
            } = scrollbar;
            const params = swiper.params.scrollbar;
            let newSize = dragSize;
            let newPos = (trackSize - dragSize) * progress;
            if (rtl) {
                newPos = -newPos;
                if (newPos > 0) {
                    newSize = dragSize - newPos;
                    newPos = 0;
                } else if (-newPos + dragSize > trackSize) {
                    newSize = trackSize + newPos;
                }
            } else if (newPos < 0) {
                newSize = dragSize + newPos;
                newPos = 0;
            } else if (newPos + dragSize > trackSize) {
                newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
                $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
                $dragEl[0].style.width = `${newSize}px`;
            } else {
                $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
                $dragEl[0].style.height = `${newSize}px`;
            }
            if (params.hide) {
                clearTimeout(timeout);
                $el[0].style.opacity = 1;
                timeout = setTimeout(() => {
                    $el[0].style.opacity = 0;
                    $el.transition(400);
                }, 1000);
            }
        }
        function setTransition(duration) {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            swiper.scrollbar.$dragEl.transition(duration);
        }
        function updateSize() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar
            } = swiper;
            const {
                $dragEl,
                $el
            } = scrollbar;
            $dragEl[0].style.width = '';
            $dragEl[0].style.height = '';
            trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
            if (swiper.params.scrollbar.dragSize === 'auto') {
                dragSize = trackSize * divider;
            } else {
                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
            if (swiper.isHorizontal()) {
                $dragEl[0].style.width = `${dragSize}px`;
            } else {
                $dragEl[0].style.height = `${dragSize}px`;
            }
            if (divider >= 1) {
                $el[0].style.display = 'none';
            } else {
                $el[0].style.display = '';
            }
            if (swiper.params.scrollbar.hide) {
                $el[0].style.opacity = 0;
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
            }
        }
        function getPointerPosition(e) {
            if (swiper.isHorizontal()) {
                return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
            }
            return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
        }
        function setDragPosition(e) {
            const {
                scrollbar,
                rtlTranslate: rtl
            } = swiper;
            const {
                $el
            } = scrollbar;
            let positionRatio;
            positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
                positionRatio = 1 - positionRatio;
            }
            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        function onDragStart(e) {
            const params = swiper.params.scrollbar;
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el,
                $dragEl
            } = scrollbar;
            isTouched = true;
            dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
            axPreventDefault(e);
            e.stopPropagation();
            $wrapperEl.transition(100);
            $dragEl.transition(100);
            setDragPosition(e);
            clearTimeout(dragTimeout);
            $el.transition(0);
            if (params.hide) {
                $el.css('opacity', 1);
            }
            if (swiper.params.cssMode) {
                swiper.$wrapperEl.css('scroll-snap-type', 'none');
            }
            emit('scrollbarDragStart', e);
        }
        function onDragMove(e) {
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el,
                $dragEl
            } = scrollbar;
            if (!isTouched) return;
            axPreventDefault(e);
            setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            emit('scrollbarDragMove', e);
        }
        function onDragEnd(e) {
            const params = swiper.params.scrollbar;
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el
            } = scrollbar;
            if (!isTouched) return;
            isTouched = false;
            if (swiper.params.cssMode) {
                swiper.$wrapperEl.css('scroll-snap-type', '');
                $wrapperEl.transition('');
            }
            if (params.hide) {
                clearTimeout(dragTimeout);
                dragTimeout = nextTick(() => {
                    $el.css('opacity', 0);
                    $el.transition(400);
                }, 1000);
            }
            emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
                swiper.slideToClosest();
            }
        }
        function events(method) {
            const {
                scrollbar,
                touchEventsTouch,
                touchEventsDesktop,
                params,
                support
            } = swiper;
            const $el = scrollbar.$el;
            const target = $el[0];
            const activeListener = support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            const passiveListener = support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!target) return;
            const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
            if (!support.touch) {
                target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
                document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
                document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
            } else {
                target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
                target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
                target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
            }
        }
        function enableDraggable() {
            if (!swiper.params.scrollbar.el) return;
            events('on');
        }
        function disableDraggable() {
            if (!swiper.params.scrollbar.el) return;
            events('off');
        }
        function init() {
            const {
                scrollbar,
                $el: $swiperEl
            } = swiper;
            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
                el: 'ax-scrollbar'
            });
            const params = swiper.params.scrollbar;
            if (!params.el) return;
            let $el = $(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
                $el = $swiperEl.find(params.el);
            }
            let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
            if ($dragEl.length === 0) {
                $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
                $el.append($dragEl);
            }
            Object.assign(scrollbar, {
                $el,
                el: $el[0],
                $dragEl,
                dragEl: $dragEl[0]
            });
            if (params.draggable) {
                enableDraggable();
            }
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
            }
        }
        function destroy() {
            disableDraggable();
        }
        on('init', () => {
            init();
            updateSize();
            setTranslate();
        });
        on('update resize observerUpdate lock unlock', () => {
            updateSize();
        });
        on('setTranslate', () => {
            setTranslate();
        });
        on('setTransition', (_s, duration) => {
            setTransition(duration);
        });
        on('enable disable', () => {
            const {
                $el
            } = swiper.scrollbar;
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
            }
        });
        on('destroy', () => {
            destroy();
        });
        Object.assign(swiper.scrollbar, {
            updateSize,
            setTranslate,
            init,
            destroy
        });
    }
    function Parallax(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            parallax: {
                enabled: false
            }
        });
        const setTransform = (el, progress) => {
            const {
                rtl
            } = swiper;
            const $el = $(el);
            const rtlFactor = rtl ? -1 : 1;
            const p = $el.attr('data-swiper-parallax') || '0';
            let x = $el.attr('data-swiper-parallax-x');
            let y = $el.attr('data-swiper-parallax-y');
            const scale = $el.attr('data-swiper-parallax-scale');
            const opacity = $el.attr('data-swiper-parallax-opacity');
            if (x || y) {
                x = x || '0';
                y = y || '0';
            } else if (swiper.isHorizontal()) {
                x = p;
                y = '0';
            } else {
                y = p;
                x = '0';
            }
            if (x.indexOf('%') >= 0) {
                x = `${parseInt(x, 10) * progress * rtlFactor}%`;
            } else {
                x = `${x * progress * rtlFactor}px`;
            }
            if (y.indexOf('%') >= 0) {
                y = `${parseInt(y, 10) * progress}%`;
            } else {
                y = `${y * progress}px`;
            }
            if (typeof opacity !== 'undefined' && opacity !== null) {
                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
                $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === 'undefined' || scale === null) {
                $el.transform(`translate3d(${x}, ${y}, 0px)`);
            } else {
                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
                $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
            }
        };
        const setTranslate = () => {
            const {
                $el,
                slides,
                progress,
                snapGrid
            } = swiper;
            $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
                setTransform(el, progress);
            });
            slides.each((slideEl, slideIndex) => {
                let slideProgress = slideEl.progress;
                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                    slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
                }
                slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
                    setTransform(el, slideProgress);
                });
            });
        };
        const setTransition = function (duration) {
            if (duration === void 0) {
                duration = swiper.params.speed;
            }
            const {
                $el
            } = swiper;
            $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
                const $parallaxEl = $(parallaxEl);
                let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
                if (duration === 0) parallaxDuration = 0;
                $parallaxEl.transition(parallaxDuration);
            });
        };
        on('beforeInit', () => {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        });
        on('init', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
        });
        on('setTranslate', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
        });
        on('setTransition', (_swiper, duration) => {
            if (!swiper.params.parallax.enabled) return;
            setTransition(duration);
        });
    }
    function Zoom(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const window = getWindow();
        extendParams({
            zoom: {
                enabled: false,
                maxRatio: 3,
                minRatio: 1,
                toggle: true,
                containerClass: 'ax-zoom',
                zoomedSlideClass: 'ax-slide-zoomed'
            }
        });
        swiper.zoom = {
            enabled: false
        };
        let currentScale = 1;
        let isScaling = false;
        let gesturesEnabled;
        let fakeGestureTouched;
        let fakeGestureMoved;
        const gesture = {
            $slideEl: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            $imageEl: undefined,
            $imageWrapEl: undefined,
            maxRatio: 3
        };
        const image = {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {}
        };
        const velocity = {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined
        };
        let scale = 1;
        Object.defineProperty(swiper.zoom, 'scale', {
            get() {
                return scale;
            },
            set(value) {
                if (scale !== value) {
                    const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
                    const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
                    emit('zoomChange', value, imageEl, slideEl);
                }
                scale = value;
            }
        });
        function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) return 1;
            const x1 = e.targetTouches[0].pageX;
            const y1 = e.targetTouches[0].pageY;
            const x2 = e.targetTouches[1].pageX;
            const y2 = e.targetTouches[1].pageY;
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            return distance;
        } 
        function onGestureStart(e) {
            const support = swiper.support;
            const params = swiper.params.zoom;
            fakeGestureTouched = false;
            fakeGestureMoved = false;
            if (!support.gestures) {
                if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
                    return;
                }
                fakeGestureTouched = true;
                gesture.scaleStart = getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
                gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
                if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
                gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
                if (gesture.$imageWrapEl.length === 0) {
                    gesture.$imageEl = undefined;
                    return;
                }
            }
            if (gesture.$imageEl) {
                gesture.$imageEl.transition(0);
            }
            isScaling = true;
        }
        function onGestureChange(e) {
            const support = swiper.support;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            if (!support.gestures) {
                if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
                    return;
                }
                fakeGestureMoved = true;
                gesture.scaleMove = getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                if (e.type === 'gesturechange') onGestureStart(e);
                return;
            }
            if (support.gestures) {
                zoom.scale = e.scale * currentScale;
            } else {
                zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
                zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
            }
            if (zoom.scale < params.minRatio) {
                zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
            }
            gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }
        function onGestureEnd(e) {
            const device = swiper.device;
            const support = swiper.support;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            if (!support.gestures) {
                if (!fakeGestureTouched || !fakeGestureMoved) {
                    return;
                }
                if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
                    return;
                }
                fakeGestureTouched = false;
                fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
            currentScale = zoom.scale;
            isScaling = false;
            if (zoom.scale === 1) gesture.$slideEl = undefined;
        }
        function onTouchStart(e) {
            const device = swiper.device;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (image.isTouched) return;
            if (device.android && e.cancelable){
                axPreventDefault(e);
            } 
            image.isTouched = true;
            image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        }
        function onTouchMove(e) {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) return;
            if (!image.isMoved) {
                image.width = gesture.$imageEl[0].offsetWidth;
                image.height = gesture.$imageEl[0].offsetHeight;
                image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
                image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
                gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
                gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
                gesture.$imageWrapEl.transition(0);
            } 
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
            if (!image.isMoved && !isScaling) {
                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                    image.isTouched = false;
                    return;
                }
                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                    image.isTouched = false;
                    return;
                }
            }
            if (e.cancelable) {
                axPreventDefault(e);
            }
            e.stopPropagation();
            image.isMoved = true;
            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
            if (image.currentX < image.minX) {
                image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
            }
            if (image.currentX > image.maxX) {
                image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
            }
            if (image.currentY < image.minY) {
                image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
            }
            if (image.currentY > image.maxY) {
                image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
            } 
            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
            if (!velocity.prevTime) velocity.prevTime = Date.now();
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
            gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }
        function onTouchEnd() {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (!image.isTouched || !image.isMoved) {
                image.isTouched = false;
                image.isMoved = false;
                return;
            }
            image.isTouched = false;
            image.isMoved = false;
            let momentumDurationX = 300;
            let momentumDurationY = 300;
            const momentumDistanceX = velocity.x * momentumDurationX;
            const newPositionX = image.currentX + momentumDistanceX;
            const momentumDistanceY = velocity.y * momentumDurationY;
            const newPositionY = image.currentY + momentumDistanceY; 
            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX;
            image.currentY = newPositionY; 
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
            gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }
        function onTransitionEnd() {
            const zoom = swiper.zoom;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
                if (gesture.$imageEl) {
                    gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
                }
                if (gesture.$imageWrapEl) {
                    gesture.$imageWrapEl.transform('translate3d(0,0,0)');
                }
                zoom.scale = 1;
                currentScale = 1;
                gesture.$slideEl = undefined;
                gesture.$imageEl = undefined;
                gesture.$imageWrapEl = undefined;
            }
        }
        function zoomIn(e) {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.$slideEl) {
                if (e && e.target) {
                    gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
                }
                if (!gesture.$slideEl) {
                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
                    } else {
                        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                    }
                }
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
            if (swiper.params.cssMode) {
                swiper.wrapperEl.style.overflow = 'hidden';
                swiper.wrapperEl.style.touchAction = 'none';
            }
            gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
            let touchX;
            let touchY;
            let offsetX;
            let offsetY;
            let diffX;
            let diffY;
            let translateX;
            let translateY;
            let imageWidth;
            let imageHeight;
            let scaledWidth;
            let scaledHeight;
            let translateMinX;
            let translateMinY;
            let translateMaxX;
            let translateMaxY;
            let slideWidth;
            let slideHeight;
            if (typeof image.touchesStart.x === 'undefined' && e) {
                touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
            } else {
                touchX = image.touchesStart.x;
                touchY = image.touchesStart.y;
            }
            zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            if (e) {
                slideWidth = gesture.$slideEl[0].offsetWidth;
                slideHeight = gesture.$slideEl[0].offsetHeight;
                offsetX = gesture.$slideEl.offset().left + window.scrollX;
                offsetY = gesture.$slideEl.offset().top + window.scrollY;
                diffX = offsetX + slideWidth / 2 - touchX;
                diffY = offsetY + slideHeight / 2 - touchY;
                imageWidth = gesture.$imageEl[0].offsetWidth;
                imageHeight = gesture.$imageEl[0].offsetHeight;
                scaledWidth = imageWidth * zoom.scale;
                scaledHeight = imageHeight * zoom.scale;
                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                translateMaxX = -translateMinX;
                translateMaxY = -translateMinY;
                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;
                if (translateX < translateMinX) {
                    translateX = translateMinX;
                }
                if (translateX > translateMaxX) {
                    translateX = translateMaxX;
                }
                if (translateY < translateMinY) {
                    translateY = translateMinY;
                }
                if (translateY > translateMaxY) {
                    translateY = translateMaxY;
                }
            } else {
                translateX = 0;
                translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
            gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }
        function zoomOut() {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.$slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                    gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
                } else {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
            if (swiper.params.cssMode) {
                swiper.wrapperEl.style.overflow = '';
                swiper.wrapperEl.style.touchAction = '';
            }
            zoom.scale = 1;
            currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
            gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
            gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
            gesture.$slideEl = undefined;
        } 
        function zoomToggle(e) {
            const zoom = swiper.zoom;
            if (zoom.scale && zoom.scale !== 1) {
                zoomOut();
            } else {
                zoomIn(e);
            }
        }
        function getListeners() {
            const support = swiper.support;
            const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            const activeListenerWithCapture = support.passiveListener ? {
                passive: false,
                capture: true
            } : true;
            return {
                passiveListener,
                activeListenerWithCapture
            };
        }
        function getSlideSelector() {
            return `.${swiper.params.slideClass}`;
        }
        function toggleGestures(method) {
            const {
                passiveListener
            } = getListeners();
            const slideSelector = getSlideSelector();
            swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
            swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
            swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
        }
        function enableGestures() {
            if (gesturesEnabled) return;
            gesturesEnabled = true;
            toggleGestures('on');
        }
        function disableGestures() {
            if (!gesturesEnabled) return;
            gesturesEnabled = false;
            toggleGestures('off');
        } 
        function enable() {
            const zoom = swiper.zoom;
            if (zoom.enabled) return;
            zoom.enabled = true;
            const support = swiper.support;
            const {
                passiveListener,
                activeListenerWithCapture
            } = getListeners();
            const slideSelector = getSlideSelector(); 
            if (support.gestures) {
                swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
                swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
                if (swiper.touchEvents.cancel) {
                    swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
                }
            } 
            swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
        }
        function disable() {
            const zoom = swiper.zoom;
            if (!zoom.enabled) return;
            const support = swiper.support;
            zoom.enabled = false;
            const {
                passiveListener,
                activeListenerWithCapture
            } = getListeners();
            const slideSelector = getSlideSelector(); 
            if (support.gestures) {
                swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
                swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
                if (swiper.touchEvents.cancel) {
                    swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
                }
            } 
            swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
        }
        on('init', () => {
            if (swiper.params.zoom.enabled) {
                enable();
            }
        });
        on('destroy', () => {
            disable();
        });
        on('touchStart', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchStart(e);
        });
        on('touchEnd', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchEnd();
        });
        on('doubleTap', (_s, e) => {
            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                zoomToggle(e);
            }
        });
        on('transitionEnd', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                onTransitionEnd();
            }
        });
        on('slideChange', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                onTransitionEnd();
            }
        });
        Object.assign(swiper.zoom, {
            enable,
            disable,
            in: zoomIn,
            out: zoomOut,
            toggle: zoomToggle
        });
    }
    function Lazy(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            lazy: {
                checkInView: false,
                enabled: false,
                loadPrevNext: false,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: false,
                scrollingElement: '',
                elementClass: 'ax-lazy',
                loadingClass: 'ax-lazy-loading',
                loadedClass: 'ax-lazy-loaded',
                preloaderClass: 'ax-loading'
            }
        });
        swiper.lazy = {};
        let scrollHandlerAttached = false;
        let initialImageLoaded = false;
        function loadInSlide(index, loadInDuplicate) {
            if (loadInDuplicate === void 0) {
                loadInDuplicate = true;
            }
            const params = swiper.params.lazy;
            if (typeof index === 'undefined') return;
            if (swiper.slides.length === 0) return;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
            const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
                $images.push($slideEl[0]);
            }
            if ($images.length === 0) return;
            $images.each(imageEl => {
                const $imageEl = $(imageEl);
                $imageEl.addClass(params.loadingClass);
                const background = $imageEl.attr('data-background');
                const src = $imageEl.attr('data-src');
                const srcset = $imageEl.attr('data-srcset');
                const sizes = $imageEl.attr('data-sizes');
                const $pictureEl = $imageEl.parent('picture');
                swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
                    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
                    if (background) {
                        $imageEl.css('background-image', `url("${background}")`);
                        $imageEl.removeAttr('data-background');
                    } else {
                        if (srcset) {
                            $imageEl.attr('srcset', srcset);
                            $imageEl.removeAttr('data-srcset');
                        }
                        if (sizes) {
                            $imageEl.attr('sizes', sizes);
                            $imageEl.removeAttr('data-sizes');
                        }
                        if ($pictureEl.length) {
                            $pictureEl.children('source').each(sourceEl => {
                                const $source = $(sourceEl);
                                if ($source.attr('data-srcset')) {
                                    $source.attr('srcset', $source.attr('data-srcset'));
                                    $source.removeAttr('data-srcset');
                                }
                            });
                        }
                        if (src) {
                            $imageEl.attr('src', src);
                            $imageEl.removeAttr('data-src');
                        }
                    }
                    $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                    $slideEl.find(`.${params.preloaderClass}`).remove();
                    if (swiper.params.loop && loadInDuplicate) {
                        const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
                        if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
                            loadInSlide(originalSlide.index(), false);
                        } else {
                            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
                            loadInSlide(duplicatedSlide.index(), false);
                        }
                    }
                    emit('lazyImageReady', $slideEl[0], $imageEl[0]);
                    if (swiper.params.autoHeight) {
                        swiper.updateAutoHeight();
                    }
                });
                emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
            });
        }
        function load() {
            const {
                $wrapperEl,
                params: swiperParams,
                slides,
                activeIndex
            } = swiper;
            const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            const params = swiperParams.lazy;
            let slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === 'auto') {
                slidesPerView = 0;
            }
            function slideExist(index) {
                if (isVirtual) {
                    if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
                        return true;
                    }
                } else if (slides[index]) return true;
                return false;
            }
            function slideIndex(slideEl) {
                if (isVirtual) {
                    return $(slideEl).attr('data-swiper-slide-index');
                }
                return $(slideEl).index();
            }
            if (!initialImageLoaded) initialImageLoaded = true;
            if (swiper.params.watchSlidesProgress) {
                $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
                    const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
                    loadInSlide(index);
                });
            } else if (slidesPerView > 1) {
                for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                    if (slideExist(i)) loadInSlide(i);
                }
            } else {
                loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
                if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
                    const amount = params.loadPrevNextAmount;
                    const spv = slidesPerView;
                    const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                    const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); 
                    for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
                        if (slideExist(i)) loadInSlide(i);
                    } 
                    for (let i = minIndex; i < activeIndex; i += 1) {
                        if (slideExist(i)) loadInSlide(i);
                    }
                } else {
                    const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
                    if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
                    const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
                    if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
                }
            }
        }
        function checkInViewOnLoad() {
            const window = getWindow();
            if (!swiper || swiper.destroyed) return;
            const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
            const isWindow = $scrollElement[0] === window;
            const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
            const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
            const swiperOffset = swiper.$el.offset();
            const {
                rtlTranslate: rtl
            } = swiper;
            let inView = false;
            if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
            const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
            for (let i = 0; i < swiperCoord.length; i += 1) {
                const point = swiperCoord[i];
                if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
                    if (point[0] === 0 && point[1] === 0) continue; 
                    inView = true;
                }
            }
            const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (inView) {
                load();
                $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
            } else if (!scrollHandlerAttached) {
                scrollHandlerAttached = true;
                $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
            }
        }
        on('beforeInit', () => {
            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                swiper.params.preloadImages = false;
            }
        });
        on('init', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('scroll', () => {
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
                load();
            }
        });
        on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('transitionStart', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
                    if (swiper.params.lazy.checkInView) {
                        checkInViewOnLoad();
                    } else {
                        load();
                    }
                }
            }
        });
        on('transitionEnd', () => {
            if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('slideChange', () => {
            const {
                lazy,
                cssMode,
                watchSlidesProgress,
                touchReleaseOnEdges,
                resistanceRatio
            } = swiper.params;
            if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
                load();
            }
        });
        Object.assign(swiper.lazy, {
            load,
            loadInSlide
        });
    }
    /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    function Controller(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            controller: {
                control: undefined,
                inverse: false,
                by: 'slide' 
            }
        });
        swiper.controller = {
            control: undefined
        };
        function LinearSpline(x, y) {
            const binarySearch = function search() {
                let maxIndex;
                let minIndex;
                let guess;
                return (array, val) => {
                    minIndex = -1;
                    maxIndex = array.length;
                    while (maxIndex - minIndex > 1) {
                        guess = maxIndex + minIndex >> 1;
                        if (array[guess] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                    }
                    return maxIndex;
                };
            }();
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1; 
            let i1;
            let i3;
            this.interpolate = function interpolate(x2) {
                if (!x2) return 0; 
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1; 
                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
            };
            return this;
        } 
        function getInterpolateFunction(c) {
            if (!swiper.controller.spline) {
                swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
            }
        }
        function setTranslate(_t, byController) {
            const controlled = swiper.controller.control;
            let multiplier;
            let controlledTranslate;
            const Swiper = swiper.constructor;
            function setControlledTranslate(c) {
                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                if (swiper.params.controller.by === 'slide') {
                    getInterpolateFunction(c); 
                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                }
                if (!controlledTranslate || swiper.params.controller.by === 'container') {
                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
                }
                if (swiper.params.controller.inverse) {
                    controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setTranslate(controlledTranslate, swiper);
                c.updateActiveIndex();
                c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
                for (let i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTranslate(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
            }
        }
        function setTransition(duration, byController) {
            const Swiper = swiper.constructor;
            const controlled = swiper.controller.control;
            let i;
            function setControlledTransition(c) {
                c.setTransition(duration, swiper);
                if (duration !== 0) {
                    c.transitionStart();
                    if (c.params.autoHeight) {
                        nextTick(() => {
                            c.updateAutoHeight();
                        });
                    }
                    c.$wrapperEl.transitionEnd(() => {
                        if (!controlled) return;
                        if (c.params.loop && swiper.params.controller.by === 'slide') {
                            c.loopFix();
                        }
                        c.transitionEnd();
                    });
                }
            }
            if (Array.isArray(controlled)) {
                for (i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTransition(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
            }
        }
        function removeSpline() {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = undefined;
                delete swiper.controller.spline;
            }
        }
        on('beforeInit', () => {
            swiper.controller.control = swiper.params.controller.control;
        });
        on('update', () => {
            removeSpline();
        });
        on('resize', () => {
            removeSpline();
        });
        on('observerUpdate', () => {
            removeSpline();
        });
        on('setTranslate', (_s, translate, byController) => {
            if (!swiper.controller.control) return;
            swiper.controller.setTranslate(translate, byController);
        });
        on('setTransition', (_s, duration, byController) => {
            if (!swiper.controller.control) return;
            swiper.controller.setTransition(duration, byController);
        });
        Object.assign(swiper.controller, {
            setTranslate,
            setTransition
        });
    }
    function A11y(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            a11y: {
                enabled: true,
                notificationClass: 'ax-notification',
                prevSlideMessage: '上一个',
                nextSlideMessage: '下一个',
                firstSlideMessage: '这是第一个',
                lastSlideMessage: '这是最后一个',
                paginationBulletMessage: '跳转到第{{index}}页',
                slideLabelMessage: '第{{index}}/{{slidesLength}}页',
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: 'group',
                id: null
            }
        });
        let liveRegion = null;
        function notify(message) {
            const notification = liveRegion;
            if (notification.length === 0) return;
            notification.html('');
            notification.html(message);
        }
        function getRandomNumber(size) {
            if (size === void 0) {
                size = 16;
            }
            const randomChar = () => Math.round(16 * Math.random()).toString(16);
            return 'x'.repeat(size).replace(/x/g, randomChar);
        }
        function makeElFocusable($el) {
            $el.attr('tabIndex', '0');
        }
        function makeElNotFocusable($el) {
            $el.attr('tabIndex', '-1');
        }
        function addElRole($el, role) {
            $el.attr('role', role);
        }
        function addElRoleDescription($el, description) {
            $el.attr('aria-roledescription', description);
        }
        function addElControls($el, controls) {
            $el.attr('aria-controls', controls);
        }
        function addElLabel($el, label) {
            $el.attr('aria-label', label);
        }
        function addElId($el, id) {
            $el.attr('id', id);
        }
        function addElLive($el, live) {
            $el.attr('aria-live', live);
        }
        function disableEl($el) {
            $el.attr('aria-disabled', true);
        }
        function enableEl($el) {
            $el.attr('aria-disabled', false);
        }
        function onEnterOrSpaceKey(e) {
            if (e.keyCode !== 13 && e.keyCode !== 32) return;
            const params = swiper.params.a11y;
            const $targetEl = $(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    notify(params.lastSlideMessage);
                } else {
                    notify(params.nextSlideMessage);
                }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    notify(params.firstSlideMessage);
                } else {
                    notify(params.prevSlideMessage);
                }
            }
            if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
                $targetEl[0].click();
            }
        }
        function updateNavigation() {
            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    disableEl($prevEl);
                    makeElNotFocusable($prevEl);
                } else {
                    enableEl($prevEl);
                    makeElFocusable($prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    disableEl($nextEl);
                    makeElNotFocusable($nextEl);
                } else {
                    enableEl($nextEl);
                    makeElFocusable($nextEl);
                }
            }
        }
        function hasPagination() {
            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
        }
        function hasClickablePagination() {
            return hasPagination() && swiper.params.pagination.clickable;
        }
        function updatePagination() {
            const params = swiper.params.a11y;
            if (!hasPagination()) return;
            swiper.pagination.bullets.each(bulletEl => {
                const $bulletEl = $(bulletEl);
                if (swiper.params.pagination.clickable) {
                    makeElFocusable($bulletEl);
                    if (!swiper.params.pagination.renderBullet) {
                        addElRole($bulletEl, 'button');
                        addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
                    }
                }
                if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
                    $bulletEl.attr('aria-current', 'true');
                } else {
                    $bulletEl.removeAttr('aria-current');
                }
            });
        }
        const initNavEl = ($el, wrapperId, message) => {
            makeElFocusable($el);
            if ($el[0].tagName !== 'BUTTON') {
                addElRole($el, 'button');
                $el.on('keydown', onEnterOrSpaceKey);
            }
            addElLabel($el, message);
            addElControls($el, wrapperId);
        };
        const handleFocus = e => {
            const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
            if (!slideEl || !swiper.slides.includes(slideEl)) return;
            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
            if (isActive || isVisible) return;
            swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
        };
        function init() {
            const params = swiper.params.a11y;
            swiper.$el.append(liveRegion); 
            const $containerEl = swiper.$el;
            if (params.containerRoleDescriptionMessage) {
                addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
            }
            if (params.containerMessage) {
                addElLabel($containerEl, params.containerMessage);
            } 
            const $wrapperEl = swiper.$wrapperEl;
            const wrapperId = params.id || $wrapperEl.attr('id') || `ax-wrapper-${getRandomNumber(16)}`;
            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
            addElId($wrapperEl, wrapperId);
            addElLive($wrapperEl, live); 
            if (params.itemRoleDescriptionMessage) {
                addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
            }
            addElRole($(swiper.slides), params.slideRole);
            const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
            swiper.slides.each((slideEl, index) => {
                const $slideEl = $(slideEl);
                const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
                const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                addElLabel($slideEl, ariaLabelMessage);
            }); 
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl && $nextEl.length) {
                initNavEl($nextEl, wrapperId, params.nextSlideMessage);
            }
            if ($prevEl && $prevEl.length) {
                initNavEl($prevEl, wrapperId, params.prevSlideMessage);
            } 
            if (hasClickablePagination()) {
                swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
            } 
            swiper.$el.on('focus', handleFocus, true);
        }
        function destroy() {
            if (liveRegion && liveRegion.length > 0) liveRegion.remove();
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                $nextEl.off('keydown', onEnterOrSpaceKey);
            }
            if ($prevEl) {
                $prevEl.off('keydown', onEnterOrSpaceKey);
            } 
            if (hasClickablePagination()) {
                swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
            } 
            swiper.$el.off('focus', handleFocus, true);
        }
        on('beforeInit', () => {
            liveRegion = $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
        });
        on('afterInit', () => {
            if (!swiper.params.a11y.enabled) return;
            init();
        });
        on('fromEdge toEdge afterInit lock unlock', () => {
            if (!swiper.params.a11y.enabled) return;
            updateNavigation();
        });
        on('paginationUpdate', () => {
            if (!swiper.params.a11y.enabled) return;
            updatePagination();
        });
        on('destroy', () => {
            if (!swiper.params.a11y.enabled) return;
            destroy();
        });
    }
    function History(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            history: {
                enabled: false,
                root: '',
                replaceState: false,
                key: 'slides'
            }
        });
        let initialized = false;
        let paths = {};
        const slugify = text => {
            return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
        };
        const getPathValues = urlOverride => {
            const window = getWindow();
            let location;
            if (urlOverride) {
                location = new URL(urlOverride);
            } else {
                location = window.location;
            }
            const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
            const total = pathArray.length;
            const key = pathArray[total - 2];
            const value = pathArray[total - 1];
            return {
                key,
                value
            };
        };
        const setHistory = (key, index) => {
            const window = getWindow();
            if (!initialized || !swiper.params.history.enabled) return;
            let location;
            if (swiper.params.url) {
                location = new URL(swiper.params.url);
            } else {
                location = window.location;
            }
            const slide = swiper.slides.eq(index);
            let value = slugify(slide.attr('data-history'));
            if (swiper.params.history.root.length > 0) {
                let root = swiper.params.history.root;
                if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
                value = `${root}/${key}/${value}`;
            } else if (!location.pathname.includes(key)) {
                value = `${key}/${value}`;
            }
            const currentState = window.history.state;
            if (currentState && currentState.value === value) {
                return;
            }
            if (swiper.params.history.replaceState) {
                window.history.replaceState({
                    value
                }, null, value);
            } else {
                window.history.pushState({
                    value
                }, null, value);
            }
        };
        const scrollToSlide = (speed, value, runCallbacks) => {
            if (value) {
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHistory = slugify(slide.attr('data-history'));
                    if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index = slide.index();
                        swiper.slideTo(index, speed, runCallbacks);
                    }
                }
            } else {
                swiper.slideTo(0, speed, runCallbacks);
            }
        };
        const setHistoryPopState = () => {
            paths = getPathValues(swiper.params.url);
            scrollToSlide(swiper.params.speed, swiper.paths.value, false);
        };
        const init = () => {
            const window = getWindow();
            if (!swiper.params.history) return;
            if (!window.history || !window.history.pushState) {
                swiper.params.history.enabled = false;
                swiper.params.hashNavigation.enabled = true;
                return;
            }
            initialized = true;
            paths = getPathValues(swiper.params.url);
            if (!paths.key && !paths.value) return;
            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
                window.addEventListener('popstate', setHistoryPopState);
            }
        };
        const destroy = () => {
            const window = getWindow();
            if (!swiper.params.history.replaceState) {
                window.removeEventListener('popstate', setHistoryPopState);
            }
        };
        on('init', () => {
            if (swiper.params.history.enabled) {
                init();
            }
        });
        on('destroy', () => {
            if (swiper.params.history.enabled) {
                destroy();
            }
        });
        on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
                setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        });
        on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
                setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        });
    }
    function HashNavigation(_ref) {
        let {
            swiper,
            extendParams,
            emit,
            on
        } = _ref;
        let initialized = false;
        const document = getDocument();
        const window = getWindow();
        extendParams({
            hashNavigation: {
                enabled: false,
                replaceState: false,
                watchState: false
            }
        });
        const onHashChange = () => {
            emit('hashChange');
            const newHash = document.location.hash.replace('#', '');
            const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
            if (newHash !== activeSlideHash) {
                const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
                if (typeof newIndex === 'undefined') return;
                swiper.slideTo(newIndex);
            }
        };
        const setHash = () => {
            if (!initialized || !swiper.params.hashNavigation.enabled) return;
            if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
                window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
                emit('hashSet');
            } else {
                const slide = swiper.slides.eq(swiper.activeIndex);
                const hash = slide.attr('data-hash') || slide.attr('data-history');
                document.location.hash = hash || '';
                emit('hashSet');
            }
        };
        const init = () => {
            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
            initialized = true;
            const hash = document.location.hash.replace('#', '');
            if (hash) {
                const speed = 0;
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHash = slide.attr('data-hash') || slide.attr('data-history');
                    if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index = slide.index();
                        swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
                    }
                }
            }
            if (swiper.params.hashNavigation.watchState) {
                $(window).on('hashchange', onHashChange);
            }
        };
        const destroy = () => {
            if (swiper.params.hashNavigation.watchState) {
                $(window).off('hashchange', onHashChange);
            }
        };
        on('init', () => {
            if (swiper.params.hashNavigation.enabled) {
                init();
            }
        });
        on('destroy', () => {
            if (swiper.params.hashNavigation.enabled) {
                destroy();
            }
        });
        on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
                setHash();
            }
        });
        on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
                setHash();
            }
        });
    }
    /* eslint no-underscore-dangle: "off" */
    function Autoplay(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        let timeout;
        swiper.autoplay = {
            running: false,
            paused: false
        };
        extendParams({
            autoplay: {
                enabled: false,
                delay: 3000,
                waitForTransition: true,
                disableOnInteraction: true,
                stopOnLastSlide: false,
                reverseDirection: false,
                pauseOnMouseEnter: false
            }
        });
        function run() {
            const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            let delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr('data-swiper-autoplay')) {
                delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
            }
            clearTimeout(timeout);
            timeout = nextTick(() => {
                let autoplayResult;
                if (swiper.params.autoplay.reverseDirection) {
                    if (swiper.params.loop) {
                        swiper.loopFix();
                        autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                        emit('autoplay');
                    } else if (!swiper.isBeginning) {
                        autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                        emit('autoplay');
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                        emit('autoplay');
                    } else {
                        stop();
                    }
                } else if (swiper.params.loop) {
                    swiper.loopFix();
                    autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                    emit('autoplay');
                } else if (!swiper.isEnd) {
                    autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                    emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
                    emit('autoplay');
                } else {
                    stop();
                }
                if (swiper.params.cssMode && swiper.autoplay.running) run(); else if (autoplayResult === false) {
                    run();
                }
            }, delay);
        }
        function start() {
            if (typeof timeout !== 'undefined') return false;
            if (swiper.autoplay.running) return false;
            swiper.autoplay.running = true;
            emit('autoplayStart');
            run();
            return true;
        }
        function stop() {
            if (!swiper.autoplay.running) return false;
            if (typeof timeout === 'undefined') return false;
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
            swiper.autoplay.running = false;
            emit('autoplayStop');
            return true;
        }
        function pause(speed) {
            if (!swiper.autoplay.running) return;
            if (swiper.autoplay.paused) return;
            if (timeout) clearTimeout(timeout);
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
                swiper.autoplay.paused = false;
                run();
            } else {
                ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                    swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
                });
            }
        }
        function onVisibilityChange() {
            const document = getDocument();
            if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
                pause();
            }
            if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
                run();
                swiper.autoplay.paused = false;
            }
        }
        function onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
            if (e.target !== swiper.$wrapperEl[0]) return;
            ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
            });
            swiper.autoplay.paused = false;
            if (!swiper.autoplay.running) {
                stop();
            } else {
                run();
            }
        }
        function onMouseEnter() {
            if (swiper.params.autoplay.disableOnInteraction) {
                stop();
            } else {
                emit('autoplayPause');
                pause();
            }
            ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
            });
        }
        function onMouseLeave() {
            if (swiper.params.autoplay.disableOnInteraction) {
                return;
            }
            swiper.autoplay.paused = false;
            emit('autoplayResume');
            run();
        }
        function attachMouseEvents() {
            if (swiper.params.autoplay.pauseOnMouseEnter) {
                swiper.$el.on('mouseenter', onMouseEnter);
                swiper.$el.on('mouseleave', onMouseLeave);
            }
        }
        function detachMouseEvents() {
            swiper.$el.off('mouseenter', onMouseEnter);
            swiper.$el.off('mouseleave', onMouseLeave);
        }
        on('init', () => {
            if (swiper.params.autoplay.enabled) {
                start();
                const document = getDocument();
                document.addEventListener('visibilitychange', onVisibilityChange);
                attachMouseEvents();
            }
        });
        on('beforeTransitionStart', (_s, speed, internal) => {
            if (swiper.autoplay.running) {
                if (internal || !swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.pause(speed);
                } else {
                    stop();
                }
            }
        });
        on('sliderFirstMove', () => {
            if (swiper.autoplay.running) {
                if (swiper.params.autoplay.disableOnInteraction) {
                    stop();
                } else {
                    pause();
                }
            }
        });
        on('touchEnd', () => {
            if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
                run();
            }
        });
        on('destroy', () => {
            detachMouseEvents();
            if (swiper.autoplay.running) {
                stop();
            }
            const document = getDocument();
            document.removeEventListener('visibilitychange', onVisibilityChange);
        });
        Object.assign(swiper.autoplay, {
            pause,
            run,
            start,
            stop
        });
    }
    function Thumb(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: true,
                autoScrollOffset: 0,
                slideThumbActiveClass: 'ax-slide-thumb-active',
                thumbsContainerClass: 'ax-thumbs'
            }
        });
        let initialized = false;
        let swiperCreated = false;
        swiper.thumbs = {
            swiper: null
        };
        function onThumbClick() {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const clickedIndex = thumbsSwiper.clickedIndex;
            const clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
            if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
            let slideToIndex;
            if (thumbsSwiper.params.loop) {
                slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            } else {
                slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
                let currentIndex = swiper.activeIndex;
                if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                    swiper.loopFix(); 
                    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                    currentIndex = swiper.activeIndex;
                }
                const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
                const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
                if (typeof prevIndex === 'undefined') slideToIndex = nextIndex; else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex; else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex; else slideToIndex = prevIndex;
            }
            swiper.slideTo(slideToIndex);
        }
        function init() {
            const {
                thumbs: thumbsParams
            } = swiper.params;
            if (initialized) return false;
            initialized = true;
            const SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
                swiper.thumbs.swiper = thumbsParams.swiper;
                Object.assign(swiper.thumbs.swiper.originalParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                Object.assign(swiper.thumbs.swiper.params, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
            } else if (isObject(thumbsParams.swiper)) {
                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                Object.assign(thumbsSwiperParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                swiperCreated = true;
            }
            swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on('tap', onThumbClick);
            return true;
        }
        function update(initial) {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                let currentThumbsIndex = thumbsSwiper.activeIndex;
                let newThumbsIndex;
                let direction;
                if (thumbsSwiper.params.loop) {
                    if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                        thumbsSwiper.loopFix(); 
                        thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                        currentThumbsIndex = thumbsSwiper.activeIndex;
                    } 
                    const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
                    const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
                    if (typeof prevThumbsIndex === 'undefined') {
                        newThumbsIndex = nextThumbsIndex;
                    } else if (typeof nextThumbsIndex === 'undefined') {
                        newThumbsIndex = prevThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = nextThumbsIndex;
                    } else {
                        newThumbsIndex = prevThumbsIndex;
                    }
                    direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
                } else {
                    newThumbsIndex = swiper.realIndex;
                    direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
                }
                if (useOffset) {
                    newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
                }
                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                    if (thumbsSwiper.params.centeredSlides) {
                        if (newThumbsIndex > currentThumbsIndex) {
                            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                        } else {
                            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                        }
                    } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);
                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                }
            } 
            let thumbsToActivate = 1;
            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
                thumbsToActivate = swiper.params.slidesPerView;
            }
            if (!swiper.params.thumbs.multipleActiveThumbs) {
                thumbsToActivate = 1;
            }
            thumbsToActivate = Math.floor(thumbsToActivate);
            thumbsSwiper.slides.removeClass(thumbActiveClass);
            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
                for (let i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
                }
            } else {
                for (let i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
                }
            }
        }
        on('beforeInit', () => {
            const {
                thumbs
            } = swiper.params;
            if (!thumbs || !thumbs.swiper) return;
            init();
            update(true);
        });
        on('slideChange update resize observerUpdate', () => {
            update();
        });
        on('setTransition', (_s, duration) => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            thumbsSwiper.setTransition(duration);
        });
        on('beforeDestroy', () => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            if (swiperCreated) {
                thumbsSwiper.destroy();
            }
        });
        Object.assign(swiper.thumbs, {
            init,
            update
        });
    }
    function freeMode(_ref) {
        let {
            swiper,
            extendParams,
            emit,
            once
        } = _ref;
        extendParams({
            freeMode: {
                enabled: false,
                momentum: true,
                momentumRatio: 1,
                momentumBounce: true,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: false,
                minimumVelocity: 0.02
            }
        });
        function onTouchStart() {
            const translate = swiper.getTranslate();
            swiper.setTranslate(translate);
            swiper.setTransition(0);
            swiper.touchEventsData.velocities.length = 0;
            swiper.freeMode.onTouchEnd({
                currentPos: swiper.rtl ? swiper.translate : -swiper.translate
            });
        }
        function onTouchMove() {
            const {
                touchEventsData: data,
                touches
            } = swiper; 
            if (data.velocities.length === 0) {
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                    time: data.touchStartTime
                });
            }
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
                time: now()
            });
        }
        function onTouchEnd(_ref2) {
            let {
                currentPos
            } = _ref2;
            const {
                params,
                $wrapperEl,
                rtlTranslate: rtl,
                snapGrid,
                touchEventsData: data
            } = swiper; 
            const touchEndTime = now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (currentPos < -swiper.minTranslate()) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (currentPos > -swiper.maxTranslate()) {
                if (swiper.slides.length < snapGrid.length) {
                    swiper.slideTo(snapGrid.length - 1);
                } else {
                    swiper.slideTo(swiper.slides.length - 1);
                }
                return;
            }
            if (params.freeMode.momentum) {
                if (data.velocities.length > 1) {
                    const lastMoveEvent = data.velocities.pop();
                    const velocityEvent = data.velocities.pop();
                    const distance = lastMoveEvent.position - velocityEvent.position;
                    const time = lastMoveEvent.time - velocityEvent.time;
                    swiper.velocity = distance / time;
                    swiper.velocity /= 2;
                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                        swiper.velocity = 0;
                    } 
                    if (time > 150 || now() - lastMoveEvent.time > 300) {
                        swiper.velocity = 0;
                    }
                } else {
                    swiper.velocity = 0;
                }
                swiper.velocity *= params.freeMode.momentumVelocityRatio;
                data.velocities.length = 0;
                let momentumDuration = 1000 * params.freeMode.momentumRatio;
                const momentumDistance = swiper.velocity * momentumDuration;
                let newPosition = swiper.translate + momentumDistance;
                if (rtl) newPosition = -newPosition;
                let doBounce = false;
                let afterBouncePosition;
                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
                let needsLoopFix;
                if (newPosition < swiper.maxTranslate()) {
                    if (params.freeMode.momentumBounce) {
                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                            newPosition = swiper.maxTranslate() - bounceAmount;
                        }
                        afterBouncePosition = swiper.maxTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.maxTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (newPosition > swiper.minTranslate()) {
                    if (params.freeMode.momentumBounce) {
                        if (newPosition - swiper.minTranslate() > bounceAmount) {
                            newPosition = swiper.minTranslate() + bounceAmount;
                        }
                        afterBouncePosition = swiper.minTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.minTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (params.freeMode.sticky) {
                    let nextSlide;
                    for (let j = 0; j < snapGrid.length; j += 1) {
                        if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                    }
                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                        newPosition = snapGrid[nextSlide];
                    } else {
                        newPosition = snapGrid[nextSlide - 1];
                    }
                    newPosition = -newPosition;
                }
                if (needsLoopFix) {
                    once('transitionEnd', () => {
                        swiper.loopFix();
                    });
                } 
                if (swiper.velocity !== 0) {
                    if (rtl) {
                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                    } else {
                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                    }
                    if (params.freeMode.sticky) {
                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                        if (moveDistance < currentSlideSize) {
                            momentumDuration = params.speed;
                        } else if (moveDistance < 2 * currentSlideSize) {
                            momentumDuration = params.speed * 1.5;
                        } else {
                            momentumDuration = params.speed * 2.5;
                        }
                    }
                } else if (params.freeMode.sticky) {
                    swiper.slideToClosest();
                    return;
                }
                if (params.freeMode.momentumBounce && doBounce) {
                    swiper.updateProgress(afterBouncePosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(() => {
                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                        emit('momentumBounce');
                        swiper.setTransition(params.speed);
                        setTimeout(() => {
                            swiper.setTranslate(afterBouncePosition);
                            $wrapperEl.transitionEnd(() => {
                                if (!swiper || swiper.destroyed) return;
                                swiper.transitionEnd();
                            });
                        }, 0);
                    });
                } else if (swiper.velocity) {
                    emit('_freeModeNoMomentumRelease');
                    swiper.updateProgress(newPosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    if (!swiper.animating) {
                        swiper.animating = true;
                        $wrapperEl.transitionEnd(() => {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }
                } else {
                    swiper.updateProgress(newPosition);
                }
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            } else if (params.freeMode.sticky) {
                swiper.slideToClosest();
                return;
            } else if (params.freeMode) {
                emit('_freeModeNoMomentumRelease');
            }
            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
        }
        Object.assign(swiper, {
            freeMode: {
                onTouchStart,
                onTouchMove,
                onTouchEnd
            }
        });
    }
    function Grid(_ref) {
        let {
            swiper,
            extendParams
        } = _ref;
        extendParams({
            grid: {
                rows: 1,
                fill: 'column'
            }
        });
        let slidesNumberEvenToRows;
        let slidesPerRow;
        let numFullColumns;
        const initSlides = slidesLength => {
            const {
                slidesPerView
            } = swiper.params;
            const {
                rows,
                fill
            } = swiper.params.grid;
            slidesPerRow = slidesNumberEvenToRows / rows;
            numFullColumns = Math.floor(slidesLength / rows);
            if (Math.floor(slidesLength / rows) === slidesLength / rows) {
                slidesNumberEvenToRows = slidesLength;
            } else {
                slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
            }
            if (slidesPerView !== 'auto' && fill === 'row') {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
            }
        };
        const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
            const {
                slidesPerGroup,
                spaceBetween
            } = swiper.params;
            const {
                rows,
                fill
            } = swiper.params.grid; 
            let newSlideOrderIndex;
            let column;
            let row;
            if (fill === 'row' && slidesPerGroup > 1) {
                const groupIndex = Math.floor(i / (slidesPerGroup * rows));
                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
                row = Math.floor(slideIndexInGroup / columnsInGroup);
                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
                slide.css({
                    '-webkit-order': newSlideOrderIndex,
                    order: newSlideOrderIndex
                });
            } else if (fill === 'column') {
                column = Math.floor(i / rows);
                row = i - column * rows;
                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
                    row += 1;
                    if (row >= rows) {
                        row = 0;
                        column += 1;
                    }
                }
            } else {
                row = Math.floor(i / slidesPerRow);
                column = i - row * slidesPerRow;
            }
            slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
        };
        const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
            const {
                spaceBetween,
                centeredSlides,
                roundLengths
            } = swiper.params;
            const {
                rows
            } = swiper.params.grid;
            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
            swiper.$wrapperEl.css({
                [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
            });
            if (centeredSlides) {
                snapGrid.splice(0, snapGrid.length);
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid.push(...newSlidesGrid);
            }
        };
        swiper.grid = {
            initSlides,
            updateSlide,
            updateWrapperSize
        };
    }
    function appendSlide(slides) {
        const swiper = this;
        const {
            $wrapperEl,
            params
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
        } else {
            $wrapperEl.append(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
    }
    function prependSlide(slides) {
        const swiper = this;
        const {
            params,
            $wrapperEl,
            activeIndex
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        let newActiveIndex = activeIndex + 1;
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.prepend(slides[i]);
            }
            newActiveIndex = activeIndex + slides.length;
        } else {
            $wrapperEl.prepend(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        swiper.slideTo(newActiveIndex, 0, false);
    }
    function addSlide(index, slides) {
        const swiper = this;
        const {
            $wrapperEl,
            params,
            activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        const baseLength = swiper.slides.length;
        if (index <= 0) {
            swiper.prependSlide(slides);
            return;
        }
        if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
        }
        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        const slidesBuffer = [];
        for (let i = baseLength - 1; i >= index; i -= 1) {
            const currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
            $wrapperEl.append(slides);
        }
        for (let i = 0; i < slidesBuffer.length; i += 1) {
            $wrapperEl.append(slidesBuffer[i]);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeSlide(slidesIndexes) {
        const swiper = this;
        const {
            params,
            $wrapperEl,
            activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        let newActiveIndex = activeIndexBuffer;
        let indexToRemove;
        if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (let i = 0; i < slidesIndexes.length; i += 1) {
                indexToRemove = slidesIndexes[i];
                if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            newActiveIndex = Math.max(newActiveIndex, 0);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeAllSlides() {
        const swiper = this;
        const slidesIndexes = [];
        for (let i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
        }
        swiper.removeSlide(slidesIndexes);
    }
    function Manipulation(_ref) {
        let {
            swiper
        } = _ref;
        Object.assign(swiper, {
            appendSlide: appendSlide.bind(swiper),
            prependSlide: prependSlide.bind(swiper),
            addSlide: addSlide.bind(swiper),
            removeSlide: removeSlide.bind(swiper),
            removeAllSlides: removeAllSlides.bind(swiper)
        });
    }
    function effectInit(params) {
        const {
            effect,
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams,
            perspective,
            recreateShadows,
            getEffectParams
        } = params;
        on('beforeInit', () => {
            if (swiper.params.effect !== effect) return;
            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
            if (perspective && perspective()) {
                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
            }
            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
            Object.assign(swiper.params, overwriteParamsResult);
            Object.assign(swiper.originalParams, overwriteParamsResult);
        });
        on('setTranslate', () => {
            if (swiper.params.effect !== effect) return;
            setTranslate();
        });
        on('setTransition', (_s, duration) => {
            if (swiper.params.effect !== effect) return;
            setTransition(duration);
        });
        on('transitionEnd', () => {
            if (swiper.params.effect !== effect) return;
            if (recreateShadows) {
                if (!getEffectParams || !getEffectParams().slideShadows) return; 
                swiper.slides.each(slideEl => {
                    const $slideEl = swiper.$(slideEl);
                    $slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();
                }); 
                recreateShadows();
            }
        });
        let requireUpdateOnVirtual;
        on('virtualUpdate', () => {
            if (swiper.params.effect !== effect) return;
            if (!swiper.slides.length) {
                requireUpdateOnVirtual = true;
            }
            requestAnimationFrame(() => {
                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                    setTranslate();
                    requireUpdateOnVirtual = false;
                }
            });
        });
    }
    function effectTarget(effectParams, $slideEl) {
        if (effectParams.transformEl) {
            return $slideEl.find(effectParams.transformEl).css({
                'backface-visibility': 'hidden',
                '-webkit-backface-visibility': 'hidden'
            });
        }
        return $slideEl;
    }
    function effectVirtualTransitionEnd(_ref) {
        let {
            swiper,
            duration,
            transformEl,
            allSlides
        } = _ref;
        const {
            slides,
            activeIndex,
            $wrapperEl
        } = swiper;
        if (swiper.params.virtualTranslate && duration !== 0) {
            let eventTriggered = false;
            let $transitionEndTarget;
            if (allSlides) {
                $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
            } else {
                $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
            }
            $transitionEndTarget.transitionEnd(() => {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                for (let i = 0; i < triggerEvents.length; i += 1) {
                    $wrapperEl.trigger(triggerEvents[i]);
                }
            });
        }
    }
    function EffectFade(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            fadeEffect: {
                crossFade: false,
                transformEl: null
            }
        });
        const setTranslate = () => {
            const {
                slides
            } = swiper;
            const params = swiper.params.fadeEffect;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = swiper.slides.eq(i);
                const offset = $slideEl[0].swiperSlideOffset;
                let tx = -offset;
                if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                }
                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.css({
                    opacity: slideOpacity
                }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.fadeEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl,
                allSlides: true
            });
        };
        effectInit({
            effect: 'fade',
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCube(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            cubeEffect: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            }
        });
        const createSlideShadows = ($slideEl, progress, isHorizontal) => {
            let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
                shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
                $slideEl.append(shadowBefore);
            }
            if (shadowAfter.length === 0) {
                shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
                $slideEl.append(shadowAfter);
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        };
        const recreateShadows = () => {
            const isHorizontal = swiper.isHorizontal();
            swiper.slides.each(slideEl => {
                const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                createSlideShadows($(slideEl), progress, isHorizontal);
            });
        };
        const setTranslate = () => {
            const {
                $el,
                $wrapperEl,
                slides,
                width: swiperWidth,
                height: swiperHeight,
                rtlTranslate: rtl,
                size: swiperSize,
                browser
            } = swiper;
            const params = swiper.params.cubeEffect;
            const isHorizontal = swiper.isHorizontal();
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let wrapperRotate = 0;
            let $cubeShadowEl;
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $wrapperEl.append($cubeShadowEl);
                    }
                    $cubeShadowEl.css({
                        height: `${swiperWidth}px`
                    });
                } else {
                    $cubeShadowEl = $el.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $el.append($cubeShadowEl);
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let slideIndex = i;
                if (isVirtual) {
                    slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
                }
                let slideAngle = slideIndex * 90;
                let round = Math.floor(slideAngle / 360);
                if (rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                let tx = 0;
                let ty = 0;
                let tz = 0;
                if (slideIndex % 4 === 0) {
                    tx = -round * 4 * swiperSize;
                    tz = 0;
                } else if ((slideIndex - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * swiperSize;
                } else if ((slideIndex - 2) % 4 === 0) {
                    tx = swiperSize + round * 4 * swiperSize;
                    tz = swiperSize;
                } else if ((slideIndex - 3) % 4 === 0) {
                    tx = -swiperSize;
                    tz = 3 * swiperSize + swiperSize * 4 * round;
                }
                if (rtl) {
                    tx = -tx;
                }
                if (!isHorizontal) {
                    ty = tx;
                    tx = 0;
                }
                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = slideIndex * 90 + progress * 90;
                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
                }
                $slideEl.transform(transform);
                if (params.slideShadows) {
                    createSlideShadows($slideEl, progress, isHorizontal);
                }
            }
            $wrapperEl.css({
                '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
                'transform-origin': `50% 50% -${swiperSize / 2}px`
            });
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
                } else {
                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                    const scale1 = params.shadowScale;
                    const scale2 = params.shadowScale / multiplier;
                    const offset = params.shadowOffset;
                    $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
                }
            }
            const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
            $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
            $wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
        };
        const setTransition = duration => {
            const {
                $el,
                slides
            } = swiper;
            slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                $el.find('.swiper-cube-shadow').transition(duration);
            }
        };
        effectInit({
            effect: 'cube',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.cubeEffect,
            perspective: () => true,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true
            })
        });
    }
    function createShadow(params, $slideEl, side) {
        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
        const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
        let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
        if (!$shadowEl.length) {
            $shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
            $shadowContainer.append($shadowEl);
        }
        return $shadowEl;
    }
    function EffectFlip(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            flipEffect: {
                slideShadows: true,
                limitRotation: true,
                transformEl: null
            }
        });
        const createSlideShadows = ($slideEl, progress, params) => {
            let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
                shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }
            if (shadowAfter.length === 0) {
                shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        };
        const recreateShadows = () => {
            const params = swiper.params.flipEffect;
            swiper.slides.each(slideEl => {
                const $slideEl = $(slideEl);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min(slideEl.progress, 1), -1);
                }
                createSlideShadows($slideEl, progress, params);
            });
        };
        const setTranslate = () => {
            const {
                slides,
                rtlTranslate: rtl
            } = swiper;
            const params = swiper.params.flipEffect;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                }
                const offset = $slideEl[0].swiperSlideOffset;
                const rotate = -180 * progress;
                let rotateY = rotate;
                let rotateX = 0;
                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                } else if (rtl) {
                    rotateY = -rotateY;
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
                if (params.slideShadows) {
                    createSlideShadows($slideEl, progress, params);
                }
                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.flipEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl
            });
        };
        effectInit({
            effect: 'flip',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.flipEffect,
            perspective: () => true,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCoverflow(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: true,
                transformEl: null
            }
        });
        const setTranslate = () => {
            const {
                width: swiperWidth,
                height: swiperHeight,
                slides,
                slidesSizesGrid
            } = swiper;
            const params = swiper.params.coverflowEffect;
            const isHorizontal = swiper.isHorizontal();
            const transform = swiper.translate;
            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
            const rotate = isHorizontal ? params.rotate : -params.rotate;
            const translate = params.depth; 
            for (let i = 0, length = slides.length; i < length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideSize = slidesSizesGrid[i];
                const slideOffset = $slideEl[0].swiperSlideOffset;
                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
                const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; 
                let translateZ = -translate * Math.abs(offsetMultiplier);
                let stretch = params.stretch; 
                if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
                    stretch = parseFloat(params.stretch) / 100 * slideSize;
                }
                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); 
                if (Math.abs(translateX) < 0.001) translateX = 0;
                if (Math.abs(translateY) < 0.001) translateY = 0;
                if (Math.abs(translateZ) < 0.001) translateZ = 0;
                if (Math.abs(rotateY) < 0.001) rotateY = 0;
                if (Math.abs(rotateX) < 0.001) rotateX = 0;
                if (Math.abs(scale) < 0.001) scale = 0;
                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(slideTransform);
                $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (params.slideShadows) {
                    let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if ($shadowBeforeEl.length === 0) {
                        $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
                    }
                    if ($shadowAfterEl.length === 0) {
                        $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
                    }
                    if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                }
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.coverflowEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        };
        effectInit({
            effect: 'coverflow',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
                watchSlidesProgress: true
            })
        });
    }
    function EffectCreative(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            creativeEffect: {
                transformEl: null,
                limitProgress: 1,
                shadowPerProgress: false,
                progressMultiplier: 1,
                perspective: true,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const getTranslateValue = value => {
            if (typeof value === 'string') return value;
            return `${value}px`;
        };
        const setTranslate = () => {
            const {
                slides,
                $wrapperEl,
                slidesSizesGrid
            } = swiper;
            const params = swiper.params.creativeEffect;
            const {
                progressMultiplier: multiplier
            } = params;
            const isCenteredSlides = swiper.params.centeredSlides;
            if (isCenteredSlides) {
                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideProgress = $slideEl[0].progress;
                const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
                let originalProgress = progress;
                if (!isCenteredSlides) {
                    originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
                }
                const offset = $slideEl[0].swiperSlideOffset;
                const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
                const r = [0, 0, 0];
                let custom = false;
                if (!swiper.isHorizontal()) {
                    t[1] = t[0];
                    t[0] = 0;
                }
                let data = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                if (progress < 0) {
                    data = params.next;
                    custom = true;
                } else if (progress > 0) {
                    data = params.prev;
                    custom = true;
                } 
                t.forEach((value, index) => {
                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
                }); 
                r.forEach((value, index) => {
                    r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                });
                $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                const translateString = t.join(', ');
                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; 
                if (custom && data.shadow || !custom) {
                    let $shadowEl = $slideEl.children('.swiper-slide-shadow');
                    if ($shadowEl.length === 0 && data.shadow) {
                        $shadowEl = createShadow(params, $slideEl);
                    }
                    if ($shadowEl.length) {
                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                        $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                    }
                }
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform).css({
                    opacity: opacityString
                });
                if (data.origin) {
                    $targetEl.css('transform-origin', data.origin);
                }
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.creativeEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl,
                allSlides: true
            });
        };
        effectInit({
            effect: 'creative',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => swiper.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCards(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            cardsEffect: {
                slideShadows: true,
                transformEl: null,
                rotate: true
            }
        });
        const setTranslate = () => {
            const {
                slides,
                activeIndex
            } = swiper;
            const params = swiper.params.cardsEffect;
            const {
                startTranslate,
                isTouched
            } = swiper.touchEventsData;
            const currentTranslate = swiper.translate;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideProgress = $slideEl[0].progress;
                const progress = Math.min(Math.max(slideProgress, -4), 4);
                let offset = $slideEl[0].swiperSlideOffset;
                if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                    swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
                }
                if (swiper.params.centeredSlides && swiper.params.cssMode) {
                    offset -= slides[0].swiperSlideOffset;
                }
                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                let tY = 0;
                const tZ = -100 * Math.abs(progress);
                let scale = 1;
                let rotate = -2 * progress;
                let tXAdd = 8 - Math.abs(progress) * 0.75;
                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
                if (isSwipeToNext || isSwipeToPrev) {
                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                    rotate += -28 * progress * subProgress;
                    scale += -0.5 * subProgress;
                    tXAdd += 96 * subProgress;
                    tY = `${-25 * subProgress * Math.abs(progress)}%`;
                }
                if (progress < 0) {
                    tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
                } else if (progress > 0) {
                    tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
                } else {
                    tX = `${tX}px`;
                }
                if (!swiper.isHorizontal()) {
                    const prevY = tY;
                    tY = tX;
                    tX = prevY;
                }
                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
                const transform = `
          translate3d(${tX}, ${tY}, ${tZ}px)
          rotateZ(${params.rotate ? rotate : 0}deg)
          scale(${scaleString})
        `;
                if (params.slideShadows) {
                    let $shadowEl = $slideEl.find('.swiper-slide-shadow');
                    if ($shadowEl.length === 0) {
                        $shadowEl = createShadow(params, $slideEl);
                    }
                    if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.cardsEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl
            });
        };
        effectInit({
            effect: 'cards',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
    Swiper.use(modules);
    return Swiper;
}));
/*!
 * 设置多久后过期时间，返回过期时间（国标时间），
 */
const axExpires = (type = 'd', expires = 365) => {
    let dateExp;
    if (axIsDate(expires)) {
        dateExp = new Date(expires).toUTCString()
    } else {
        let now = new Date();
        if (type == 'second' || type == 's') {
            now.setSeconds(now.getSeconds() + ~~expires);
            dateExp = now.toUTCString();
        } else if (type == 'minute' || type == 'm') {
            now.setMinutes(now.getMinutes() + ~~expires);
            dateExp = now.toUTCString();
        } else if (type == 'hour' || type == 'h') {
            now.setHours(now.getHours() + ~~expires);
            dateExp = now.toUTCString();
        } else {
            now.setDate(now.getDate() + ~~expires);
            dateExp = now.toUTCString();
        }
    }
    return dateExp;
}
/*!
 * 定义cookie方法
 * 支持axCookie.set、axCookie.get、axCookie.del三个方法
 * set方法支持options参数，支持追加path、domain、secure和sameSite属性
 * 默认过期时间是365天
 */
const axCookie = {
    set: function (name, value, options = { type: 'd', expires: 365 }) {
        if (!name) {
            console.error('The name of cookie can not be empty!');
            return false;
        }
        let opt = Object.assign({}, options),
            string = opt.path ? ';path=' + opt.path : '';
        string += opt.domain ? ';domain=' + opt.domain : '';
        string += opt.secure ? ';secure=' + opt.secure : '';
        string += opt.sameSite ? ';sameSite=' + opt.sameSite : '';
        opt.expires = axExpires(options.type, options.expires);
        if ((options.expires < 0 || value === null) && this.get(name)) {
            this.del(name);
        } else {
            document.cookie = name + "=" + encodeURIComponent(value) + ";expires=" + opt.expires + string;
        }
        return this;
    },
    get: function (name) {
        let cookieArr = document.cookie.replace(/;\s*/, ';').split(';');
        let value = '';
        for (let i = 0; i < cookieArr.length; i++) {
            let k = cookieArr[i].split('=')[0],
                v = cookieArr[i].split('=')[1];
            if (k == name) {
                value = v;
                break;
            }
        }
        if (value) {
            return decodeURIComponent(value);
        } else {
            return false;
        }
    },
    remove: function (name) {
        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT";
        return this;
    }
}
/*!
 * 定义localStorage本地存储
 * 支持set、get、del、clear、key五个方法
 * set方法支持options参数，type和expires
 * 默认过期时间是0，即永不过期
 */
const axLocalStorage = {
    set: function (key, value = '', options = { type: 'd', expires: 0, cover: true }) {
        if (typeof key !== 'string' && !key) {
            return false;
        }
        let newValue = axClone(value),
            type = axType(value),
            filterProps = (obj) => {
                Object.keys(obj).forEach(k => {
                    let val = obj[k];
                    (axType(val) === 'Array' || axType(val) === 'Object') && filterProps(val);
                    (axType(val).includes('HTML') || axType(val) === 'Function') && delete obj[k];
                });
                return obj;
            };
        if ((type === 'Array' || type === 'Object') && !axIsEmpty(newValue)) {
            filterProps(newValue);
        }
        let expires = options.expires !== 0 ? axExpires(options.type, options.expires) : 0,
            oldValue = axLocalStorage.get(key),
            valueExp = {
                data: (!options.cover && axLocalStorage.get(key)) ? axExtend(oldValue, newValue) : newValue,
                expires: expires,
            };
        if ((options.expires < 0 || newValue === null) && this.get(key)) {
            this.del(key);
        } else {
            window.localStorage.setItem(key, JSON.stringify(valueExp));
        }
        return this;
    },
    get: function (key) {
        if (axIsEmpty(key)) {
            return false;
        }
        let now = new Date().toUTCString(),
            valueExp = JSON.parse(window.localStorage.getItem(key));
        if (valueExp) {
            if (valueExp.expires === 0 || now <= valueExp.expires) {
                return valueExp.data;
            } else {
                window.localStorage.removeItem(key);
                return null;
            }
        } else {
            return null;
        }
    },
    remove: function (key) {
        if (axIsEmpty(key)) {
            return false;
        }
        let arr = [];
        if (Array.isArray(key)) {
            arr = key;
        } else {
            arr.push(key);
        }
        arr.forEach(k => {
            window.localStorage.removeItem(k);
        });
        return this;
    },
    key: function (num) {
        if (typeof num !== 'number') {
            return false;
        }
        return window.localStorage.key(num);
    },
    clear: function () {
        window.localStorage.clear();
        return this;
    }
}
/*!
 * 插件：全局实例管理；使用方法：new axInstance('#id',{参数})
 * 支持axInstance.push、axInstance.destroy、axInstance.destroyAll、axInstance.clear等个方法
 */
class AXINSTANCE {
    constructor() {
        this.data = [];
        this.destroyFun = (item) => {
            if (!item) {
                return false;
            }
            if ((!item.instance.hasOwnProperty('destroyed') || !item.instance.destroyed) && item.instance.__proto__.destroy) {
                item.instance.destroy();
                item.log = `destroy(${new Date().toLocaleString()})`;
            }
        }
        this.initFun = (item) => {
            if (!item) {
                return false;
            }
            if ((!item.instance.hasOwnProperty('destroyed') || item.instance.destroyed) && item.instance.__proto__.init) {
                item.instance.init();
                item.log = `init(${new Date().toLocaleString()})`;
            }
        }
    }
    push(instance, name, type) {
        if (!instance) {
            return false;
        }
        let obj = { name: name, instance: instance, type: type || '', log: `push(${new Date().toLocaleString()})` }
        if (!this.data.some(i => i.instance === instance)) {
            this.data.push(obj);
        }
    }
    find(name, type, destroyed = false) {
        if (!name) {
            return false;
        }
        let item;
        if (type) {
            item = this.data.find(i => {
                if (i.instance.hasOwnProperty('destroyed')) {
                    return i.name === name && i.type === type && i.instance.destroyed === destroyed;
                } else {
                    return i.name === name && i.type === type;
                }
            });
        } else {
            item = this.data.find(i => {
                if (i.instance.hasOwnProperty('destroyed')) {
                    return i.name === name && i.instance.destroyed === destroyed;
                } else {
                    return i.name === name;
                }
            });
        }
        return item ? item.instance : item;
    }
    findAll(type, destroyed = false) {
        let items = [];
        if (!type) {
            if (i.instance.hasOwnProperty('destroyed')) {
                items = this.data.filter(i => i.instance.destroyed === destroyed);
            } else {
                items = this.data;
            }
        } else {
            items = this.data.filter(i => {
                if (i.instance.hasOwnProperty('destroyed')) {
                    return i.type === type && i.instance.destroyed === destroyed;
                } else {
                    return i.type === type;
                }
            });
        }
        return items.length > 0 ? items.map(i => i.instance) : items;
    }
    destroy(name, type, callback) {
        if (!name) {
            return false;
        }
        let item;
        if (type) {
            item = this.data.find(i => i.name === name && i.type === type);
        } else {
            item = this.data.find(i => i.name === name);
        }
        this.destroyFun(item);
        callback && callback(item);
    }
    destroyAll(type, callback) {
        if (!type) {
            this.data.forEach(i => {
                this.destroyFun(i);
            });
            callback && callback(this.data);
            return false;
        } else {
            let items = this.data.filter(i => i.type === type);
            items.forEach(i => {
                this.destroyFun(i);
            });
            callback && callback(items);
        }
    }
    clear(callback) {
        this.data.forEach(i => {
            this.destroyFun(i);
        });
        this.data.length = 0
        callback && callback();
    }
    init(name, type, callback) {
        if (!name) {
            return false;
        }
        let item;
        if (type) {
            item = this.data.find(i => i.name === name && i.type === type);
        } else {
            item = this.data.find(i => i.name === name);
        }
        this.initFun(item);
        callback && callback(item);
    }
    initAll(type, callback) {
        if (!type) {
            this.data.forEach(i => {
                this.initFun(i);
            });
            callback && callback(this.data);
            return false;
        } else {
            let items = this.data.filter(i => i.type === type);
            items.forEach(i => {
                this.initFun(i);
            });
            callback && callback(items);
        }
    }
}
const axInstance = new AXINSTANCE();
/*!
* 插件：告示；使用方法：new axAlert('#id',{参数})
*/
class axAlert {
    constructor(elem, options) {
        if (!elem) {
            return false;
        }
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            caption: '',
            content: '',
            theme: 'warning',
            borderless: false,
            square: false,
            className: '',
            closable: false,
            style: 'simple',
            icon: '',
            iconShow: true,
            notable: false,
            display: '',
            onInit: '',
            onShow: '',
            onHide: '',
            onUpdate: '',
            onUpdateContent: '',
            onClear: '',
            onDestroy: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.init();
    }
    init() {
        this.shown = true;
         axInstance.push(this, this.options.insName, 'alert');
        this.destroyed = false;
        this.render();
        this.setAttribute();
        if (this.close) {
            this.close.onclick = () => {
                this.hide();
            }
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    render() {
        if (!this.targetDom.innerHTML.trim()) {
            let html = '';
            if (this.options.style == 'simple' || !this.options.style) {
                this.content = this.targetDom.innerHTML.trim() ? this.targetDom.innerHTML : this.options.content;
                if (this.options.icon && this.options.iconShow) {
                    html = `<i class="ax-iconfont ${this.options.icon}" icon></i><span content>${this.content}</span>`;
                } else {
                    html = `<span content>${this.content}</span>${this.options.closable ? '<i close></i>' : ''}`;
                }
            } else if (this.options.style == 'complex') {
                if (!this.targetDom.innerHTML.trim()) {
                    html = `${this.options.icon && this.options.iconShow ? '<i class="ax-iconfont ' + this.options.icon + '" icon></i>' : ''}
                    <div wrapper>
                        ${this.options.caption ? '<div caption>' + this.options.caption + '</div>' : ''}
                        <div content>${this.options.content}</div>
                    </div>
                    ${this.options.closable ? '<i close></i>' : ''}
                    `;
                }
            }
            this.targetDom.innerHTML = html;
        }
        this.close = this.targetDom.querySelector('[close]');
        this.icon = this.targetDom.querySelector('[icon]');
        this.wrapper = this.targetDom.querySelector('[wrapper]');
        this.caption = this.targetDom.querySelector('[caption]');
        this.content = this.targetDom.querySelector('[content]');
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-alert') ? this.targetDom.classList.add('ax-alert') : null;
        axClass.add(this.targetDom, this.options.className);
        this.options.theme ? this.targetDom.setAttribute('theme', this.options.theme) : null;
        this.options.borderless ? this.targetDom.setAttribute('borderless', '') : null;
        this.options.notable && this.options.style === 'complex' ? this.targetDom.setAttribute('notable', '') : null;
        this.options.square ? this.targetDom.setAttribute('square', '') : null;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.targetDom.removeAttribute('class');
        this.targetDom.removeAttribute('theme');
        this.targetDom.removeAttribute('borderless');
        this.targetDom.removeAttribute('square');
        this.targetDom.removeAttribute('notable');
        this.targetDom.innerHTML = '';
        this.init();
        callback && callback.call(this);
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        return this;
    }
    updateContent(html, callback) {
        if (this.destroyed) {
            return this;
        }
        this.content.innerHTML = html;
        callback && callback.call(this);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this);
        'updateContent' in this.handlers ? this.emit('updateContent', '') : null;
        return this;
    }
    show(callback) {
        if (this.destroyed || this.shown) {
            return this;
        }
        if (this.options.display) {
            this.targetDom.style.display = this.options.display;
        } else {
            this.targetDom.style.cssText = this.targetDom.style.cssText.replace('display: none;', '');
        }
        this.shown = true;
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed || !this.shown) {
            return this;
        }
        this.targetDom.style.display = 'none';
        this.shown = false;
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        callback && callback.call(this);
        return this;
    }
    clear(callback) {
        if (this.destroyed) {
            return this;
        }
        this.targetDom.removeAttribute('class');
        this.targetDom.removeAttribute('theme');
        this.targetDom.removeAttribute('borderless');
        this.targetDom.removeAttribute('square');
        this.targetDom.removeAttribute('notable');
        this.targetDom.innerHTML = '';
        callback && callback.call(this);
        this.options.onClear && this.options.onClear.call(this);
        'clear' in this.handlers ? this.emit('clear', '') : null;
        return this;
    }
    destroy(callback) {
        this.close ? this.close.onclick = null : null;
        this.destroyed = true;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axAlert]').forEach(element => {
        new axAlert(element);
    });
})(); */
/*!
* 插件：Tags标签；使用方法：new axTags('#id',{参数})
*/
class axTags {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        if (!this.targetDom) {
            return false;
        }
        this.options = axExtend({
            insName: '',
            content: '',
            theme: '',
            borderless: false,
            compact: false,
            text: false,
            corner: '',
            className: '',
            removeNode: 'i',
            removable: false,
            separator: ',',
            unique: false,
            emptyShow: true,
            emptyTip: '<i class="ax-color-ignore">还没有创建标签！</i>',
            edit: {
                enable: false,
                addable: true,
                deletable: true,
                input: '',
                placeholder: '输入关键字...',
            },
            onInit: '',
            onBeforeAdd: '',
            onAdd: '',
            onBeforeRemove: '',
            onRemove: '',
            onUpdate: '',
            onUClear: '',
            onDestroy: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.maxIndex = 0;
        this.emptyDom = axAddElem('span', { emptyTip: '' }, this.options.emptyTip);
        this.inputEdit = (e) => {
            let value = this.inputDom.value,
                selected = this.content.find(k => k.dom.hasAttribute('selected'));
            !this.options.edit.input ? this.inputDom.style.width = value.length + 'em' : null;
            if (value) {
                if (this.options.edit.addable && e.code === 'Enter') {
                    if (axIsEmpty(this.options.onBeforeAdd)) {
                        this.add(this.inputDom.value.trim());
                        this.inputDom.value = '';
                    } else {
                        this.options.onBeforeAdd.call(this, this.inputDom.value.trim());
                    }
                }
                selected ? selected.dom.removeAttribute('selected') : null;
            } else {
                if (this.options.edit.deletable && e.code === 'Backspace' && this.content.length > 0) {
                    let end = this.content.slice(-1)[0];
                    if (end.dom.hasAttribute('selected')) {
                        if (axIsEmpty(this.options.onBeforeRemove)) {
                            this.remove(end.dom);
                        } else {
                            this.options.onBeforeRemove.call(this, this.content.find(k => k.dom == end.dom));
                        }
                        /* 
                                                end.dom.remove();
                                                this.content = this.content.slice(0, -1); */
                    } else {
                        end.dom.setAttribute('selected', '');
                    }
                    this.toggleEmpty();
                } else {
                    selected ? selected.dom.removeAttribute('selected') : null;
                }
            }
        }
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'tags');
        this.destroyed = false;
        this.content = [];
        this.contentProxy = new axObserve(this.content, {
            deep: true,
        });
        this.contentProxy.proxy.push(...this.getSource(this.options.content));
        this.render(this.content);
        this.observeInput();
        this.setAttribute();
        this.renderFinish();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    renderFinish() {
        this.content.forEach(k => {
            k.dom.onclick = () => {
                k.dom.setAttribute('selected', '');
                this.content.filter(i => i !== k).forEach(i => {
                    i.dom.removeAttribute('selected');
                });
            }
        });
    }
    getSource(obj) {
        let result = [];
        if (!axIsEmpty(obj)) {
            if (Array.isArray(obj)) {
                if (typeof obj[0] === 'string') {
                    result = obj.map(k => {
                        return { value: k, theme: '' };
                    });
                } else {
                    result = obj;
                }
            } else if (typeof obj === 'object') {
                result = [obj];
            } else if (typeof obj === 'string') {
                let arr = obj.trim().split(this.options.separator);
                result = arr.map(k => {
                    return { value: k, theme: '' };
                });
            }
        }
        result = result.filter(Boolean);
        result.forEach((k, i) => {
            !k.hasOwnProperty('id') ? k.id = this.maxIndex + i : null;
            !k.hasOwnProperty('theme') ? k.theme = '' : null;
        });
        this.maxIndex += result.length;
        return result;
    }
    render(content) {
        this.toggleEmpty();
        if (axIsEmpty(content)) {
            return false;
        }
        let fragment = document.createDocumentFragment();
        content.forEach(i => {
            let tagDom = this.createTag(i);
            i.dom = tagDom;
            fragment.appendChild(tagDom);
        });
        this.targetDom.appendChild(fragment);
        if (this.inputDom && !this.options.edit.input) {
            this.targetDom.appendChild(this.inputDom);
            this.inputDom.focus();
        }
    }
    createTag(obj) {
        let tagDom = axAddElem('span', { class: 'ax-tag' }, obj.value),
            tagClose = axAddElem(this.options.removeNode, { remove: '' });
        if (!this.options.theme && obj.theme) {
            tagDom.setAttribute('theme', obj.theme)
        }
        if (this.options.removable) {
            tagDom.appendChild(tagClose);
            tagClose.onclick = () => {
                if (axIsEmpty(this.options.onBeforeRemove)) {
                    this.remove(tagDom);
                } else {
                    this.options.onBeforeRemove.call(this, this.content.find(k => k.dom == tagDom));
                }
            }
        }
        obj.dom = tagDom;
        return tagDom;
    }
    getTag(obj) {
        if (axIsEmpty(obj)) {
            return false;
        }
        let filter, tag,
            type = axType(obj);
        if (type === 'Object') {
            let str = '';
            obj.id || obj.id == 0 ? str += 'item.id == obj.id ' : null;
            obj.value ? str += '&& item.value == obj.value ' : null;
            obj.dom ? str += '&& item.dom == obj.dom' : null;
            str.startsWith('&&') ? str = 'true ' + str : null;
            filter = new Function('data', 'obj', `return data.filter(item =>${str})`)(this.content, obj);
            filter.length > 0 ? tag = filter[0] : null;
        } else if (type.includes('HTML')) {
            tag = this.content.find(k => k.dom === obj);
        } else if (type === 'String') {
            tag = this.content.find(k => k.value === obj);
        } else if (type === 'Number') {
            tag = this.content.find(k => k.id == obj);
        }
        return { item: tag, id: this.content.findIndex(k => k === tag) };
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-tags') ? this.targetDom.classList.add('ax-tags') : null;
        axClass.add(this.targetDom, this.options.className);
        this.options.theme ? this.targetDom.setAttribute('theme', this.options.theme) : null;
        this.options.borderless ? this.targetDom.setAttribute('borderless', '') : null;
        this.options.compact ? this.targetDom.setAttribute('compact', '') : null;
        this.options.text ? this.targetDom.setAttribute('text', '') : null;
        this.options.corner ? this.targetDom.setAttribute('corner', this.options.corner) : null;
    }
    observeInput() {
        if (!this.options.edit.enable || this.destroyed) {
            return false;
        }
        if (!this.options.edit.input) {
            this.inputDom = axAddElem('input', { type: 'text', placeholder: this.options.edit.placeholder });
            this.targetDom.appendChild(this.inputDom);
        } else {
            this.inputDom = axIdToDom(this.options.edit.input);
            !this.inputDom.hasAttribute('placeholder') ? this.inputDom.setAttribute('placeholder', this.options.edit.placeholder) : null;
        }
        this.inputDom ? this.inputDom.addEventListener('keyup', this.inputEdit) : null;
    }
    toggleEmpty() {
        if (!this.options.emptyShow) {
            return false;
        }
        if (this.content.length === 0) {
            this.targetDom.insertAdjacentElement('afterbegin', this.emptyDom)
            this.maxIndex = 0;
        } else {
            this.emptyDom.remove();
        }
    }
    update(setting, callback) {
        if (axIsEmpty(setting) || this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.targetDom.innerHTML = '';
        this.inputDom && !this.options.edit.input ? this.targetDom.appendChild(this.inputDom) : null;
        this.init();
        callback && callback.call(this);
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        return this;
    }
    add(obj, callback) {
        if (axIsEmpty(obj) || this.destroyed) {
            return this;
        }
        let arr = this.getSource(obj),
            oldValues = this.content.map(k => k.value);
        if (this.options.unique) {
            arr = axUnique(arr, 'value');
            for (let i = 0; i < arr.length; i++) {
                if (oldValues.includes(arr[i].value)) {
                    arr.splice(i--, 1);
                }
            }
            if (arr.length === 0) {
                new axMessage({
                    content: '不可添加重复的标签!',
                    result: 'warning',
                    iconShow: true,
                }).show();
            }
        }
        if (arr.length === 0) {
            return false;
        }
        this.contentProxy.proxy.push(...arr);
        this.render(arr);
        this.renderFinish();
        this.options.onAdd && this.options.onAdd.call(this, arr);
        'add' in this.handlers ? this.emit('add', arr) : null;
        callback && callback.call(this, arr);
        return this;
    }
    remove(obj, callback) {
        if (axIsEmpty(obj) || this.destroyed) {
            return this;
        }
        let tags = [],
            ids = [],
            type = axType(obj);
        if (type === 'Array' && obj.length > 0) {
            obj.forEach(k => {
                let tagObj = this.getTag(k);
                if (tagObj.item) {
                    tags.push(tagObj.item)
                    ids.push(tagObj.id);
                }
            });
        } else if (type === 'String') {
            let arr = obj.split(this.options.separator);
            tags = this.content.filter(k => arr.includes(k.value));
            ids = tags.map(k => this.content.findIndex(i => i === k));
        } else {
            let tagObj = this.getTag(obj);
            if (tagObj.item) {
                tags.push(tagObj.item)
                ids.push(tagObj.id);
            }
        }
        tags.forEach(k => {
            k.dom.remove();
        });
        let doms = tags.map(k => {
            return k.dom;
        });
        this.contentProxy.proxy.forEach((k, i) => {
            doms.includes(k.dom) ? this.contentProxy.proxy.splice(i--, 1) : null;
        });
        this.toggleEmpty();
        this.options.onRemove && this.options.onRemove.call(this, tags, ids);
        'remove' in this.handlers ? this.emit('remove', tags, ids) : null;
        callback && callback.call(this, tags, ids);
        return this;
    }
    clear(callback) {
        if (this.destroyed) {
            return this;
        }
        this.contentProxy.proxy.splice(0);
        this.maxIndex = 0;
        this.targetDom.innerHTML = '';
        this.inputDom && !this.options.edit.input ? this.targetDom.appendChild(this.inputDom) : null;
        this.toggleEmpty();
        this.options.onClear && this.options.onClear.call(this);
        'clear' in this.handlers ? this.emit('clear', '') : null;
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.content.forEach(K => {
            let remove = K.dom.querySelector('[remove]');
            remove ? remove.onclick = null : null;
        });
        this.inputDom ? this.inputDom.removeEventListener('keyup', this.inputEdit, false) : null;
        this.destroyed = true;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axTags]').forEach(element => {
        new axTags(element);
    });
})();  */
/*!
 * 插件：表单校验；使用方法：new axValid('#id',{参数})
 */
const axValids = [];
class axValid {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        if (!this.targetDom.getAttribute('name')) {
            console.error('The element to be verified must have a name attribute!');
            return false;
        }
        this.options = axExtend({
            insName: '',
            label: '',
            mode: 'newline', 
            url: '', 
            iconShow: true, 
            type: '', 
            label: '', 
            parent: '',
            error: '', 
            success: '通过验证！', 
            rule: {}, 
            number: '', 
            max: '', 
            min: '', 
            length: '', 
            maxLength: '', 
            minLength: '', 
            include: [], 
            exclude: [], 
            date: '', 
            earliest: '', 
            latest: '', 
            compare: '', 
            compareLabel: '', 
            least: 1, 
            most: 2, 
            separator: '',
            successShow: true,
            message: {},
            popup: {},
            format: '', 
            inputSuccess: 'ax-check-primary', 
            inputError: 'ax-check-danger', 
            boxSuccess: 'ax-color-primary', 
            boxError: 'ax-color-danger', 
            chars: '~!@#', 
            charsShow: false, 
            trigger: 'blur', 
            ajaxType: 'post',
            onTrigger: '', 
            onChange: '',
            onInit: '',
        }, options, this.targetDom, 'axValid');
        if (this.options.parent) {
            this.parent = axIdToDom(this.options.parent);
        } else {
            this.parent = this.targetDom.closest('form') ? this.targetDom.closest('form') : document;
        }
        if (this.options.compare) {
            if (typeof this.options.compare == 'string') {
                this.compare = this.parent.querySelector('[name=' + this.options.compare + ']');
            } else {
                this.compare = axIdToDom(this.options.compare);
            }
        }
        if (this.options.compareLabel) {
            this.compareLabel = this.options.compareLabel;
        } else {
            if (this.compare && this.compare.getAttribute('data-label')) {
                this.compareLabel = this.compare.getAttribute('data-label');
            }
        }
        this.handlers = {};
        this.strong = 0;
        this.msgBox = axAddElem('div', { 'valid': '' });
        this.value = null;
        this.label = this.options.label;
        this.name = this.targetDom.getAttribute('name');
        this.type = this.targetDom.getAttribute('type') ? this.targetDom.getAttribute('type') : this.targetDom.type;
        this.text = '';
        this.verified = null;
        this.verifieds = [];
        this.getRules();
        this.strongParse = this.parseFormat();
        this.checks = {
            /**
             * 为空校验，不填则直接返回结果
             */
            required: function (value) {
                if (value) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label ? this.label + '是必填项！' : '这是必填项！' };
                }
            },
            /**
             * 特定字符串校验
             */
            email: function (value) {
                let pattern = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/;
                return this.doTest(pattern, value, '请填写正确的邮箱！');
            },
            telephone: function (value) {
                let pattern = /^[1][3456789][0-9]{9}$/;
                return this.doTest(pattern, value, '请填写11位手机号！');
            },
            landline: function (value) {
                let pattern = /^([0-9]{3,4}-)?[0-9]{7,8}$/;
                return this.doTest(pattern, value, '请填写正确的座机号码！');
            },
            ip: function (value) {
                let pattern = /^\d+\.\d+\.\d+\.\d+$/;
                return this.doTest(pattern, value, '请填写正确的IP地址！');
            },
            plate: function (value) {
                let pattern = '';
                if (value.length == 8) {
                    pattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
                } else {
                    pattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/;
                }
                return this.doTest(pattern, value, '请填写正确的车牌号！');
            },
            idCard: function (value) {
                let pattern = /^(([1][1-5])|([2][1-3])|([3][1-7])|([4][1-6])|([5][0-4])|([6][1-5])|([7][1])|([8][1-2]))\d{4}(([1][9]\d{2})|([2]\d{3}))(([0][1-9])|([1][0-2]))(([0][1-9])|([1-2][0-9])|([3][0-1]))\d{3}[0-9xX]$/;
                return this.doTest(pattern, value, '请填写正确的身份证号！');
            },
            zip: function (value) {
                let pattern = /^\d{6}$/;
                return this.doTest(pattern, value, '只能填写6位数字邮编！');
            },
            url: function (value) {
                let pattern = /^(?=^.{3,255}$)(http(s)?:\/\/)?(www\.)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+(:\d+)*(\/\w+\.\w+)*$/;
                return this.doTest(pattern, value, '请填写正确的域名！');
            },
            /**
             * 字符类型校验
             */
            chinese: function (value) {
                let pattern = /^[\u0391-\uFFE5]+$/;
                return this.doTest(pattern, value, this.label + '只能填写中文！');
            },
            letter: function (value) {
                let pattern = /^[a-zA-Z]+$/;
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母！');
            },
            string: function (value) {
                let pattern = /^[a-zA-Z0-9]+$/;
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母和数字！');
            },
            password: function (value) {
                let pattern = new RegExp('^[a-zA-Z0-9' + this.options.chars + ']+$');
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母、数字以及特殊字符！');
            },
            /** 
             *日期格式校验
             */
            ymdhms: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11-13 2:56:12的日期格式！');
            },
            ymd: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11-13的日期格式！');
            },
            hms: function (value) {
                let pattern = /^((20|21|22|23|[0-1]\d)\:[0-5][0-9])(\:[0-5][0-9])?$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2:56:12的日期格式！');
            },
            ym: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11的日期格式！');
            },
            y: function (value) {
                let pattern = /^(\d{4})$/;
                return this.doTest(pattern, value, this.label + '只能填写4位数字年份！');
            },
            m: function (value) {
                let pattern = /^(0?[1-9]|1[0-2])$/;
                return this.doTest(pattern, value, this.label + '只能填写1~12月份！');
            },
            d: function (value) {
                let pattern = /^((0?[1-9])|((1|2)[0-9])|30|31)$/;
                return this.doTest(pattern, value, this.label + '只能填写1~31日！');
            },
            date: function (value) {
                let ymdhms = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/,
                    ymd = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/,
                    ym = /^(\d{1,4})(-|\/)(\d{1,2})$/,
                    y = /^(\d{4})$/;
                if (ymdhms.test(value) || ymd.test(value) || ym.test(value) || y.test(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '请填写有效的日期！' };
                }
            },
            earlier: function (value) {
                if (!this.options.date || isNaN(Date.parse(this.options.date))) {
                    console.error('Please enter a valid target date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    target = axLocalTime(this.options.date);
                if (timestamp < target) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可晚于' + this.options.date + '！' };
                }
            },
            later: function (value) {
                if (!this.options.date || isNaN(Date.parse(this.options.date))) {
                    console.error('Please enter a valid target date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    target = axLocalTime(this.options.date);
                if (timestamp > target) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可早于' + this.options.date + '！' };
                }
            },
            dateRange: function (value) {
                if (!this.options.earliest || isNaN(Date.parse(this.options.earliest))) {
                    console.error('Please enter a valid earliest date!');
                    return;
                }
                if (!this.options.latest || isNaN(Date.parse(this.options.latest))) {
                    console.error('Please enter a valid latest date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    earliest = axLocalTime(this.options.earliest),
                    latest = axLocalTime(this.options.latest);
                if (timestamp > earliest && timestamp < latest) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可早于' + this.options.latest + '，且不可晚于' + this.options.earliest + '！' };
                }
            },
            /** 
             *数字校验
             */
            integer: function (value) {
                let pattern = /^[1-9]d*$/;
                return this.doTest(pattern, value, this.label + '只能填写非0开头的正整数！');
            },
            number: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                return this.doTest(pattern, value, this.label + '只能填写数字，包括正数、负数、整数、小数！');
            },
            moreThan: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value > this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于' + this.options.number + '！' };
                }
            },
            moreEqual: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value >= this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于或等于' + this.options.number + '！' };
                }
            },
            lessThan: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value < this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要小于' + this.options.number + '！' };
                }
            },
            lessEqual: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value <= this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要小于或等于' + this.options.number + '！' };
                }
            },
            equal: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value == this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要等于' + this.options.number + '！' };
                }
            },
            range: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value >= this.options.min && value < this.options.max) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于等于' + this.options.min + '并小于' + this.options.max + '！' };
                }
            },
            /*
             *字符长度校验
             */
            length: function (value) {
                let pattern = new RegExp('^.{' + this.options.length + '}$');
                return this.doTest(pattern, value, this.label + '只能填写' + this.options.length + '个字符！');
            },
            lengthMore: function (value) {
                let pattern = new RegExp('^.{' + this.options.length + ',}$');
                return this.doTest(pattern, value, this.label + '字符数量不可少于' + this.options.length + '个！');
            },
            lengthLess: function (value) {
                let pattern = new RegExp('^.{0,' + this.options.length + '}$');
                return this.doTest(pattern, value, this.label + '字符数量不可多于' + this.options.length + '个！');
            },
            lengthRange: function (value) {
                let pattern = new RegExp('^.{' + this.options.minLength + ',' + this.options.maxLength + '}$');
                return this.doTest(pattern, value, this.label + '字符数量不可少于' + this.options.minLength + '个，而且不可多于' + this.options.maxLength + '个！');
            },
            /**
             * 包含与否检验
             */
            include: function (value) {
                if (axIsEmpty(this.options.include)) {
                    console.error('The array of include can not be empty!');
                    return;
                }
                if (this.options.include.includes(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '填写的值在指定内容中不存在！' };
                }
            },
            exclude: function (value) {
                if (axIsEmpty(this.options.exclude)) {
                    console.error('The array of exclude can not be empty!');
                    return;
                }
                if (!this.options.exclude.includes(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可填写该值！' };
                }
            },
            /**
             * 强度校验
             */
            strong: function (value) {
                if (!this.options.format) {
                    console.error(axError.formatError);
                    return;
                }
                this.getStrong(value);
                let pattern = new RegExp(this.strongParse.pattern);
                return this.doTest(pattern, value, this.strongParse.message);
            },
            /**
             * 异步校验，需要配合this.options.url参数
             */
            async: function (value) {
                if (!this.options.format) {
                    console.error(axError.formatError);
                    return;
                }
                this.getStrong(value);
                let pattern = new RegExp(this.strongParse.pattern);
                return this.doTest(pattern, value, this.strongParse.message);
            },
            /**
             * 选择数量校验，radio、checkbox、select使用
             */
            oneChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (value.length == 1) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '必须且只能选择1项！' };
                }
            },
            leastChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (this.options.least && value.length >= this.options.least) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '至少选择' + this.options.least + '项！' };
                }
            },
            mostChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (!this.options.most || (this.options.most && value.length <= this.options.most)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '最多选择' + this.options.most + '项！' };
                }
            },
            rangeChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (this.options.least && this.options.most && this.options.most > this.options.least) {
                    if (value.length >= this.options.least && value.length <= this.options.most) {
                        return { verified: true, message: '' };
                    } else {
                        return { verified: false, message: this.label + '至少选择' + this.options.least + '项，且不能多于' + this.options.most + '项！' };
                    }
                } else {
                    console.error(axError.paraError);
                    return;
                }
            },
            /**
             * 对比校验
            */
            same: function (value) {
                if (!this.compare) {
                    console.error(axError.noNode);
                    return;
                }
                if (value == this.compare.value) {
                    return { verified: true, message: '' };
                } else {
                    let info = this.compareLabel ? this.label + '与' + this.compareLabel + '不一致！' : '两个字段值不一致！';
                    return { verified: false, message: info };
                }
            },
        }
        Object.assign(this.checks, this.options.extend);
        this.init();
        return this;
    }
    init(callback) {
         axInstance.push(this, this.options.insName, 'valid');
        let info = { dom: this.targetDom, name: this.name, instance: this };
        if (axIsEmpty(axValids)) {
            if (this.parent) {
                axValids.push({ parent: this.parent, children: [info] });
            }
        } else {
            if (axValids.some(item => (item.parent == this.parent))) {
                let index = axValids.findIndex(i => (i.parent == this.parent)),
                    infoArr = axValids[index].children;
                if (infoArr.some(i => (i.name == this.name))) {
                    for (let k = 0; k < infoArr.length; k++) {
                        if (infoArr[k].name == this.name) {
                            infoArr[k] = info;
                            break;
                        }
                    }
                } else {
                    infoArr.push(info);
                }
            } else {
                axValids.push({ parent: this.parent, children: [info] });
            }
        }
        /* 
        axValids的最终格式如下：
        [
            {
                parent:'', children: [
                    { dom: '', name: '', instance: '', verified: '' },
                    { dom: '', name: '', instance: '', verified: '' },
                ]
            },
            {
                parent:'', children: [
                    { dom: '', name: '', instance: '', verified: '' },
                    { dom: '', name: '', instance: '', verified: '' },
                ]
            },
            ...
        ] 
        以parent循环监听submit事件，以dom和instance执行校验，以name去重，以verfied确认表单验证是否全部通过
        */
        /**
         * 触发校验
         * */
        let checkFun = async () => {
            if (!axIsEmpty(this.options.extend)) {
                for (let i in this.options.extend) {
                    this.rules[i] = ['', this.options.success]
                }
            }
            let value = '';
            if (this.type == 'radio' || this.type == 'checkbox' || this.type == 'select-multiple' || this.type == 'file') {
                value = axMultiValues(this.name, this.type, this.parent);
            } else {
                value = this.targetDom.value.trim();
                if (this.options.separator) {
                    value = value.split(this.options.separator);
                }
            }
            let len = Object.keys(this.rules).length,
                index = 0;
            this.value = value;
            for (let i in this.rules) {
                index++;
                let msgFalse = this.rules[i][0],
                    msgTrue = this.rules[i][1];
                if (axIsEmpty(value)) {
                    if (i == 'required') {
                        this.text = !msgFalse ? this.checks[i].call(this, '').message : msgFalse;
                        this.verified = false;
                        break;
                    } else if (i == 'oneChecked' || i == 'leastChecked' || i == 'rangeChecked') {
                        this.text = !msgFalse ? this.checks[i].call(this, []).message : msgFalse;
                        this.verified = false;
                    } else {
                        this.text = msgTrue;
                        this.verified = true;
                    }
                } else {
                    if (this.options.type) {
                        let result = this.checks[i].call(this, value);
                        if (!result.verified) {
                            !msgFalse ? this.text = result.message : this.text = msgFalse;
                            this.verified = false;
                            break;
                        } else {
                            if (index == len) {
                                this.text = msgTrue;
                                this.verified = true;
                            }
                        }
                    }
                }
            }
            if (this.options.url && !this.options.type) {
                await axAjax({
                    url: this.options.url,
                    data: { name: this.name, value: this.value, parent: this.parent },
                    type: this.options.ajaxType,
                    success: (response) => {
                        this.verified = response.content.verified;
                        this.text = response.content.text;
                    }
                });
            }
            this.refreshDom(this.options.mode);
            info.verified = this.verified;
            callback && callback.call(this, this.verified, this.text, this.strong);
            this.options.onInit && this.options.onInit.call(this, this.verified, this.text, this.strong);
            this.options.onTrigger && this.options.onTrigger.call(this, this.verified, this.text, this.strong);
            this.verifieds.unshift(this.verified);
            if (this.verifieds.length >= 2) {
                if (this.verifieds.length > 2) {
                    this.verifieds.splice(2);
                }
                if (this.verifieds[0] != this.verifieds[1]) {
                    this.options.onChange && this.options.onChange.call(this, this.verified, this.text, this.strong);
                    'change' in this.handlers ? this.emit('change', this.verified, this.text, this.strong) : null;
                }
            }
        }
        if (this.options.trigger == 'submit') {
            checkFun();
        } else if (this.options.trigger == 'listen') {
            this.targetDom.onchange = () => {
                checkFun();
            }
        } else {
            this.targetDom.addEventListener(this.options.trigger, checkFun, false);
        }
        return this;
    }
    parseFormat() {
        if (this.options.format) {
            let upperLen = '', 
                lowerLen = '', 
                numberLen = '', 
                charLen = '', 
                cnLen = '', 
                formatMin = '', 
                formatMax = '', 
                onlyName = {},
                scaleNameGroup = [],
                scaleName = {},
                scale = '',
                regExp = '',
                regText = [],
                message = '',
                lengthOnly = null,
                formatType = '',
                formatLength = '',
                formatScale = '';
            formatType = this.options.format.split("#")[0];
            if (this.options.format.split("#")[1]) {
                formatLength = this.options.format.split("#")[1];
                formatMin = formatLength.split(",")[0];
                if (formatLength.indexOf(',') == -1) {
                    lengthOnly = true;
                    formatMax = '';
                } else if (formatLength.indexOf(',') !== -1 && formatLength.split(",")[1]) {
                    formatMax = formatLength.split(",")[1];
                } else {
                    formatMax = '';
                }
            } else {
                formatMin = '';
                formatMax = '';
            }
            if (this.options.format.split("#")[2]) {
                formatScale = this.options.format.split("#")[2];
                if (formatScale.indexOf('a') !== -1) {
                    scaleName.lower = '小写字母';
                    scale += 'a-z';
                    regText.push('a-z');
                    scaleNameGroup.push(scaleName.lower);
                }
                if (formatScale.indexOf('A') !== -1) {
                    scaleName.upper = '大写字母';
                    scale += 'A-Z';
                    regText.push('A-Z');
                    scaleNameGroup.push(scaleName.upper);
                }
                if (formatScale.indexOf('9') !== -1) {
                    scaleName.number = '数字';
                    scale += '0-9';
                    regText.push('0-9');
                    scaleNameGroup.push(scaleName.number);
                }
                if (formatScale.indexOf('~') !== -1) {
                    scaleName.char = this.options.charsShow ? '特殊字符"' + this.options.chars + '"' : '特殊字符';
                    scale += this.options.chars;
                    regText.push(this.options.chars);
                    scaleNameGroup.push(scaleName.char);
                }
                if (formatScale.indexOf('中') !== -1) {
                    scaleName.cn = '中文';
                    scale += '\u4e00-\u9fa5';
                    regText.push('\u4e00-\u9fa5');
                    scaleNameGroup.push(scaleName.cn);
                }
                if (scaleNameGroup.length > 2) {
                    scaleNameGroup = axRangeReplace(scaleNameGroup.join(), '和', scaleNameGroup.join().lastIndexOf(','));
                } else {
                    scaleNameGroup = scaleNameGroup.join()
                }
                scaleNameGroup = scaleNameGroup.replaceAll(',', '、');
                !axIsEmpty(scaleNameGroup) ? message += '必须是' + scaleNameGroup + '，并且要求' : null;
            }
            if (axIsEmpty(this.options.format.split("#")[0]) && this.options.format.split("#")[3]) {
                if (this.options.format.split("#")[3] < formatScale.length && this.options.format.split("#")[3] > 0) {
                    if (this.options.format.split("#")[3] == 2) {
                        regText.forEach(item => {
                            regExp += '(?![' + item + ']+$)';
                        });
                    } else if (this.options.format.split("#")[3] == 3) {
                        axArrange(regText, 2).forEach(item => {
                            regExp += '(?![' + item.join().replaceAll(',', '') + ']+$)';
                        });
                    } else if (this.options.format.split("#")[3] == 4) {
                        axArrange(regExp, 3).forEach(item => {
                            regExp += '(?![' + item.join().replaceAll(',', '') + ']+$)';
                        });
                    }
                } else {
                    console.error('随机字符类型必须有1种，并且不能超过允许字符类型范围！');
                }
                message = scaleNameGroup + '中至少选择' + this.options.format.split("#")[3] + '种字符。';
            }
            if (formatType.indexOf('a') !== -1) {
                let index = formatType.lastIndexOf("a");
                onlyName.lower = '小写字母';
                lowerLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.lower + '至少' + lowerLen + '个，';
            }
            if (formatType.indexOf('A') !== -1) {
                let index = formatType.lastIndexOf("A");
                onlyName.upper = '大写字母';
                upperLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.upper + '至少' + upperLen + '个，';
            }
            if (formatType.indexOf('9') !== -1) {
                let index = formatType.lastIndexOf("9");
                onlyName.number = '数字';
                numberLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.number + '至少' + numberLen + '个，';
            }
            if (formatType.indexOf('~') !== -1) {
                let index = formatType.lastIndexOf("~");
                onlyName.char = this.options.charsShow ? '特殊字符"' + this.options.chars + '"' : '特殊字符';
                charLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.char + '至少' + charLen + '个。';
            }
            if (formatType.indexOf('中') !== -1) {
                let index = formatType.lastIndexOf("中");
                onlyName.cn = '中文';
                cnLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.cn + '至少' + cnLen + '个。';
            }
            lowerLen ? regExp += '(?=' + Array(lowerLen + 1).join('.*?[a-z]') + ')' : null;
            upperLen ? regExp += '(?=' + Array(upperLen + 1).join('.*?[A-Z]') + ')' : null;
            numberLen ? regExp += '(?=' + Array(numberLen + 1).join('.*?[0-9]') + ')' : null;
            charLen ? regExp += '(?=' + Array(charLen + 1).join('.*?[' + this.options.chars + ']') + ')' : null;
            cnLen ? regExp += '(?=' + Array(cnLen + 1).join('.*?[\u4e00-\u9fa5]') + ')' : null;
            if (!axIsEmpty(scale)) {
                if (formatMin) {
                    regExp += '[' + scale + ']';
                } else {
                    regExp += '[' + scale + ']+';
                }
            } else if (axIsEmpty(scale) && formatMin) {
                regExp += '.'
            } else {
                regExp += '.{0,}'
            }
            if (formatMin && lengthOnly && !formatMax) {
                regExp += '{' + formatMin + '}';
                message += '总共只能是' + formatMin + '个字符。';
            } else if (formatMin && !formatMax) {
                regExp += '{' + formatMin + ',}';
                message += '总共至少' + formatMin + '个字符。';
            } else if (formatMin && formatMax) {
                regExp += '{' + formatMin + ',' + formatMax + '}';
                message += '总共至少' + formatMin + '个字符，且不能超过' + formatMax + '个字符。';
            }
            regExp = '^' + regExp + '$';
            return { pattern: regExp, message: message }
        } else {
            return {}
        }
    }
    getStrong(value) {
        let upVal = 0,
            lowVal = 0,
            numVal = 0,
            charVal = 0,
            cnVal = 0,
            lenVal = 0;
        if (this.options.format) {
            let minLength = this.options.format.split("#")[1].split(",")[0];
            if (value && value.match(new RegExp('[a-z]'))) { lowVal = 1; };
            if (value && value.match(new RegExp('[A-Z]'))) { upVal = 1; };
            if (value && value.match(new RegExp('[0-9]'))) { numVal = 1; }
            if (value && value.match(new RegExp('[' + this.options.chars + ']'))) { charVal = 1; };
            if (value && value.match(new RegExp('[\u4e00-\u9fa5]'))) { cnVal = 1; }
            if (value && minLength && value.length >= minLength) { lenVal = 1; };
        }
        this.strong = upVal + lowVal + numVal + charVal + cnVal + lenVal;
        return this.strong;
    }
    doTest(pattern, value, message) {
        if (pattern.test(value)) {
            return { verified: true, message: '' };
        } else {
            return { verified: false, message: message };
        }
    }
    getRules() {
        this.rules = {};
        let types = this.options.type.trim().split(",");
        if (types[0] != 'required' && types.includes('required')) {
            for (let i = 0; i < types.length; i++) {
                if (types[i] === 'required') {
                    types.splice(i, 1);
                    break;
                }
            }
            types.unshift('required');
        }
        types.forEach(item => {
            this.rules[item] = ['', ''];
            if (!axIsEmpty(this.options.rule)) {
                this.options.rule[item] ? this.rules[item] = this.options.rule[item] : null;
            }
            !this.rules[item][0] ? this.rules[item][0] = this.options.error : null;
            !this.rules[item][1] ? this.rules[item][1] = this.options.success : null;
        });
        return this.rules;
    }
    refreshText() {
        let icon = this.verified ? axIcon.font.successFill : axIcon.font.errorFill;
        if (this.options.iconShow) {
            this.msgBox.innerHTML = icon + ' ' + this.text;
        } else {
            this.msgBox.innerHTML = this.text;
        }
    }
    refreshDom(mode) {
        let classToggle = () => {
            if (this.verified) {
                this.msgBox.classList.remove(this.options.boxError)
                this.msgBox.classList.add(this.options.boxSuccess)
                this.targetDom.classList.remove(this.options.inputError);
                this.targetDom.classList.add(this.options.inputSuccess);
            } else {
                this.msgBox.classList.remove(this.options.boxSuccess)
                this.msgBox.classList.add(this.options.boxError)
                this.targetDom.classList.remove(this.options.inputSuccess);
                this.targetDom.classList.add(this.options.inputError);
            }
        };
        this.refreshText();
        if (this.options.mode.nodeType == 1 || mode.substr(0, 1) == "#") {
            let dom = axIdToDom(mode);
            if (!this.msgBox.parentNode) {
                dom.appendChild(this.msgBox);
            }
            classToggle();
        } else if (mode == 'note') {
            this.msgBox.classList.add('ax-form-txt');
            let parent = this.targetDom.closest('.ax-form-con'),
                brother = parent.nextElementSibling;
            if (this.type == 'raido' || this.type == 'checkbox') {
                if (brother && brother.hasAttribute('valid')) {
                    brother.remove();
                }
                parent.insertAdjacentElement('afterend', this.msgBox);
            } else {
                if (brother != this.msgBox) {
                    parent.insertAdjacentElement('afterend', this.msgBox);
                }
            }
            classToggle();
        } else if (mode == 'popup') {
            if (!this.popup) {
                this.popup = new axPopup(this.targetDom.closest('.ax-form-input'), axExtend({
                    content: this.msgBox,
                    padding: false,
                    placement: 'bottom-start',
                    offsetShow: false,
                    arrow: false,
                    close: false,
                    footerShow: false,
                    theme: 'crude',
                    stay: true,
                }, this.options.popup)).show();
            } else {
                this.popup.content.innerHTML = '';
                this.popup.content.appendChild(this.msgBox);
            }
            classToggle();
        } else if (mode == 'message') {
            if (!this.verified) {
                new axMessage(axExtend({
                    content: this.text,
                    result: 'error',
                    iconShow: this.options.iconShow,
                }, this.options.message)).show();
            } else {
                if (this.options.successShow) {
                    new axMessage(axExtend({
                        content: this.text,
                        result: 'success',
                        iconShow: this.options.iconShow,
                    }, this.options.message)).show();
                }
            }
            classToggle();
        } else {
            let brother = this.targetDom.closest('.ax-form-input');
            if (this.type == 'radio' || this.type == 'checkbox') {
                if (brother.nextElementSibling && brother.nextElementSibling.hasAttribute('valid')) {
                    brother.nextElementSibling.remove();
                }
                brother.insertAdjacentElement('afterend', this.msgBox);
            } else {
                if (brother != this.msgBox) {
                    brother.insertAdjacentElement('afterend', this.msgBox);
                }
            }
            this.msgBox.classList.add('ax-valid');
            classToggle();
        }
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/**
 * 点击提交表单校验，通常是对button使用js提交的时候使用
 * e：通常是window
 * data：数组数据，格式为：[{parent:'',children:{name:'',verified:'',text:''}},{}]
 * outer:表单项的父层，可以是form节点，也可以是某div节点，但是必须与表单项的父节点一致，所以建议是form节点
 * callback：校验成功后执行回调函数
 * interval：表单项校验的间隔时间，纯是为了显示逐个校验效果，默认100毫秒
*/
const axValidRepeat = (e, outer, callback, options = { data: axValids, interval: 100}) => {
    if (!outer) {
        console.error('A form node must be filled in!');
        return false;
    }
    if (axIsEmpty(options.data)) {
        console.error(axError.required);
        return false;
    }
    if (axIsEmpty(options.data.filter(i => i.parent == outer))) {
        console.error('No submittable form found!');
        return false;
    }
    let formValids = [...options.data],
        children = formValids.filter(item => item.parent == outer)[0].children,
        k = 0,
        judge = () => {
            let form = options.data.filter(i => i.parent == outer)[0];
            if (form.children.some(i => !i.verified)) {
                axPreventDefault(e);
            } else {
                callback && callback();
            }
        };
    children.forEach((i, index) => {
        i.instance.options.trigger = 'submit';
        setTimeout(() => {
            k++;
            i.instance.init(function () {
                if (k == children.length) {
                    judge();
                }
            });
        }, options.interval * index);
    });
}
(() => {
    [...document.querySelectorAll('[axValid]')].filter(item => {
        return item.getAttribute('name');
    }).forEach(item => {
        new axValid(item);
    });
    if (!axIsEmpty(axValids)) {
        let formValids = [...axValids];
        formValids.forEach(item => {
            if (item.parent.nodeName == 'FORM') {
                item.parent.addEventListener("submit", function (e) {
                    axPreventDefault(e);
                    axValidRepeat(e, item.parent, () => {
                        item.parent.submit();
                    });
                }, false);
            }
        })
    }
})();
/*!
* 插件：定义效果更好Hover操作；使用方法：new axHover('#id',{参数})
*/
class axHover {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            timeout: 50,
            interval: 50,
            threshold: 7,
            enter: () => { },
            leave: () => { },
            hold: '',
        }, options);
        this.curX;
        this.curY;
        this.preX;
        this.preY;
        this.enterTimer;
        this.leaveTimer;
        this.isActive = false;
        this.options.hold ? this.hold = axIdToDom(this.options.hold) : this.hold = '';
        this.event = (type, elem, event) => {
            if (type === 'enter') {
                this.options.enter.call(this, elem, event);
                this.isActive = true;
            } else if (type === 'leave') {
                this.options.leave.call(this, elem, event);
                this.isActive = false;
            }
        }
        this.enterCompare = (elem, e) => {
            let distX = this.preX - this.curX,
                distY = this.preY - this.curY,
                distance = Math.sqrt(distX ** 2 + distY ** 2);
            if (distance < this.options.threshold) {
                if(!this.isActive){
                    this.event('enter', elem, e);
                }
            } else {
                this.preX = this.curX;
                this.preY = this.curY;
                this.enterTimer = setTimeout(() => {
                    this.enterCompare(elem, e);
                }, this.options.interval);
            }
        };
        this.init();
    }
    init() {
        let _this = this;
        this.targetDom.addEventListener('mousemove', (e) => {
            this.curX = e.pageX;
            this.curY = e.pageY;
        });
        this.targetDom.addEventListener('mouseenter', function (e) {
            clearTimeout(_this.leaveTimer);
            _this.preX = e.pageX;
            _this.preY = e.pageY;
            _this.enterTimer = setTimeout(() => {
                _this.enterCompare(this, e);
            }, _this.options.interval);
        });
        this.targetDom.addEventListener('mouseleave', function (e) {
            clearTimeout(_this.enterTimer);
            _this.leaveTimer = setTimeout(() => {
                _this.event('leave', this, e);
            }, _this.options.timeout);
        });
        if (this.hold) {
            _this.hold.onmouseenter = function (e) {
                clearTimeout(_this.leaveTimer);
            }
            _this.hold.onmouseleave = function (e) {
                clearTimeout(_this.enterTimer);
                _this.leaveTimer = setTimeout(() => {
                    _this.event('leave', _this.targetDom, e);
                }, _this.options.timeout);
            }
        }
    };
}
/*!
 * 插件：查看更多；使用方法：new axMore('#id',{参数})
 */
const axMores = [];
class axMore {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            length: 60,
            textFold: '展开',
            textUnfold: '收起',
            classFold: 'ax-color-primary',
            classUnfold: 'ax-color-primary',
        }, options, this.targetDom,'axMore');
        this.handlers = {};
        this.html = this.targetDom.innerHTML;
        this.pureHtml = this.targetDom.textContent;
        let _this = this,
            more = true;
        this.event = function() {
            if (more) {
                _this.targetDom.removeChild(this.previousSibling);
                this.innerHTML = _this.options.textUnfold;
                this.setAttribute('class', _this.options.classUnfold);
                this.insertAdjacentHTML('beforeBegin', _this.text);
                more = false;
                'unfold' in _this.handlers ? _this.emit('unfold', '') : null;
            } else {
                _this.targetDom.removeChild(this.previousSibling);
                this.innerHTML = _this.options.textFold;
                this.setAttribute('class', _this.options.classFold);
                this.insertAdjacentHTML('beforeBegin', _this.ell);
                more = true;
                'fold' in _this.handlers ? _this.emit('fold', '') : null;
            }
        };
        !!this.targetDom.getAttribute('axMore') ? this.referName = this.targetDom.getAttribute('axMore') : this.referName = '';
        this.init();
    }
    init() {
         axInstance.push(this, this.options.insName, 'more');
        this.text = this.pureHtml.trim().replace(/<[^>]+>/g, '').replace(/ +/g, ' ');
        this.ell = this.text.substring(0, this.options.length) + '...';
        let textLength = [...this.text].length,
            link = `<a href="###" class="${this.options.classFold}">${this.options.textFold}</a>`;
        if (textLength > this.options.length) {
            this.targetDom.innerHTML = this.ell + link;
        }
        this.targetDom.lastChild.onclick = this.event;
        if (this.referName) {
            if (axIsEmpty(axMores)) {
                axMores.push({ name: this.referName, instance: this });
            } else {
                if (!axMores.some(item => (item.name == this.referName))) {
                    axMores.push({ name: this.referName, instance: this });
                }
                /*  for (let i = 0; i < axMores.length; i++) {
                     if (axMores[i].name == this.referName) {
                         axMores[i].instance = this;
                         break;
                     } else {
                         axMores.push({ name: this.referName, instance: this });
                     }
                 } */
            }
        }
        'load' in this.handlers ? this.emit('load', '') : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.lastChild.removeEventListener('click', this.event, false);
        this.targetDom.innerHTML = this.html;
        callback && callback.call(this);
    }
    updateContent(text, callback) {
        if ((typeof text) === 'string') {
            if (text.substr(0, 1) == "#") {
                text = document.querySelector(text).textContent;
            } else {
                text = text;
            }
        } else {
            text = text.textContent;
        }
        this.pureHtml = text;
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axMore]').forEach(element => {
        new axMore(element);
    });
})();
 */
/*!
 * 插件：手风琴折叠；使用方法：new axAccordion('#id',{参数})
 */
class axAccordion {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            storageName: '',
            content: '',
            dispose: false,
            active: '',
            disabled: '',
            multiple: false,
            collapseAll: true,
            borderShow: false,
            ajaxType: 'post',
            trigger: 'click',
            max: 0,
            headerBreakShow: true,
            bodyBreakShow: true,
            targetClass: '',
            itemNode: 'li',
            arrow: {
                enable: true,
                rotate: 180,
                iconClose: 'ax-icon-up',
                iconOpen: 'ax-icon-up',
                position: 'end',
            },
            tipPosition: 'begin',
            addToActive: true,
            onInit: '',
            onAdd: '',
            onRemove: '',
            onDisable: '',
            onEnable: '',
            onDisableALL: '',
            onEnableAll: '',
            onExpand: '',
            onExpanded: '',
            onCollapse: '',
            onCollapsed: '',
            onUpdate: '',
            onUpdateContent: '',
            onDestroy: '',
            onSave: '',
            onExpandAll: '',
            onCollapseAll: '',
        }, options, this.targetDom, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.triggerShow = function () {
            _this.toggle(this);
        }
        this.init();
    };
    init() {
        axInstance.push(this, this.options.insName, 'accordion');
        this.destroyed = false;
        this.data = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.setAttribute();
        this.initDataStd();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    async initDataStd() {
        if (!axIsEmpty(this.options.content)) {
            this.targetDom.innerHTML = '';
            if (typeof this.options.content === 'string') {
                await this.getAsyncData((content) => {
                    this.initRender(content);
                });
            } else {
                this.data = this.options.content;
                if (this.data.length > 0) {
                    this.initRender(this.data);
                }
            }
        } else {
            if (this.targetDom.innerHTML) {
                let children = [...this.targetDom.children];
                for (let k in children) {
                    if (k >= this.options.max && this.options.max !== 0) {
                        break;
                    }
                    let wrapperDom = children[k],
                        headerDom = wrapperDom.querySelector('.ax-accordion-header'),
                        flexDom = wrapperDom.querySelector('[flex]'),
                        bodyDom = wrapperDom.querySelector('.ax-accordion-body'),
                        contentDom = wrapperDom.querySelector('.ax-accordion-content'),
                        labelDom = headerDom.querySelector('[label]'),
                        arrowDom = headerDom.querySelector('[arrow]'),
                        tipDom = wrapperDom.querySelector('[tip]'),
                        legendDom = wrapperDom.querySelector('[legend]'),
                        headerBreakDom = headerDom.nextElementSibling && headerDom.nextElementSibling.classList.contains('ax-break-line') ? headerDom.nextElementSibling : null,
                        bodyBreakDom = contentDom.nextElementSibling && contentDom.nextElementSibling.classList.contains('ax-break-line') ? contentDom.nextElementSibling : null;
                    let obj = {
                        label: labelDom.innerHTML.trim(),
                        content: contentDom.innerHTML.trim(),
                        wrapperDom: wrapperDom,
                        flexDom: flexDom,
                        labelDom: labelDom,
                        headerDom: headerDom,
                        bodyDom: bodyDom,
                        contentDom: contentDom,
                        arrowDom: arrowDom,
                        tipDom: tipDom,
                        legendDom: legendDom,
                        headerBreakDom: headerBreakDom,
                        bodyBreakDom: bodyBreakDom,
                    }
                    if (wrapperDom.hasAttribute('active')) {
                        obj.active = true;
                    };
                    if (wrapperDom.hasAttribute('disabled')) {
                        obj.disabled = true;
                    }
                    this.data.push(obj);
                }
            }
        }
        this.renderFinish();
    }
    getAsyncData(callback) {
        return axAjax({
            type: this.options.ajaxType,
            url: this.options.content,
            opened:(response)=>{
                this.contentXhr = response.xhr;
            },
            success: (response) => {
                if (axIsEmpty(response.content)) {
                    console.warn('No data obtained!');
                    return false;
                }
                this.targetDom.innerHTML = '';
                this.data = response.content;
                callback && callback(this.data);
            }
        }, this.targetDom);
    }
    initRender(data) {
        for (let k in data) {
            if (k >= this.options.max && this.options.max !== 0) {
                break;
            }
            this.appendItem(data[k]);
        }
        this.disable(this.options.disabled);
    }
    appendItem(obj, callback) {
        let content;
        if (obj.type === 'async' || obj.type === 'url') {
            content = '';
        } else if (obj.type === 'node') {
            content = axIdToDom(obj.content);
        } else {
            if (typeof obj.content === 'string') {
                if (axStrType(obj.content)) {
                    content = axIdToDom(obj.content).innerHTML;
                } else {
                    content = obj.content
                }
            } else {
                content = obj.content || '';
            }
        }
        let wrapperDom = axAddElem(this.options.itemNode),
            flexDom = axAddElem('div', { flex: '' }),
            labelDom = axAddElem('i', { label: '' }, obj.label),
            headerDom = axAddElem('div', { class: 'ax-accordion-header' }, labelDom),
            bodyDom = axAddElem('div', { class: 'ax-accordion-body' }),
            headerBreakDom = axAddElem('hr'),
            bodyBreakDom = axAddElem('hr'),
            contentDom = axAddElem(obj.type === 'url' ? 'iframe' : 'div', obj.type === 'url' ? { class: 'ax-accordion-content', frameborder: 0 } : { class: 'ax-accordion-content' }, content);
        flexDom.appendChild(labelDom);
        headerDom.appendChild(flexDom);
        wrapperDom.appendChild(headerDom);
        if (this.options.headerBreakShow) {
            headerDom.insertAdjacentElement('afterend', headerBreakDom);
            obj.headerBreakDom = headerBreakDom;
        } else {
            obj.headerBreakDom = null;
        }
        bodyDom.appendChild(contentDom);
        if (this.options.bodyBreakShow) {
            bodyDom.insertAdjacentElement('beforeend', bodyBreakDom);
            obj.bodyBreakDom = bodyBreakDom;
        } else {
            obj.bodyBreakDom = null;
        }
        wrapperDom.appendChild(bodyDom);
        obj.wrapperDom = wrapperDom;
        obj.headerDom = headerDom;
        obj.bodyDom = bodyDom;
        obj.contentDom = contentDom;
        obj.labelDom = labelDom;
        obj.headerBreakDom = headerBreakDom;
        obj.disabled ? wrapperDom.setAttribute('disabled', '') : null;
        if (!axIsEmpty(obj.props)) {
            for (let k in obj.props) {
                wrapperDom.setAttribute(k, obj.props[k]);
            }
        }
        if (obj.tip) {
            let tipDom = axAddElem('i', { tip: '' }, obj.tip);
            if (this.options.tipPosition === 'begin') {
                labelDom.insertAdjacentElement('afterend', tipDom);
            } else if (this.options.tipPosition === 'end') {
                headerDom.insertAdjacentElement('beforeend', tipDom);
            }
            obj.tipDom = tipDom;
        }
        if (obj.legend) {
            let legendDom = axAddElem('i', { legend: '', class: obj.legend ? 'ax-iconfont ' + obj.legend : 'ax-iconfont' });
            headerDom.insertAdjacentElement('afterbegin', legendDom);
            obj.legendDom = legendDom;
        }
        if (this.options.arrow.enable) {
            let arrowDom = axAddElem('i', { arrow: '', class: `ax-iconfont ${this.options.arrow.iconClose}` });
            if (this.options.arrow.position === 'begin') {
                headerDom.insertAdjacentElement('afterbegin', arrowDom);
            } else if (this.options.arrow.position === 'end') {
                headerDom.insertAdjacentElement('beforeend', arrowDom);
            }
            obj.arrowDom = arrowDom;
        }
        this.targetDom.appendChild(wrapperDom);
        callback && callback(obj);
    }
    initActive() {
        if (this.data.length === 0) {
            return false;
        }
        if (this.options.multiple && !this.options.collapseAll) {
            this.expandAll();
        } else {
            let activeItems = this.data.filter(k => k.active);
            if (this.options.active !== '') {
                let stringArr = axValueToArr(this.options.active),
                    itemArr = [...stringArr.map(k => axFindItem(k, this.data)), ...activeItems].filter(Boolean);
                if (itemArr.length > 0) {
                    if (this.options.multiple) {
                        itemArr.forEach(k => {
                            this.expand(k);
                        });
                    } else {
                        this.expand(itemArr[0]);
                    }
                }
            } else {
                if (this.options.multiple) {
                    activeItems.forEach(k => {
                        this.expand(k);
                    });
                } else {
                    this.expand(activeItems[0]);
                }
            }
        }
    }
    asyncActive(obj, callback) {
        if (obj.contentDom.innerHTML.trim()) {
            return false;
        }
        if (obj.type === 'async' && obj.content && typeof obj.content === 'string') {
            axAjax({
                url: obj.content,
                type: this.options.ajaxType,
                success: function (content) {
                    obj.contentDom.innerHTML = content;
                    callback && callback(content);
                }
            });
        }
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-accordion') ? this.targetDom.classList.add('ax-accordion') : null;
        this.options.targetClass ? axClass.add(this.targetDom, this.options.targetClass) : null;
        this.options.borderShow ? axClass.add(this.targetDom, 'ax-border') : null;
        this.options.arrow.enable && this.options.arrow.rotate ? this.targetDom.setAttribute('rotate', this.options.arrow.rotate) : null;
    }
    renderFinish() {
        this.initActive();
        if (!this.options.dispose) {
            this.data.forEach(k => {
                if (!k.disabled) {
                    k.headerDom.addEventListener(this.options.trigger, this.triggerShow, false);
                }
            });
        }
        this.save();
    }
    workToggle(item, type = 'disable') {
        if (type === 'enable' && item.disabled) {
            delete item.disabled;
            item.wrapperDom.removeAttribute('disabled');
            item.headerDom.addEventListener(this.options.trigger, this.triggerShow, false);
        } else if (type === 'disable' && !item.disabled) {
            item.disabled = true;
            item.wrapperDom.setAttribute('disabled', '');
            item.headerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
        }
        this.save();
    }
    getDisabled() {
        return this.data.filter(k => k.disabled);
    }
    getActive() {
        return this.data.filter(k => k.active);
    }
    collapseAll(callback) {
        if (this.destroyed) {
            return this;
        }
        this.data.filter(k => k.active).forEach(k => {
            this.collapse(k);
        });
        'collapseAll' in this.handlers ? this.emit('collapseAll', '') : null;
        this.options.onCollapseAll && this.options.onCollapseAll.call(this);
        callback && callback.call(this);
    }
    expandAll(callback) {
        if (this.destroyed || !this.options.multiple) {
            return this;
        }
        this.data.forEach(k => {
            this.expand(k);
        });
        'expandAll' in this.handlers ? this.emit('expandAll', '') : null;
        this.options.onExpandAll && this.options.onExpandAll.call(this);
        callback && callback.call(this);
    }
    disable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let disableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'disable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                disableFun(k);
            });
        } else {
            disableFun(obj);
        }
        this.save();
        let disableds = this.data.filter(k => k.disabled);
        'disable' in this.handlers ? this.emit('disable', disableds) : null;
        this.options.onDisable && this.options.onDisable.call(this, disableds);
        callback && callback.call(this, disableds);
    }
    disableAll(callback) {
        this.disable(this.data);
        'disableAll' in this.handlers ? this.emit('disableAll', '') : null;
        this.options.onDisableAll && this.options.onDisableAll.call(this);
        callback && callback.call(this);
    }
    enable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let enableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'enable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                enableFun(k);
            });
        } else {
            enableFun(obj);
        }
        this.save();
        let enableds = this.data.filter(k => !k.disabled);
        'enable' in this.handlers ? this.emit('enable', enableds) : null;
        this.options.onEnable && this.options.onEnable.call(this, enableds);
        callback && callback.call(this, enableds);
    }
    enableAll(callback) {
        this.enable(this.data);
        'enableAll' in this.handlers ? this.emit('enableAll', '') : null;
        this.options.onEnableAll && this.options.onEnableAll.call(this);
        callback && callback.call(this);
    }
    updateContent(item, content, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(item, this.data);
        if (me) {
            me.contentDom.innerHTML = '';
            content ? me.content = content : null;
            if (me.type === 'url') {
                me.contentDom.src = content;
            } else if (me.type === 'async') {
                this.asyncActive(me);
            } else if (axType(me.conten).includes('HTML')) {
                me.contentDom.appendChild(me.content);
            } else {
                me.contentDom.innerHTML = me.content;
            }
            this.save();
        }
        'updateContent' in this.handlers ? this.emit('updateContent', me) : null;
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, me);
        callback && callback.call(this, me);
    }
    toggle(item) {
        let me = axFindItem(item, this.data);
        if (me.active) {
            this.collapse(me);
        } else {
            this.expand(me);
        }
    }
    collapse(obj, callback) {
        let type = axType(obj),
            item = type === 'Object' ? obj : axFindItem(obj, this.data);
        if (!item) {
            return false;
        }
        'collapse' in this.handlers ? this.emit('collapse', item) : null;
        this.options.onCollapse && this.options.onCollapse.call(this, item);
        delete item.active;
        item.wrapperDom.removeAttribute('active');
        if (this.options.arrow.enable && !this.options.arrow.rotate) {
            item.arrowDom.classList.remove(this.options.arrow.iconOpen);
            item.arrowDom.classList.add(this.options.arrow.iconClose);
        }
        axSlideUp(item.bodyDom, '', () => {
            'collapsed' in this.handlers ? this.emit('collapsed', item) : null;
            this.options.onCollapsed && this.options.onCollapsed.call(this, item);
            callback && callback.call(this, item);
        });
        this.save();
    }
    slideDown(obj, callback) {
        let type = axType(obj),
            item = type === 'Object' ? obj : axFindItem(obj, this.data);
        if (!item) {
            return false;
        }
        item.active = true;
        item.wrapperDom.setAttribute('active', '');
        if (this.options.arrow.enable && !this.options.arrow.rotate) {
            item.arrowDom.classList.remove(this.options.arrow.iconClose);
            item.arrowDom.classList.add(this.options.arrow.iconOpen);
        }
        axSlideDown(item.bodyDom, '', () => {
            'expanded' in this.handlers ? this.emit('expanded', item) : null;
            this.options.onExpanded && this.options.onExpanded.call(this, item);
            callback && callback.call(this, item);
        });
    }
    expand(item, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(item, this.data), others;
        if (!axIsEmpty(me)) {
            'expand' in this.handlers ? this.emit('expand', me) : null;
            this.options.onExpand && this.options.onExpand.call(this, me);
            if (me.type === 'async' && !me.contentDom.innerHTML) {
                me.arrowDom ? me.arrowDom.setAttribute('loading', '') : null;
                this.asyncActive(me, () => {
                    this.slideDown(me, () => {
                        callback && callback.call(this, me);
                    });
                    me.arrowDom ? me.arrowDom.removeAttribute('loading') : null;
                });
            } else {
                if (me.type === 'url' && !me.contentDom.getAttribute('src')) {
                    me.contentDom.setAttribute('src', me.content)
                }
                this.slideDown(me, () => {
                    callback && callback.call(this, me);
                });
            }
            if (!this.options.multiple) {
                others = this.data.filter(k => (k !== me && k.active));
                others.forEach(k => {
                    this.collapse(k);
                });
            }
            this.save();
        }
    }
    add(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length >= this.options.max && this.options.max !== 0) {
            console.warn('The number of children exceeds the maximum!');
            return false;
        }
        let type = axType(data),
            items = [],
            appendFun = (obj) => {
                if (this.data.findIndex(k => k.label === obj.label) === -1) {
                    this.appendItem(obj, () => {
                        this.data.push(obj);
                        items.push(obj);
                    });
                }
            };
        if (type === 'Object') {
            appendFun(data);
        } if (type === 'Array' && data.length > 0) {
            data.forEach(k => {
                appendFun(k);
            });
        }
        if (items.length > 0) {
            if (this.options.addToActive) {
                if (this.options.multiple) {
                    items.forEach(k => {
                        this.expand(k);
                    });
                } else {
                    this.expand(items[items.length - 1]);
                }
            }
            this.renderFinish();
        }
        this.save();
        'add' in this.handlers ? this.emit('add', items) : null;
        this.options.onAdd && this.options.onAdd.call(this, items);
        callback && callback.call(this, items);
        return this;
    }
    remove(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length === 0) {
            console.warn('The data is already empty!');
            return false;
        }
        let removeItem = (child) => {
            let item = axFindItem(child, this.data);
            if (item) {
                item.headerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
                item.wrapperDom.remove();
                this.data = this.data.filter(k => k !== item);
            }
        };
        if (Array.isArray(data)) {
            data.forEach(k => {
                removeItem(k);
            });
        } else {
            removeItem(data);
        }
        this.save();
        'remove' in this.handlers ? this.emit('remove', '') : null;
        this.options.onRemove && this.options.onRemove.call(this);
        callback && callback.call(this);
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            let idsActive = this.data.filter(k => k.active).map(k => k.id).filter(Boolean),
                idsDisabled = this.data.filter(k => k.disabled).map(k => k.id).filter(Boolean);
            if (!props) {
                axLocalStorage.set(this.options.storageName, { active: idsActive, disabled: idsDisabled, content: this.data });
            } else {
                !props.hasOwnProperty('active') ? props.active = idsActive : null;
                !props.hasOwnProperty('disabled') ? props.disabled = idsDisabled : null;
                !props.hasOwnProperty('content') ? props.content = this.data : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            'save' in this.handlers ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
            return this;
        }, 0)
    }
    destroy(callback) {
        this.data.forEach(k => {
            k.headerDom.removeEventListener(this.options.trigger, this.triggerShow);
        });
        this.destroyed = true;
         this.contentXhr ? this.contentXhr.abort() : null;
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* document.querySelectorAll('[axAccordion]').forEach(element => {
    new axAccordion(element);
}); */
/*!
 * 插件：页签切换；使用方法：axTab('#id',{参数})
 */
class axTab {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            storageName: '',
            trigger: 'click',
            disabled: '',
            active: 0,
            content: '',
            ajaxType: 'post',
            headerNode: 'ul',
            bodyNode: 'ul',
            headerChildNode: 'li',
            bodyChildNode: 'li',
            max: 0,
            removable: false,
            updatable: false,
            wrapperClass: '',
            headerClass: 'ax-tab-group',
            bodyClass: '',
            sticky: 0,
            swiper: {
                enable: false,
                arrowShow: false,
                options: { slidesPerView: 'auto', threshold: 4 },
            },
            menu: {
                enable: false,
                options: {
                    columns: 4,
                    size: 'lg',
                }
            },
            addToActive: true,
            onInit: '',
            onAdd: '',
            onBeforeRemove: '',
            onRemove: '',
            onDisable: '',
            onEnable: '',
            onDisableALL: '',
            onEnableAll: '',
            onActive: '',
            onUpdate: '',
            onUpdateContent: '',
            onDestroy: '',
            onSave: '',
        }, options, this.targetDom, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.swiperDom = null;
        this.swiper = null;
        this.maxIndex = 0;
        this.triggerShow = function () {
            _this.active(this);
        }
        this.labelRemove = (obj) => {
            if (this.options.onBeforeRemove) {
                let flag = this.options.onBeforeRemove.call(this, obj);
                if (flag) {
                    this.remove(obj);
                }
            } else {
                this.remove(obj);
            }
        }
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'tab');
        this.destroyed = false;
        this.data = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.initDataStd();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    async initDataStd() {
        if (!axIsEmpty(this.options.content)) {
            this.targetDom.innerHTML = '';
            if (typeof this.options.content === 'string') {
                await axAjax({
                    url: this.options.content,
                    type: this.options.ajaxType,
                    success: (response) => {
                        this.targetDom.innerHTML = '';
                        this.data = response.content;
                    }
                }, this.targetDom);
            } else {
                this.data = this.options.content;
            }
            if (this.data.length > 0) {
                this.initRender(this.data);
            }
        } else {
            !this.targetDom.classList.contains('ax-tab') ? this.targetDom.classList.add('ax-tab') : null;
            if (this.targetDom.querySelector('.ax-tab-header') && this.targetDom.querySelector('.ax-tab-body')) {
                this.navDom = this.targetDom.querySelector('[nav]');
                this.prevDom = this.navDom ? this.navDom.querySelector('[prev]') : null;
                this.nextDom = this.navDom ? this.navDom.querySelector('[next]') : null;
                this.menuDom = this.navDom ? this.navDom.querySelector('[menu]') : null;
                this.swiperDom = this.targetDom.querySelector('.ax-swiper');
                this.headerWrapperDom = this.targetDom.querySelector('.ax-tab-header');
                this.bodyWrapperDom = this.targetDom.querySelector('.ax-tab-body');
                let headerChildren = [...this.headerWrapperDom.children],
                    bodyChildren = [...this.bodyWrapperDom.children];
                for (let i = 0, len = headerChildren.length; i < len; i++) {
                    if (i >= this.options.max && this.options.max !== 0) {
                        break;
                    }
                    let k = headerChildren[i],
                        tabCaptionDom = k.querySelector('[label]'),
                        tabRemoveDom = k.querySelector('[remove]'),
                        tabUpdateDom = k.querySelector('[update]');
                    let bodyItem = bodyChildren[i];
                    if (bodyItem) {
                        let obj = {
                            label: tabCaptionDom ? tabCaptionDom.innerText : k.innerHTML,
                            content: bodyItem.innerHTML,
                            labelDom: tabCaptionDom,
                            headerDom: k,
                            bodyDom: bodyItem,
                        }
                        if (k.hasAttribute('active')) {
                            obj.active = true;
                        };
                        if (k.hasAttribute('disabled')) {
                            obj.disabled = true;
                        }
                        obj.index = this.maxIndex;
                        this.data.push(obj);
                        tabUpdateDom ? obj.updateDom = tabUpdateDom : null;
                        if (tabRemoveDom) {
                            !this.isSticky(obj) ? obj.removeDom = tabRemoveDom : tabRemoveDom.remove();
                        }
                    }
                    this.maxIndex++;
                }
                this.createSwiper();
                this.initActive();
            }
        }
        this.renderFinish();
    }
    initRender(data) {
        this.headerWrapperDom = axAddElem(this.options.headerNode, { class: 'ax-tab-header' });
        this.bodyWrapperDom = axAddElem(this.options.bodyNode, { class: 'ax-tab-body' });
        for (let i = 0, len = data.length; i < len; i++) {
            if (i >= this.options.max && this.options.max !== 0) {
                break;
            }
            this.appendItem(data[i]);
        }
        this.initActive();
        this.disable(this.options.disabled);
        this.setAttribute();
        if (this.options.swiper.enable) {
            this.headerWrapperDom.classList.add('ax-wrapper');
            this.swiperDom = axAddElem('div', { class: 'ax-swiper' }, this.headerWrapperDom);
            this.navDom = axAddElem('div', { class: 'ax-tab-swiper' }, this.swiperDom);
            if (this.options.swiper.arrowShow) {
                this.prevDom = axAddElem('i', { prev: '' });
                this.nextDom = axAddElem('i', { next: '' });
                this.navDom.insertAdjacentElement('afterbegin', this.prevDom);
                this.navDom.insertAdjacentElement('beforeend', this.nextDom);
            }
            if (this.options.menu.enable) {
                this.menuDom = axAddElem('i', { menu: '' });
                this.navDom.insertAdjacentElement('beforeend', this.menuDom);
            }
            this.targetDom.appendChild(this.navDom);
            this.createSwiper();
        } else {
            this.targetDom.appendChild(this.headerWrapperDom);
        }
        this.targetDom.appendChild(this.bodyWrapperDom);
    }
    isSticky(obj) {
        return typeof this.options.sticky === 'string' ? this.options.sticky === obj.label : this.options.sticky === obj.index;
    }
    appendItem(obj, callback) {
        if (!obj.label) {
            return false;
        }
        let content;
        if (obj.type === 'async' || obj.type === 'url') {
            content = '';
        } else if (obj.type === 'node') {
            content = axIdToDom(obj.content);
        } else {
            if (typeof obj.content === 'string') {
                if (axStrType(obj.content)) {
                    content = axIdToDom(obj.content).innerHTML;
                } else {
                    content = obj.content
                }
            } else {
                content = obj.content || '';
            }
        }
        let headerChildDom = axAddElem(this.options.headerChildNode),
            tabLabelDom = axAddElem('i', { label: '' }, obj.label),
            bodyChildDom = axAddElem(obj.type === 'url' ? 'iframe' : this.options.bodyChildNode, obj.type === 'url' ? { src: obj.content, frameborder: 0 } : '', content),
            tabRemoveDom = axAddElem('i', { remove: '' }),
            tabUpdateDom = axAddElem('i', { update: '' });
        obj.index = this.maxIndex;
        headerChildDom.appendChild(tabLabelDom);
        obj.active ? (headerChildDom.setAttribute('active', ''), bodyChildDom.setAttribute('active', '')) : null;
        obj.disabled ? headerChildDom.setAttribute('disabled', '') : null;
        if (!axIsEmpty(obj.props)) {
            for (let k in obj.props) {
                bodyChildDom.setAttribute(k, obj.props[k]);
            }
        }
        this.swiper ? headerChildDom.classList.add('ax-slide') : null;
        obj.headerDom = headerChildDom;
        obj.labelDom = tabLabelDom;
        obj.bodyDom = bodyChildDom;
        this.headerWrapperDom.appendChild(headerChildDom);
        if (this.options.updatable) {
            obj.updateDom = tabUpdateDom;
            headerChildDom.appendChild(tabUpdateDom);
        }
        if (this.options.removable && !this.isSticky(obj)) {
            obj.removeDom = tabRemoveDom;
            headerChildDom.appendChild(tabRemoveDom);
        }
        this.maxIndex++;
        callback && callback(obj);
    }
    initActive() {
        if (this.data.length === 0) {
            return false;
        }
        let activeTab = this.data.find(k => k.active) || this.data[0];
        if (this.options.active) {
            this.active(this.options.active);
        } else {
            this.active(activeTab);
        }
        /* 
                if (this.options.active) {
                    this.active(this.options.active);
                } else {
                    let activeTab;
                    if (!this.data.find(k => k.active)) {
                        activeTab = this.data[0];
                        activeTab.active = true;
                        activeTab.labelDom.setAttribute('active', '');
                        activeTab.bodyDom.setAttribute('active', '');
                    } else {
                        let activeTabs = this.data.filter(k => k.active);
                        if (activeTabs.length > 1) {
                            activeTabs.slice(1).forEach(k => {
                                k.active ? delete k.active : null;
                                k.labelDom.hasAttribute('active') ? k.labelDom.removeAttribute('active') : null;
                                k.bodyDom.hasAttribute('active') ? k.bodyDom.revoveAttribute('active') : null;
                            });
                        }
                        activeTab = activeTabs[0];
                    }
                    axIsVnode(activeTab.bodyDom) ? this.bodyWrapperDom.appendChild(activeTab.bodyDom) : null;
                    activeTab.type === 'async' ? this.asyncActive(activeTab) : null;
                } */
    }
    asyncActive(obj, callback) {
        if (obj.bodyDom.innerHTML.trim()) {
            return false;
        }
        if (obj.type === 'async' && obj.content && typeof obj.content === 'string') {
            axAjax({
                url: obj.content,
                type: this.options.ajaxType,
                success: function (response) {
                    obj.bodyDom.innerHTML = response.content;
                    callback && callback(response.content);
                }
            }, obj.bodyDom);
        }
    }
    getDropDownData() {
        return this.data.map(k => {
            return { value: k.label, label: k.label }
        })
    }
    createSwiper() {
        if (!this.swiperDom) {
            return false;
        }
        let swiperOpt = this.options.swiper.options;
        if (this.prevDom && this.nextDom) {
            swiperOpt.navigation = { nextEl: this.prevDom, prevEl: this.nextDom };
        }
        this.swiper = new axSwiper(this.swiperDom, swiperOpt);
        if (this.menuDom) {
            setTimeout(() => {
                this.dropdown = new axDropdown(this.menuDom, {
                    arrowShow: false,
                    grid: {
                        enable: this.options.menu.options.columns === 0 || this.options.menu.options.columns === 1 ? false : true,
                        columns: this.options.menu.options.columns,
                        fenceShow: true,
                    },
                    type: 'button',
                    popup: {
                        size: this.options.menu.options.size,
                    },
                    content: this.getDropDownData(),
                });
                this.dropdown.popup.on('show', () => {
                    this.getActive() && this.getActive().label ? this.dropdown.updateValues(this.getActive().label) : null;
                });
                this.dropdown.on('set', (value) => {
                    value || value === 0 ? this.active(value) : null;
                    this.swiper.slideTo(this.getIndexActive());
                });
            }, 0);
        }
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-tab') ? this.targetDom.classList.add('ax-tab') : null;
        this.options.wrapperClass ? axClass.add(this.targetDom, this.options.wrapperClass) : null;
        this.options.headerClass ? axClass.add(this.headerWrapperDom, this.options.headerClass) : null;
        this.options.bodyClass ? axClass.add(this.bodyWrapperDom, this.options.bodyClass) : null;
    }
    renderFinish() {
        this.data.forEach(k => {
            if (!k.disabled) {
                let triggerDom = k.labelDom ? k.labelDom : k.headerDom;
                triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
                if (k.updateDom) {
                    k.updateDom.onclick = () => {
                        this.updateContent(k);
                    }
                }
                if (k.removeDom) {
                    k.removeDom.onclick = () => { this.labelRemove(k) };
                }
            }
        });
        this.save();
    }
    workToggle(item, type = 'disable') {
        let triggerDom = item.labelDom ? item.labelDom : item.headerDom;
        if (type === 'enable' && item.disabled) {
            delete item.disabled;
            item.headerDom.removeAttribute('disabled');
            item.bodyDom.removeAttribute('disabled');
            triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
            item.removeDom ? item.removeDom.onclick = () => { this.labelRemove(item) } : null;
            item.updateDom ? item.updateDom.onclick = () => { this.updateContent(item) } : null;
        } else if (type === 'disable' && !item.disabled) {
            item.disabled = true;
            item.headerDom.setAttribute('disabled', '');
            item.bodyDom.setAttribute('disabled', '');
            triggerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
            item.removeDom ? item.removeDom.onclick = null : null;
            item.updateDom ? item.updateDom.onclick = null : null;
        }
        this.save();
    }
    getIndexActive() {
        return this.data.findIndex(k => k.active);
    }
    getDisabled() {
        return this.data.filter(k => k.disabled);
    }
    getActive() {
        return this.data.find(k => k.active);
    }
    disable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let disableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'disable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                disableFun(k);
            });
        } else {
            disableFun(obj);
        }
        let disableds = this.data.filter(k => k.disabled);
        'disable' in this.handlers ? this.emit('disable', disableds) : null;
        this.options.onDisable && this.options.onDisable.call(this, disableds);
        callback && callback.call(this, disableds);
    }
    disableAll(callback) {
        this.disable(this.data);
        'disableAll' in this.handlers ? this.emit('disableAll', '') : null;
        this.options.onDisableAll && this.options.onDisableAll.call(this);
        callback && callback.call(this);
    }
    enable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let enableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'enable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                enableFun(k);
            });
        } else {
            enableFun(obj);
        }
        let enableds = this.data.filter(k => !k.disabled);
        'enable' in this.handlers ? this.emit('enable', enableds) : null;
        this.options.onEnable && this.options.onEnable.call(this, enableds);
        callback && callback.call(this, enableds);
    }
    enableAll(callback) {
        this.enable(this.data);
        'enableAll' in this.handlers ? this.emit('enableAll', '') : null;
        this.options.onEnableAll && this.options.onEnableAll.call(this);
        callback && callback.call(this);
    }
    updateContent(tab, content, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(tab, this.data);
        if (me) {
            me.bodyDom.innerHTML = '';
            content ? me.content = content : null;
            if (me.type === 'url') {
                me.bodyDom.src = content;
            } else if (me.type === 'async') {
                this.asyncActive(me);
            } else if (axType(me.conten).includes('HTML')) {
                me.bodyDom.appendChild(me.content);
            } else {
                me.bodyDom.innerHTML = me.content;
            }
            this.save();
        }
        'updateContent' in this.handlers ? this.emit('updateContent', me) : null;
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, me);
        callback && callback.call(this, me);
    }
    active(tab, callback) {
        if (this.destroyed) {
            return this;
        }
        let findMethod = axType(tab).includes('HTML') && tab.hasAttribute('label') ? axFindItem(tab, this.data, { dom: 'labelDom' }) : axFindItem(tab, this.data),
            me = findMethod, others;
        if (!axIsEmpty(me)) {
            !me.active ? me.active = true : null;
            me.headerDom.setAttribute('active', '');
            me.bodyDom.setAttribute('active', '');
            axIsVnode(me.bodyDom) ? this.bodyWrapperDom.appendChild(me.bodyDom) : null;
            me.type === 'async' ? this.asyncActive(me) : null;
            others = this.data.filter(k => k !== me);
            others.forEach(k => {
                k.active ? delete k.active : null;
                k.headerDom.removeAttribute('active');
                k.bodyDom.removeAttribute('active');
            });
            this.save();
        }
        'active' in this.handlers ? this.emit('active', me) : null;
        this.options.onActive && this.options.onActive.call(this, me);
        callback && callback.call(this, me);
    }
    add(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length >= this.options.max && this.options.max !== 0) {
            console.warn('The number of tabs exceeds the maximum!');
            return false;
        }
        let type = axType(data),
            items = [],
            appendFun = (obj) => {
                if (this.data.findIndex(k => k.label === obj.label) === -1) {
                    this.appendItem(obj, () => {
                        this.data.push(obj);
                        items.push(obj);
                    });
                }
            };
        if (type === 'Object') {
            appendFun(data);
        } if (type === 'Array' && data.length > 0) {
            data.forEach(k => {
                appendFun(k);
            });
        }
        if (items.length > 0) {
            this.swiper ? this.swiper.update(true) : null;
            if (this.options.addToActive) {
                this.active(items[items.length - 1]);
                this.swiper ? this.swiper.slideTo(items[items.length - 1]) : null;
            }
            this.renderFinish();
            this.dropdown ? this.dropdown.updateContent(this.getDropDownData()) : null;
        }
        'add' in this.handlers ? this.emit('add', items) : null;
        this.options.onAdd && this.options.onAdd.call(this, items);
        callback && callback.call(this, items);
        return this;
    }
    remove(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length === 0) {
            console.warn('The data is already empty!');
            return false;
        }
        let removeItem = (tab) => {
            let item = axFindItem(tab, this.data);
            if (item) {
                !item.labelDom ? item.headerDom.removeEventListener(this.options.trigger, this.triggerShow, false) : null;
                item.headerDom.remove();
                item.bodyDom.remove();
                this.data = this.data.filter(k => k !== item);
                this.swiper ? this.swiper.update(true) : null;
            }
        };
        if (Array.isArray(data)) {
            data.forEach(k => {
                removeItem(k);
            });
        } else {
            removeItem(data);
        }
        this.save();
        this.swiper ? this.swiper.update(true) : null;
        this.dropdown ? this.dropdown.updateContent(this.getDropDownData()) : null;
        'remove' in this.handlers ? this.emit('remove', '') : null;
        this.options.onRemove && this.options.onRemove.call(this);
        callback && callback.call(this);
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            let idsActive = this.getIndexActive(),
                idsDisabled = this.data.filter(k => k.disabled).map(k => k.id).filter(Boolean);
            if (!props) {
                axLocalStorage.set(this.options.storageName, { active: idsActive, disabled: idsDisabled, content: this.data });
            } else {
                !props.hasOwnProperty('active') ? props.active = idsActive : null;
                !props.hasOwnProperty('disabled') ? props.disabled = idsDisabled : null;
                !props.hasOwnProperty('content') ? props.content = this.data : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            'save' in this.handlers ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
            return this;
        }, 0)
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.data.forEach(k => {
            let triggerDom = k.labelDom ? k.labelDom : k.headerDom;
            triggerDom.removeEventListener(this.options.trigger, this.triggerShow);
            k.removeDom ? k.removeDom.onclick = null : null;
            k.updateDom ? k.updateDom.onclick = null : null;
        });
        this.swiper ? this.swiper.destroy() : null;
        this.dropdown ? this.dropdown.popup.destroy() : null;
        this.destroyed = true;
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* document.querySelectorAll('[axTab]').forEach(element => {
    new axTab(element);
});
 */
/*!
* 插件：抽屉侧边窗；使用方法：new axDrawer({参数},'#id')；#id是可选参数，可以从该dom获取参数值
*/
class axDrawer {
    constructor(options, elem) {
        this.options = axExtend({
            insName: '',
            title: '',
            titleBreak: true,
            overlay: true,
            overlayClose: true,
            duration: 0,
            placement: 'right',
            size: 'sm',
            padding: 'ax-padding',
            offset: '100px', 
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-opened',
            rel: '',
            close: true,
            footerType: 'center',
            footerShow: true,
            footerBreak: false,
            note: '',
            ajaxType: 'post',
            zIndex: 0,
            preventScroll: false,
            onInit: '',
            onShow: '',
            onShown: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onUpdated: '',
            onUpdateContent: '',
            onDestroy: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem, this.constructor.name);
        this.handlers = {};
        this.form = null;
        elem ? this.button = axIdToDom(elem) : null;
        this.state = 'hidden';
        this.sequenceShow = (dom, direction) => {
            if (!dom.style[direction]) {
                dom.style[direction] = this.options.offset
            } else {
                dom.style[direction] = parseInt(dom.style[direction]) * 0.6 + parseInt(this.options.offset) + 'px';
            }
        }
        this.sequenceHide = (dom, direction) => {
            if (!dom.style[direction]) {
                let prop = direction === 'left' || direction === 'right' ? 'width' : 'height';
                dom.style[direction] = '-' + getComputedStyle(dom)[prop];
            } else {
                if (dom.style[direction] == this.options.offset) {
                    dom.removeAttribute('style');
                } else {
                    dom.style[direction] = (parseInt(dom.style[direction]) - parseInt(this.options.offset)) / 0.6 + 'px';
                }
            }
        }
        this.init();
        return this;
    }
    async init() {
        axInstance.push(this, this.options.insName, 'drawer');
        this.destroyed = false;
        this.rel = axAllToDoms(this.options.rel);
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType === 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
            this.form = this.content.querySelector('form');
        } else if (this.options.type === 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) === '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            let response;
            if (this.options.type === 'async' && this.options.url) {
                response = await axCreateContent(this.options, this);
            } else {
                response = axCreateContent(this.options, this);
            }
            if (typeof this.options.content === 'function') {
                this.content.innerHTML = this.options.content.call(this,response.content);
            } else {
                this.content.innerHTML = response.content;
            }
            this.form = this.content.querySelector('form');
        }
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.footer.innerHTML = axFooterBtns(this.options, this);
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = (e)=> {
                if (this.options.confirm.type == 'submit') {
                    if (this.form && this.options.type == 'form') {
                        axValidRepeat(e, this.form, () => {
                            this.form.submit();
                        });
                        this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (this.options.confirm.type == 'async') {
                    if (this.form && this.options.type == 'form' && this.options.confirm.url) {
                        axValidRepeat(e, this.form, () => {
                            axAjaxSubmit(this.options.confirm.url, this.form, elem, {
                                type: this.options.ajaxType,
                                opened: (response) => {
                                    this.submitXhr = response.xhr;
                                },
                                success: (response) => {
                                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, response.content);
                                }
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of async is required!');
                        return false;
                    }
                } else if (this.options.confirm.type == 'prevent') {
                    axPreventDefault(e);
                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                } else {
                    this.hide();
                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick =  ()=> {
                this.options.diy.callback && this.options.diy.callback.call(this, elem);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick =  ()=> {
                this.hide();
                this.options.cancel.callback && this.options.cancel.callback.call(this, elem);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click',  ()=> {
                this.hide();
            }, false);
        });
        if (this.button) {
            this.button.onclick = () => {
                this.show();
            }
        }
        if (this.rel.length > 0) {
            this.rel.forEach(item => {
                item.onclick = () => {
                    this.show();
                }
            });
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createTemplate() {
        return `
                    <div class="ax-drawer" data-overlay="true">
                        <# if(this.overlay){ #><div class="ax-drawer-overlay" <# if(this.overlayClose){ #>close<# } #>></div><# } #>
                        <div class="ax-drawer-wrapper">
                            <# if(this.close){ #> <a href="###" class="ax-drawer-close" close><i class="ax-iconfont ax-icon-close"></i></a><# } #>
                            <# if(this.title){ #><div class="ax-drawer-header"><div class="ax-col ax-align-center"><# this.title #></div></div><# } #>
                            <# if(this.title && this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                            <div class="ax-drawer-body">
                                <# if(this.padding){ #><div class="<# this.padding #>" <# if(this.type == 'iframe'){ #>style="height:100%;"<# } #>> <# } #>
                                    <div class="ax-drawer-content" <# if(this.type == 'iframe'){ #>style="height:100%;"<# } #>></div>
                                <# if(this.padding){ #></div><# } #>
                            </div>
                            <div class="ax-drawer-footer">
                            </div>
                        </div>
                    </div>
                  `;
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-drawer-wrapper');
        this.targetDom.querySelector('.ax-drawer-overlay') ? this.overlay = this.targetDom.querySelector('.ax-drawer-overlay') : null;
        this.content = this.targetDom.querySelector('.ax-drawer-content');
        this.body = this.targetDom.querySelector('.ax-drawer-body');
        this.targetDom.querySelector('.ax-drawer-footer') ? this.footer = this.targetDom.querySelector('.ax-drawer-footer') : null;
        this.width = window.getComputedStyle(this.wrapper).width;
        this.height = window.getComputedStyle(this.wrapper).height;
        this.left = window.getComputedStyle(this.wrapper).left;
        this.right = window.getComputedStyle(this.wrapper).right;
        this.top = window.getComputedStyle(this.wrapper).top;
        this.bottom = window.getComputedStyle(this.wrapper).bottom;
    }
    setAttribute() {
        if (this.options.placement == "left") {
            this.targetDom.setAttribute('data-placement', 'left');
        } else if (this.options.placement == "right") {
            this.targetDom.setAttribute('data-placement', 'right');
        } else if (this.options.placement == "top") {
            this.targetDom.setAttribute('data-placement', 'top');
        } else if (this.options.placement == "bottom") {
            this.targetDom.setAttribute('data-placement', 'bottom');
        } else {
            return;
        }
        if (this.options.size == "sm") {
            this.targetDom.setAttribute('data-size', 'sm');
        } else if (this.options.size == 'md') {
            this.targetDom.setAttribute('data-size', 'md');
        } else if (this.options.size == 'lg') {
            this.targetDom.setAttribute('data-size', 'lg');
        } else {
            return;
        }
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
    }
    show(callback) {
        if (this.destroyed || this.state !== 'hidden') {
            return this;
        }
        this.state = 'ing';
        document.body.appendChild(this.targetDom);
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        if (this.options.duration) {
            this.duration = this.options.duration;
        } else {
            this.duration = parseFloat(axStyle(this.wrapper).animationDuration) * 1000
        }
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        axInstance.data.filter(i => i.type === 'drawer' && !i.instance.destroyed).forEach(item => {
            if (item.instance.state === 'shown' && item.instance.options.placement === this.options.placement) {
                this.sequenceShow(item.instance.wrapper, this.options.placement);
            }
        });
        this.targetDom.classList.add("ax-show");
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        setTimeout(() => {
            this.state = 'shown';
            this.options.onShown && this.options.onShown.call(this);
            'shown' in this.handlers ? this.emit('shown', '') : null;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed || this.state !== 'shown') {
            return this;
        }
        this.state = 'ing';
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        this.overlay ? this.overlay.style.opacity = 0 : null;
        this.sequenceHide(this.wrapper, this.options.placement);
        setTimeout(() => {
            this.state = 'hidden';
            this.targetDom.classList.remove("ax-show");
            this.overlay ? this.overlay.removeAttribute("style") : null;
            this.wrapper.removeAttribute("style");
            this.targetDom.remove();
            this.options.onHidden && this.options.onHidden.call(this);
            'hidden' in this.handlers ? this.emit('hidden', '') : null;
        }, this.duration);
        axInstance.data.filter(i => i.type === 'drawer' && !i.instance.destroyed).forEach(item => {
            if (item.instance.state === 'shown' && item.instance.options.placement === this.options.placement && item.instance !== this) {
                this.sequenceHide(item.instance.wrapper, this.options.placement);
            }
        });
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.button.onclick = null;
        this.rel.forEach(i => {
            i.onclick = null;
        });
        this.contentXhr ? this.contentXhr.abort() : null;
        this.submitXhr ? this.submitXhr.abort() : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            isUpdated = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            if (this.state === 'shown') {
                this.init().show();
            } else if (this.state === 'hidden') {
                this.init();
            }
            targetDom.remove();
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, after);
        this.options.onUpdated && this.options.onUpdated.call(this, isUpdated, before, after);
        'updated' in this.handlers ? this.emit('updated', isUpdated, before, after) : null;
        return this;
    }
    updateContent(data, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            isUpdated = false;
        if (axType(data) === 'String') {
            if (axStrType(data)) {
                this.content.innerHTML = axIdToDom(data) ? axIdToDom(data).innerHTML : '';
            } else {
                this.content.innerHTML = data;
            }
        } else if (axType(data).includes('HTML')) {
            this.content.innerHTML = '';
            this.content.appendChild(data);
        } else {
            this.content.innerHTML = `No data to update!`;
        }
        if (this.content.innerHTML == before) {
            isUpdated = false;
        } else {
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, this.content.innerHTML);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, isUpdated, before, this.content.innerHTML);
        'updateContent' in this.handlers ? this.emit('updateContent', isUpdated, before, this.content.innerHTML) : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axDrawer('', elem);
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axDrawer]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axDrawer]');
    eachInstance(arrInstance);
})();
 */
/*!
 * 插件：对话弹窗；使用方法：new axDialog({参数},'#id')；#id是可选参数，可以从该dom获取参数值
 */
class axDialog {
    constructor(options, elem) {
        this.options = axExtend({
            insName: '',
            title: '',
            titleBreak: false,
            overlay: true,
            overlayClose: true,
            duration: 0,
            placement: 'center',
            in: 'springIn',
            out: 'scaleOut',
            multiple: true,
            size: 'md',
            padding: 'ax-padding',
            drag: false,
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-opened',
            rel: '',
            name: '',
            width: '',
            height: '',
            close: true,
            closePlace: 'inside',
            footerShow: true,
            footerType: 'center',
            footerBreak: false,
            note: '',
            ajaxType: 'post',
            zIndex: 0,
            preventScroll: false,
            onDrag: '',
            onDragged: '',
            onInit: '',
            onShow: '',
            onShown: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onUpdated: '',
            onUpdateContent: '',
            onDestroy: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem, this.constructor.name);
        this.wrapper = '';
        this.content = '';
        this.overlay = '';
        this.handlers = {};
        this.wrapPosition = '';
        this.wrapLeft = '';
        this.wrapTop = '';
        this.form = null;
        elem ? this.button = axIdToDom(elem) : null;
        this.state = 'hidden';
        this.init();
        return this;
    }
    async init() {
        axInstance.push(this, this.options.insName, 'dialog');
        this.destroyed = false;
        this.rel = axAllToDoms(this.options.rel);
        axClient() === 'phone' ? this.options.placement = 'center' : null;
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType === 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
            this.form = this.content.querySelector('form');
        } else if (this.options.type === 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) === '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            let response;
            if (this.options.type === 'async' && this.options.url) {
                response = await axCreateContent(this.options, this);
            } else {
                response = axCreateContent(this.options, this);
            }
            if (typeof this.options.content === 'function') {
                this.content.innerHTML = this.options.content.call(this, response.content);
            } else {
                this.content.innerHTML = response.content;
            }
            this.form = this.content.querySelector('form');
        }
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.footer.innerHTML = axFooterBtns(this.options, this);
        if (this.options.drag) {
            this.drag();
        }
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = (e) => {
                if (this.options.confirm.type == 'submit') {
                    if (this.form && this.options.type == 'form') {
                        axValidRepeat(e, this.form, () => {
                            this.form.submit();
                        });
                        this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (this.options.confirm.type == 'async') {
                    if (this.form && this.options.type == 'form' && this.options.confirm.url) {
                        axValidRepeat(e, this.form, () => {
                            axAjaxSubmit(this.options.confirm.url, this.form, elem, {
                                type: this.options.ajaxType,
                                opened: (response) => {
                                    this.submitXhr = response.xhr;
                                },
                                success: (response) => {
                                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, response.content);
                                }
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of async is required!');
                        return false;
                    }
                } else if (this.options.confirm.type == 'prevent') {
                    axPreventDefault(e);
                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                } else {
                    this.hide();
                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick =  ()=> {
                this.options.diy.callback && this.options.diy.callback.call(this, elem);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick =  ()=> {
                this.hide();
                this.options.cancel.callback && this.options.cancel.callback.call(this, elem);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click',  ()=> {
                this.hide();
            }, false);
        });
        if (this.button) {
            this.button.onclick = () => {
                this.show();
            }
        }
        if (this.rel.length > 0) {
            this.rel.forEach(item => {
                item.onclick = () => {
                    this.show();
                }
            });
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createTemplate() {
        return `
        <div class="ax-dialog" data-overlay="true">
        <# if(this.overlay){ #><div class="ax-dialog-overlay" <# if(this.overlayClose){ #>close<# } #>></div><# } #>
            <div class="ax-dialog-wrapper">
                <# if(this.close){ #><a href="###" class="ax-dialog-close" close><i class="ax-iconfont ax-icon-close"></i></a><# } #>
                <# if(this.title){ #><div class="ax-dialog-header"><# this.title #></div><# } #>
                <# if(this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                <div class="ax-dialog-body">
                    <# if(typeof this.padding == 'string'){ #><div class="<# this.padding #>"> <# }else if(this.padding){ #><div class="ax-padding"> <# } #>
                    <div class="ax-dialog-content"></div>
                    <# if(this.padding){ #></div><# } #>
                </div>
                <div class="ax-dialog-footer">
                </div>
            </div>
        </div>
      `
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-dialog-wrapper');
        this.header = this.targetDom.querySelector('.ax-dialog-header');
        this.content = this.targetDom.querySelector('.ax-dialog-content');
        this.body = this.targetDom.querySelector('.ax-dialog-body');
        this.overlay = this.targetDom.querySelector('.ax-dialog-overlay');
        this.footer = this.targetDom.querySelector('.ax-dialog-footer');
    }
    setAttribute() {
        this.options.size ? this.targetDom.setAttribute('data-size', this.options.size) : null;
        this.options.footerType ? this.targetDom.setAttribute('data-footerType', this.options.footerType) : null;
        this.options.height ? this.content.style.height = this.options.height : null;
        this.oldStyle = this.options.width ? `width:${this.options.width};` : null;
        this.options.type ? this.targetDom.setAttribute('data-type', this.options.type) : null;
        !this.options.overlay ? this.targetDom.setAttribute('data-overlay', 'false') : null;
        if (!this.options.title && this.options.close) {
            if (this.options.size == 'lg') {
                this.targetDom.setAttribute('data-closePlace', 'bottom');
            } else if (!this.options.title && this.options.closePlace == 'inside') {
                this.targetDom.setAttribute('data-closePlace', 'outside');
            } else {
                this.targetDom.setAttribute('data-closePlace', this.options.closePlace)
            }
        } else if (this.options.closePlace && this.options.close) {
            this.targetDom.setAttribute('data-closePlace', this.options.closePlace)
        }
        this.targetDom.setAttribute('placement', this.options.placement);
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
    }
    drag(callback) {
        if (this.destroyed) {
            return false;
        }
        if (this.options.title) {
            let _this = this,
                header = this.targetDom.querySelector('.ax-dialog-header');
            this.targetDom.setAttribute('data-drag', this.options.drag);
            header.onmousedown = function (e) {
                _this.options.onDrag && _this.options.onDrag.call(this);
                'drag' in _this.handlers ? _this.emit('drag', '') : null;
                this.style.cursor = 'move';
                let moveDiv = this.parentNode;
                moveDiv.style.cssText += 'position:fixed ;';
                _this.wrapPosition = 'fixed';
                let x = e.clientX - moveDiv.offsetLeft;
                let y = e.clientY - moveDiv.offsetTop;
                document.onmousemove = function (ev) {
                    let _x = ev.clientX - x;
                    let _y = ev.clientY - y;
                    let maxX = document.documentElement.clientWidth - moveDiv.clientWidth;
                    let maxY = document.documentElement.clientHeight - moveDiv.clientHeight;
                    if (_x < 0) {
                        _x = 0;
                    }
                    if (_x > maxX) {
                        _x = maxX;
                    }
                    if (_y < 0) {
                        _y = 0;
                    }
                    if (_y > maxY) {
                        _y = maxY;
                    }
                    moveDiv.style.left = _x + 'px';
                    moveDiv.style.top = _y + 'px';
                    _this.wrapLeft = moveDiv.style.left;
                    _this.wrapTop = moveDiv.style.top;
                };
            };
            header.onmouseup = function () {
                document.onmousemove = null;
                document.onmouseup = null;
                _this.options.onDragged && _this.options.onDragged.call(this);
                'dragged' in _this.handlers ? _this.emit('dragged', '') : null;
            }
            header.ondragstart = function (ev) {
                axPreventDefault(ev);
            };
            header.ondragend = function (ev) {
                axPreventDefault(ev);
            };
            callback && callback.call(this);
        } else {
            return false;
        }
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            isUpdated = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            if (this.state === 'shown') {
                this.init().show();
            } else if (this.state === 'hidden') {
                this.init();
            }
            targetDom.remove();
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, after);
        this.options.onUpdated && this.options.onUpdated.call(this, isUpdated, before, after);
        'updated' in this.handlers ? this.emit('updated', isUpdated, before, after) : null;
        return this;
    }
    updateContent(data, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            isUpdated = false;
        if (axType(data) === 'String') {
            if (axStrType(data)) {
                this.content.innerHTML = axIdToDom(data) ? axIdToDom(data).innerHTML : '';
            } else {
                this.content.innerHTML = data;
            }
        } else if (axType(data).includes('HTML')) {
            this.content.innerHTML = '';
            this.content.appendChild(data);
        } else {
            this.content.innerHTML = `No data to update!`;
        }
        if (this.content.innerHTML == before) {
            isUpdated = false;
        } else {
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, this.content.innerHTML);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, isUpdated, before, this.content.innerHTML);
        'updateContent' in this.handlers ? this.emit('updateContent', isUpdated, before, this.content.innerHTML) : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.button.onclick = null;
        this.rel.forEach(i => {
            i.onclick = null;
        });
        this.contentXhr ? this.contentXhr.abort() : null;
        this.submitXhr ? this.submitXhr.abort() : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        if (this.destroyed || this.state !== 'hidden') {
            return this;
        }
        this.state = 'ing';
        document.body.appendChild(this.targetDom);
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.wrapperHeight = axArrHeight(this.wrapper).height;
        if (this.options.duration) {
            this.duration = this.options.duration;
        } else if (this.wrapperHeight) {
            this.duration = Math.floor(this.wrapperHeight / 3 + 250);
        } else {
            this.duration = parseFloat(axStyle(this.wrapper).animationDuration) * 1000
        }
        if (!this.options.multiple) {
            let items = axInstance.data.filter(i => i.type.dialog && i.instance !== this && i.instance.isShow)
            items.forEach(i => {
                i.instance.hide();
            });
        }
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.classList.remove('ax-hide');
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        let dragStyle = '';
        this.wrapPosition ? dragStyle = `position:${this.wrapPosition};left:${this.wrapLeft};top:${this.wrapTop};` : null;
        if (this.options.in == 'slideDown') {
            axHeightDown(this.wrapper, { height: this.wrapperHeight }, '', this.duration);
        } else {
            this.options.duration ? this.targetDom.style.animationDuration = `${this.options.duration}ms` : null;
            this.options.in ? this.wrapper.style.cssText = `animation-name: ${this.options.in};${dragStyle};${this.oldStyle}` : null;
        }
        setTimeout(() => {
            this.state = 'shown';
            this.options.onShown && this.options.onShown.call(this);
            'shown' in this.handlers ? this.emit('shown', '') : null;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed || this.state !== 'shown') {
            return this;
        }
        this.state = 'ing';
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        this.options.duration ? this.targetDom.style.animationDuration = this.options.duration : null;
        this.targetDom.classList.add('ax-hide');
        let dragStyle = '';
        this.wrapPosition ? dragStyle = `position:${this.wrapPosition};left:${this.wrapLeft};top:${this.wrapTop};` : null;
        if (this.options.out == 'slideUp') {
            axHeightUp(this.wrapper, { height: this.wrapperHeight }, '', this.duration);
        } else {
            this.options.out ? this.wrapper.style.cssText = `animation-name: ${this.options.out};${dragStyle};${this.oldStyle}` : null;
        }
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        setTimeout(() => {
            this.state = 'hidden'
            this.targetDom.classList.remove('ax-show');
            this.targetDom.remove();
            this.options.onHidden && this.options.onHidden.call(this);
            'hidden' in this.handlers ? this.emit('hidden', '') : null;
            this.wrapper.style.cssText = this.oldStyle;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axDialog('', elem);
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axDialog]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axDialog]');
    eachInstance(arrInstance);
})(); */
/*!
* 插件：气泡定位；使用方法：new axPopupPosition(btnDom, boxDom,{参数})
*/
class axPopupPosition {
    constructor(btnDom, boxDom, options) {
        if (!btnDom || !boxDom) {
            return false;
        }
        this.btnDom = axIdToDom(btnDom);
        this.boxDom = axIdToDom(boxDom);
        this.options = axExtend({
            placement: 'top',
            arrowShow: true, 
            arrowOffset: '2.8rem',
            gap: '.8rem',
            observer: document.body,
            onInit: '',
            onUpdated: '',
        }, options);
        this.handlers = {};
        this.gap = this.strToNum(this.options.gap);
        this.observer = axIdToDom(this.options.observer);
        this.placement = this.options.placement;
        this.init();
    }
    init() {
        if (this.placement !== 'center') {
            this.createArrow();
        }
        this.setAttribute();
        this.resetPlacement();
        window.addEventListener("resize", () => {
            this.resetPlacement();
        });
        window.addEventListener('scroll', () => {
            this.resetPlacement();
        });
        new MutationObserver(() => {
            if (!this.unsettable('btn') && this.btnData) {
                if (axOffset(this.btnDom).left !== this.btnData.left || axOffset(this.btnDom).top !== this.btnData.top) {
                    this.resetPlacement();
                }
            }
        }).observe(this.observer, {
            childList: true, 
            subtree: true, 
            characterData: true, 
        });
        this.options.onInit && this.options.onInit.call(this, this.placement);
        return this;
    }
    strToNum(str) {
        if (!str) {
            return 0;
        }
        let num;
        if (str.endsWith('rem') || str.endsWith('REM')) {
            num = str.replace('rem', '').replace('REM', '') * 10;
        } else if (str.endsWith('px') || str.endsWith('PX')) {
            num = ~~str.replace('px', '').replace('PX', '');
        } else {
            num = ~~str;
        }
        return num;
    }
    setAttribute() {
        if (getComputedStyle(this.boxDom).position !== 'absolute') {
            this.boxDom.style.position = 'absolute';
        }
    }
    createArrow() {
        if (this.options.arrowShow) {
            this.arrow = axAddElem('i', { style: 'position:absolute', arrow: '' });
            this.boxDom.appendChild(this.arrow);
        }
    }
    setArrow(placement) {
        let exceedWidth = this.btnData.width > this.boxData.width / 2,
            exceedHeight = this.btnData.height > this.boxData.height / 2,
            arrowHalf = this.strToNum(getComputedStyle(this.arrow).width) / 2;
        this.boxDom.setAttribute('placement', placement);
        if (placement.includes('top') || placement.includes('bottom')) {
            if (placement.includes('start')) {
                if (!exceedWidth) {
                    this.arrow.style.left = Math.floor(this.btnData.width / 2 - arrowHalf) + 'px';
                    this.arrow.style.right = 'auto';
                } else {
                    this.arrow.style.left = this.options.arrowOffset;
                    this.arrow.style.right = 'auto';
                }
            } else if (placement.includes('end')) {
                if (!exceedWidth) {
                    this.arrow.style.left = 'auto';
                    this.arrow.style.right = Math.floor(this.btnData.width / 2 - arrowHalf) + 'px';
                } else {
                    this.arrow.style.left = 'auto';
                    this.arrow.style.right = this.options.arrowOffset;
                }
            } else {
                this.arrow.style.left = this.boxData.width / 2 - 1 - arrowHalf + 'px';
            }
        } else if (placement.includes('left') || placement.includes('right')) {
            if (placement.includes('start')) {
                if (!exceedHeight) {
                    this.arrow.style.top = Math.floor(this.btnData.height / 2 - arrowHalf) + 'px';
                    this.arrow.style.bottom = 'auto';
                } else {
                    this.arrow.style.top = this.options.arrowOffset;
                    this.arrow.style.bottom = 'auto';
                }
            } else if (placement.includes('end')) {
                if (!exceedHeight) {
                    this.arrow.style.top = 'auto';
                    this.arrow.style.bottom = Math.floor(this.btnData.height / 2 - arrowHalf) + 'px';
                } else {
                    this.arrow.style.top = 'auto';
                    this.arrow.style.bottom = this.options.arrowOffset;
                }
            } else {
                this.arrow.style.top = this.boxData.height / 2 - 1 - arrowHalf + 'px';
            }
        }
    }
    getRectData() {
        this.browserData = {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        }
        this.btnData = {
            width: this.btnDom.getBoundingClientRect().width,
            height: this.btnDom.getBoundingClientRect().height,
            offsetLeft: this.btnDom.getBoundingClientRect().left,
            offsetLeftAlt: this.btnDom.getBoundingClientRect().right,
            offsetRight: this.browserData.width - this.btnDom.getBoundingClientRect().right,
            offsetTop: this.btnDom.getBoundingClientRect().top,
            offsetTopAlt: this.btnDom.getBoundingClientRect().bottom,
            offsetBottom: this.browserData.height - this.btnDom.getBoundingClientRect().bottom,
            ...axOffset(this.btnDom)
        };
        this.boxData = {
            width: this.boxDom.getBoundingClientRect().width,
            height: this.boxDom.getBoundingClientRect().height,
            offsetLeft: this.boxDom.getBoundingClientRect().left,
            offsetLeftAlt: this.boxDom.getBoundingClientRect().right,
            offsetRight: this.browserData.width - this.boxDom.getBoundingClientRect().right,
            offsetTop: this.boxDom.getBoundingClientRect().top,
            offsetTopAlt: this.boxDom.getBoundingClientRect().bottom,
            offsetBottom: this.browserData.height - this.boxDom.getBoundingClientRect().bottom
        };
    }
    setPlacement(placement) {
        let [left, right, top, bottom] = ['auto', 'auto', 'auto', 'auto'];
        if (placement.includes('bottom')) {
            if (placement === 'bottom') {
                left = this.btnData.left - (this.boxData.width - this.btnData.width) / 2;
            } else if (placement === 'bottom-start') {
                left = this.btnData.left
            } else if (placement === 'bottom-end') {
                left = this.btnData.left + this.btnData.width - this.boxData.width;
            }
            top = `${Math.ceil(this.btnData.top + this.btnData.height + this.gap)}px`;
            left = `${Math.ceil(left)}px`;
        } else if (placement.includes('top')) {
            if (placement === 'top') {
                left = this.btnData.left - (this.boxData.width - this.btnData.width) / 2;
            } else if (placement === 'top-start') {
                left = this.btnData.left
            } else if (placement === 'top-end') {
                left = this.btnData.left + this.btnData.width - this.boxData.width;
            }
            bottom = this.browserData.height - this.btnData.top + this.gap;
            bottom = `${Math.ceil(bottom)}px`;
            left = `${Math.ceil(left)}px`;
        } else if (placement.includes('left')) {
            if (placement === 'left') {
                top = `${Math.ceil(this.btnData.top - (this.boxData.height - this.btnData.height) / 2)}px`;
            } else if (placement === 'left-start') {
                top = `${Math.ceil(this.btnData.top)}px`;
            } else if (placement === 'left-end') {
                bottom = `${Math.ceil(this.browserData.height - this.btnData.top - this.btnData.height)}px`;
            }
            right = `${Math.ceil(this.browserData.width - this.btnData.left + this.gap)}px`;
        } else if (placement.includes('right')) {
            if (placement === 'right') {
                top = `${Math.ceil(this.btnData.top - (this.boxData.height - this.btnData.height) / 2)}px`;
            } else if (placement === 'right-start') {
                top = `${Math.ceil(this.btnData.top)}px`;
            } else if (placement === 'right-end') {
                bottom = `${Math.ceil(this.browserData.height - this.btnData.top - this.btnData.height)}px`;
            }
            left = `${Math.ceil(this.btnData.left + this.btnData.width + this.gap)}px`;
        } else if (placement === 'center') {
            this.boxDom.style.position = 'fixed';
            this.boxDom.style.marginLeft = `-${Math.ceil(this.boxData.width / 2)}px`;
            this.boxDom.style.marginTop = `-${Math.ceil(this.boxData.height / 2)}px`;
            left = '50%';
            top = '50%';
        }
        this.boxDom.style.left = left;
        this.boxDom.style.right = right;
        this.boxDom.style.top = top;
        this.boxDom.style.bottom = bottom;
        if (this.arrow) {
            this.setArrow(placement);
        }
    }
    getRectOffset() {
        let left = this.btnData.offsetLeft - this.boxData.width - this.gap,
            top = this.btnData.offsetTop - this.boxData.height - this.gap,
            right = this.browserData.width - this.btnData.offsetLeftAlt - this.boxData.width - this.gap,
            bottom = this.browserData.height - this.btnData.offsetTopAlt - this.boxData.height - this.gap,
            startTop = this.btnData.offsetTop,
            startBottom = this.browserData.height - (startTop + this.boxData.height),
            centerTop = this.btnData.offsetTop - (this.boxData.height - this.btnData.height) / 2,
            centerBottom = this.browserData.height - (centerTop + this.boxData.height),
            endTop = this.btnData.offsetTopAlt - this.boxData.height,
            endBottom = this.browserData.height - this.btnData.offsetTopAlt,
            startLeft = this.btnData.offsetLeft,
            startRight = this.browserData.width - (startLeft + this.boxData.width),
            centerLeft = this.btnData.offsetLeft - (this.boxData.width - this.btnData.width) / 2,
            centerRight = this.browserData.width - (centerLeft + this.boxData.width),
            endLeft = this.btnData.offsetLeftAlt - this.boxData.width,
            endRight = this.browserData.width - this.btnData.offsetLeftAlt;
        return {
            left: left,
            right: right,
            top: top,
            bottom: bottom,
            startTop: startTop,
            startBottom: startBottom,
            centerTop: centerTop,
            centerBottom: centerBottom,
            endTop: endTop,
            endBottom: endBottom,
            startLeft: startLeft,
            startRight: startRight,
            centerLeft: centerLeft,
            centerRight: centerRight,
            endLeft: endLeft,
            endRight: endRight
        };
    }
    edgeResponse(pos, arr) {
        let placement;
        if (arr.length === 1) {
            if (arr[0].name === 'center') {
                placement = pos;
            } else {
                placement = `${pos}-${arr[0].name}`;
            }
        } else if (arr.length === 2) {
            if (pos === 'top' || pos === 'bottom') {
                if (this.btnData.offsetLeft === this.boxData.offsetLeft && this.boxData.offsetLeft < this.boxData.offsetRight) {
                    placement = `${pos}-start`;
                } else if (this.btnData.offsetLeftAlt === this.boxData.offsetLeftAlt && this.boxData.offsetLeft > this.boxData.offsetRight) {
                    placement = `${pos}-end`;
                } else {
                    placement = `${pos}-end`;
                }
            }
            if (pos === 'left' || pos === 'right') {
                if (this.btnData.offsetTop === this.boxData.offsetTop && this.boxData.offsetTop < this.boxData.offsetBottom) {
                    placement = `${pos}-start`;
                } else if (this.btnData.offsetTopAlt === this.boxData.offsetTopAlt && this.boxData.offsetTop > this.boxData.offsetBottom) {
                    placement = `${pos}-end`;
                } else {
                    placement = pos;
                }
            }
        } else if (arr.length === 3) {
            placement = this.options.placement;
        } else {
            placement = this.placement;
        }
        return placement;
    }
    fixPlacement() {
        let rectOffset = this.getRectOffset(),
            initPlacement = this.options.placement,
            placement = this.placement,
            xOffsetArr = [{
                name: 'start',
                left: rectOffset.startLeft,
                right: rectOffset.startRight
            }, {
                name: 'center',
                left: rectOffset.centerLeft,
                right: rectOffset.centerRight
            }, {
                name: 'end',
                left: rectOffset.endLeft,
                right: rectOffset.endRight
            }],
            availableX = xOffsetArr.filter(i => i.left >= 0 && i.right >= 0),
            yOffsetArr = [{
                name: 'start',
                top: rectOffset.startTop,
                bottom: rectOffset.startBottom
            }, {
                name: 'center',
                top: rectOffset.centerTop,
                bottom: rectOffset.centerBottom
            }, {
                name: 'end',
                top: rectOffset.endTop,
                bottom: rectOffset.endBottom
            }],
            availableY = yOffsetArr.filter(i => i.top >= 0 && i.bottom >= 0);
        if (initPlacement.includes('bottom')) {
            placement = this.edgeResponse('bottom', availableX);
            if (rectOffset.bottom < 0 && rectOffset.top > 0) {
                placement = placement.replace('bottom', 'top');
            }
        } else if (initPlacement.includes('top')) {
            placement = this.edgeResponse('top', availableX);
            if (rectOffset.top < 0 && rectOffset.bottom > 0) {
                placement = placement.replace('top', 'bottom');
            }
        } else if (initPlacement.includes('left')) {
            placement = this.edgeResponse('left', availableY);
            if (rectOffset.left < 0 && rectOffset.right > 0) {
                placement = initPlacement.replace('left', 'right');
            }
        } else if (initPlacement.includes('right')) {
            placement = this.edgeResponse('right', availableY);
            if (rectOffset.right < 0 && rectOffset.left > 0) {
                placement = initPlacement.replace('right', 'left');
            }
        }
        this.placement = placement;
        return placement;
    }
    unsettable(type) {
        let dom = type === 'btn' ? this.btnDom : this.boxDom;
        return (axIsVnode(dom) || getComputedStyle(dom).display === 'none');
    }
    resetPlacement() {
        if (this.unsettable()) {
            return false;
        }
        this.getRectData();
        this.fixPlacement();
        this.setPlacement(this.placement);
        this.options.onUpdated && this.options.onUpdated.call(this, this.placement);
        'updated' in this.handlers ? this.emit('updated', this.placement) : null;
    }
    update(callback) {
        this.resetPlacement();
        callback && callback.call(this, this.placement);
        return this;
    }
    change(elem, callback) {
        this.btnDom = axIdToDom(elem);
        this.resetPlacement();
        callback && callback.call(this, this.placement);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：气泡弹窗；使用方法：new axPopup('#id',{参数})
*/
class axPopup {
    constructor(elem, options) {
        this.options = axExtend({
            insName: '',
            title: '',
            titleBreak: false,
            placement: 'top',
            arrow: true,
            trigger: 'click',
            pageClose: true,
            size: 'md',
            duration: 0,
            in: 'fadeIn',
            out: 'fadeOut',
            multiple: false,
            offsetShow: true,
            rel: '',
            triggerRel: 'click',
            theme: '',
            stay: false,
            fixDistance: '2.4rem',
            name: '',
            width: '',
            height: '',
            padding: 'ax-padding',
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-opened',
            close: true,
            closePlace: 'inside',
            triggerShowOnly: false,
            triggerStrict: false,
            footerShow: true,
            footerType: 'line',
            footerBreak: false,
            note: '',
            ajaxType: 'post',
            zIndex: 0,
            preventScroll: false,
            onInit: '',
            onShow: '',
            onShown: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onUpdated: '',
            onUpdateContent: '',
            onUpdatePosition: '',
            onDestroy: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.form = null;
        this.button = axIdToDom(elem);
        this.state = 'hidden'
        this.bound = false;
        this.triggerShow = function (e) {
            if (_this.options.triggerStrict && ![..._this.rel, _this.button].includes(e.target)) {
                return false;
            }
            if (_this.options.trigger === 'click' || this.trigger === 'click') {
                if (_this.state === 'hidden') {
                    _this.show();
                    if (!_this.options.multiple) {
                        let items = axInstance.data.filter(i => i.type === 'popup' && i.instance !== _this && i.instance.isShow);
                        items.forEach(i => {
                            i.instance.hide();
                        });
                    }
                } else if (_this.state === 'shown') {
                    !_this.options.triggerShowOnly ? _this.hide() : null;
                }
            } else if (_this.options.trigger === 'input') {
                if (!_this.button.value) {
                    !_this.options.triggerShowOnly ? _this.hide() : null;
                } else {
                    _this.show();
                }
            }
        }
        this.toggleShow = (ev) => {
            let relOut = true;
            for (let i = 0; i < this.rel.length; i++) {
                if (!axIsOutside(ev, this.rel[i])) {
                    relOut = false;
                    break;
                }
            }
            if (axIsOutside(ev, this.targetDom) && axIsOutside(ev, this.button) && relOut && this.state === 'shown') {
                this.hide();
            };
        }
        this.init();
        return this;
    }
    async init() {
        axInstance.push(this, this.options.insName, 'popup');
        this.destroyed = false;
        this.rel = axAllToDoms(this.options.rel);
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType === 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
            this.form = this.content.querySelector('form');
        } else if (this.options.type === 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) === '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            let response;
            if (this.options.type === 'async' && this.options.url) {
                response = await axCreateContent(this.options, this);
            } else {
                response = axCreateContent(this.options, this);
            }
            if (typeof this.options.content === 'function') {
                this.content.innerHTML = this.options.content.call(this,response.content);
            } else {
                this.content.innerHTML = response.content;
            }
            this.form = this.content.querySelector('form');
        }
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.footer.innerHTML = axFooterBtns(this.options, this);
        this.createPopup();
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick =  (e)=> {
                if (this.options.confirm.type == 'submit') {
                    if (this.form && this.options.type == 'form') {
                        axValidRepeat(e, this.form, () => {
                            this.form.submit();
                        });
                        this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (this.options.confirm.type == 'async') {
                    if (this.form && this.options.type == 'form' && this.options.confirm.url) {
                        axValidRepeat(e, this.form, () => {
                            axAjaxSubmit(this.options.confirm.url, this.form, elem, {
                                type: this.options.ajaxType,
                                opened: (response) => {
                                    this.submitXhr = response.xhr;
                                },
                                success: (response) => {
                                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, response.content);
                                }
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of async is required!');
                        return false;
                    }
                } else if (this.options.confirm.type === 'prevent') {
                    axPreventDefault(e);
                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                } else {
                    this.hide();
                    this.options.confirm.callback && this.options.confirm.callback.call(this, elem, '');
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick =  ()=> {
                this.options.diy.callback && this.options.diy.callback.call(this, elem);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick = ()=> {
                this.hide();
                this.options.cancel.callback && this.options.cancel.callback.call(this, elem);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', () => {
                this.hide();
            }, false);
        });
        this.showEvent();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createTemplate() {
        return `
                            <div class="ax-popup" id="popup${new Date().getTime()}">
                                <div class="ax-popup-wrapper">
                                    <# if(this.close){ #><i close></i><# } #>
                                    <# if(this.title){ #><div class="ax-popup-header"><# this.title #></div><# } #>
                                    <# if(this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                                    <div class="ax-popup-body">
                                        <# if(typeof this.padding === 'string'){ #><div class="<# this.padding #>"> <# }else if(this.padding){ #><div class="ax-padding"> <# } #>
                                        <# this.media #>
                                        <div class="ax-popup-content"></div>
                                        <# if(this.padding){ #></div><# } #>
                                    </div>
                                    <div class="ax-popup-footer">
                                    </div>
                                </div>
                            </div>
                            `
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-popup-wrapper');
        this.content = this.targetDom.querySelector('.ax-popup-content');
        this.body = this.targetDom.querySelector('.ax-popup-body');
        this.targetDom.querySelector('.ax-popup-header') ? this.header = this.targetDom.querySelector('.ax-popup-header') : null;
        this.footer = this.targetDom.querySelector('.ax-popup-footer');
    }
    setAttribute() {
        this.options.size ? this.targetDom.setAttribute('size', this.options.size) : null;
        this.options.type ? this.targetDom.setAttribute('type', this.options.type) : null;
        this.options.footerType ? this.targetDom.setAttribute('footerType', this.options.footerType) : null;
        this.options.height ? this.content.style.height = this.options.height : null;
        this.options.theme ? this.targetDom.setAttribute('theme', this.options.theme) : null;
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
        if(this.options.close){
            this.targetDom.setAttribute('closePlace', this.options.closePlace);
        }
    }
    createPopup() {
        let placement;
        if (this.options.placement === 'center' || axIsMobi()) {
            placement = 'center';
        } else {
            placement = this.options.placement;
        }
        this.popupPosition = new axPopupPosition(this.button, this.targetDom, {
            placement: placement,
            arrowShow: this.options.arrow,
            gap: this.options.arrow ? '.8rem' : '.4rem',
            arrowOffset: this.options.fixDistance,
        });
        this.oldStyle = this.options.width ? `width:${this.options.width};` : '';
    }
    showEvent() {
        if (this.options.trigger === 'click' || this.options.trigger === 'input') {
            !this.bound ? this.button.addEventListener(this.options.trigger, this.triggerShow, false) : null;
            if (this.rel.length > 0) {
                this.rel.forEach(item => {
                    if (!this.bound) {
                        item.trigger = this.options.triggerRel || this.options.trigger;
                        item.addEventListener(this.options.triggerRel || this.options.trigger, this.triggerShow, false)
                    }
                });
            }
        } else if (this.options.trigger === 'hover') {
            this.hover = new axHover(this.button, {
                enter: () => {
                    this.show();
                },
                leave: () => {
                    !this.options.triggerShowOnly ? this.hide() : null;
                },
                hold: this.targetDom,
            });
        } else if (this.options.trigger === 'sticky') {
            this.show();
        }
        if (this.options.pageClose && !this.options.multiple) {
            !this.bound ? document.addEventListener('click', this.toggleShow, false) : null;
        }
        this.bound = true;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = axClone(this.options),
            after = axExtend(this.options, setting),
            isUpdated = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            this.targetDom.remove();
            this.popupPosition = '';
            if (this.state === 'shown') {
                this.init().show();
            } else if (this.state === 'hidden') {
                this.init();
            }
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, after);
        this.options.onUpdated && this.options.onUpdated.call(this, isUpdated, before, after);
        'updated' in this.handlers ? this.emit('updated', isUpdated, before, after) : null;
        return this;
    }
    updateContent(data, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            isUpdated = false;
        if (axType(data) === 'String') {
            if (axStrType(data)) {
                this.content.innerHTML = axIdToDom(data) ? axIdToDom(data).innerHTML : '';
            } else {
                this.content.innerHTML = data;
            }
        } else if (axType(data).includes('HTML')) {
            this.content.innerHTML = '';
            this.content.appendChild(data);
        } else {
            this.content.innerHTML = `No data to update!`;
        }
        if (this.content.innerHTML == before) {
            isUpdated = false;
        } else {
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, this.content.innerHTML);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, isUpdated, before, this.content.innerHTML);
        'updateContent' in this.handlers ? this.emit('updateContent', isUpdated, before, this.content.innerHTML) : null;
        return this;
    }
    updatePosition(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let newButton = axIdToDom(obj);
        this.popupPosition.change(newButton, (placement) => {
            this.options.onUpdatePosition && this.options.onUpdatePosition.call(this, placement);
            'updatePosition' in this.handlers ? this.emit('updatePosition', placement) : null;
        });
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        if (this.destroyed || this.state !== 'hidden') {
            return this;
        }
        this.state = 'ing';
        if (!getComputedStyle(this.targetDom).display) {
            document.body.appendChild(this.targetDom);
        }
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.wrapperHeight = axArrHeight(this.wrapper).height;
        if (this.options.duration) {
            this.duration = this.options.duration;
        } else if (this.wrapperHeight) {
            this.duration = Math.floor(this.wrapperHeight / 3 + 250);
        } else {
            this.duration = parseFloat(axStyle(this.targetDom).animationDuration) * 1000
        }
        this.popupPosition.update();
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        if (this.options.in === 'slideDown') {
            axHeightDown(this.wrapper, { height: this.wrapperHeight }, '', this.duration)
        } else {
            this.options.duration ? this.targetDom.style.animationDuration = `${this.options.duration}ms` : null;
            this.options.in ? this.targetDom.style.animationName = this.options.in : null;
        }
        this.targetDom.style.cssText += `;${this.oldStyle}`;
        this.hover ? this.hover.isActive = true : null;
        setTimeout(() => {
            this.state = 'shown'
            this.options.onShown && this.options.onShown.call(this);
            'shown' in this.handlers ? this.emit('shown', '') : null;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed || this.state !== 'shown') {
            return this;
        }
        this.state = 'ing';
        if (!this.options.stay) {
            this.options.onHide && this.options.onHide.call(this);
            'hide' in this.handlers ? this.emit('hide', '') : null;
            this.button ? this.button.classList.remove(this.options.btnClass) : null;
            if (this.options.out === 'slideUp') {
                axHeightUp(this.wrapper, { height: this.wrapperHeight }, '', this.duration)
            } else {
                this.options.out ? this.targetDom.style.animationName = this.options.out : null;
            }
            this.targetDom.style.cssText += `;${this.oldStyle}`;
            this.targetDom.querySelectorAll('video,audio').forEach(elem => {
                elem.pause();
            });
            this.hover ? this.hover.isActive = false : null;
            setTimeout(() => {
                this.state = 'hidden';
                this.targetDom.classList.remove('ax-show');
                this.targetDom.remove();
                this.options.onHidden && this.options.onHidden.call(this);
                'hidden' in this.handlers ? this.emit('hidden', '') : null;
                this.options.out === 'slideUp' ? this.wrapper.style.height = 'auto' : null;
            }, this.duration);
            callback && callback.call(this);
        }
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.popupPosition = null;
        this.hover = null;
        this.button.removeEventListener(this.options.trigger, this.triggerShow);
        this.rel.forEach(i => {
            i.removeEventListener(this.options.triggerRel || this.options.trigger, this.triggerShow);
        });
        this.toggleShow ? document.removeEventListener('click', this.toggleShow) : null;
        this.bound = false;
        this.contentXhr ? this.contentXhr.abort() : null;
        this.submitXhr ? this.submitXhr.abort() : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axPopup(elem, '');
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axPopup]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axPopup]');
    eachInstance(arrInstance);
})(); */
/*!
 * 插件：小窗文字提示；使用方法：axTooltip('#id',{参数})
 */
class axTooltip {
    constructor(elem, options) {
        this.button = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            placement: 'top', 
            arrow: true, 
            trigger: 'hover', 
            size: '', 
            multiple: true, 
            theme: 'dark', 
            content: '', 
        }, options, this.button, this.constructor.name);
        this.init();
    }
    init() {
         axInstance.push(this, this.options.insName, 'tooltip');
        let btnAttr = this.button.getAttribute('axTooltip');
        if (!this.options.content && btnAttr) {
            !btnAttr.includes(':') ? this.options.content = btnAttr : null;
        }
        let popOptions = Object.assign({
            type: 'html',
            close: false,
            footerShow: false,
            padding: false,
        }, this.options);
        this.popup = new axPopup(this.button, popOptions);
        this.content = this.popup.content;
        this.setAttribute();
    }
    setAttribute() {
        this.popup.targetDom.classList.add('ax-tooltip');
        if (this.options.theme) {
            this.popup.targetDom.setAttribute('theme', this.options.theme)
        }
    }
    updateContent(str, callback) {
        this.content.innerHTML = str;
        callback && callback.call(this, update, before, this.content.innerHTML, this.options.content);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axTooltip]').forEach(element => {
        new axTooltip(element);
    });
})(); */
/*!
 * 插件：文件上传；使用方法：new axUpload('#id',{参数})
 */
class axUpload {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            insName: '',
            type: 'beautify', 
            accept: 'jpg,jpeg,gif,png,svg,doc,docx,xls,xlsx,txt,mp4,mp3,pdf', 
            mime: '',
            multiple: true, 
            name: '', 
            separator: ',',
            columns: 0,
            min: 0, 
            max: 0, 
            size: 0, 
            url: '', 
            fileType: [], 
            action: 'auto', 
            tipsShow: true, 
            summaryShow: false,
            cloud: '',
            pastable: {
                before: '请点击使用ctrl+v粘贴上传',
                ing: '使用ctrl+v粘贴进来',
                after: 'ctrl+v粘贴上传成功',
            },
            icons: {
                file: 'ax-iconfont ax-icon-file-text',
                attach: 'ax-iconfont ax-icon-attach',
                image: 'ax-iconfont ax-icon-image',
                video: 'ax-iconfont ax-icon-video',
                audio: 'ax-iconfont ax-icon-music'
            },
            beautify: {
                placeholder: '请选择文件...', 
                text: '选择文件', 
                className: 'ax-file',
                display: '',
                callback: '',
            },
            message: {
                passed: '通过文件校验!',
                exceeded: '超过了文件数量限制!',
                tooLarge: '文件体积太大了!',
                errorSuffix: '不支持该文件格式!',
                success: '上传成功!',
                failed: '提交地址可能错误!',
            },
            chooseBtn: {
                icon: '<i class="ax-iconfont ax-icon-plus"></i>',
                text: '选择文件',
                className: '',
                props: {},
                show: true,
            },
            uploadBtn: {
                icon: '<i class="ax-iconfont ax-icon-upload"></i>',
                text: '立即上传',
                className: '',
                props: {},
                show: false,
            },
            clearBtn: {
                icon: '<i class="ax-iconfont ax-icon-trash"></i>',
                text: '删除全部',
                className: '',
                props: {},
                show: false,
            },
            cubeBtn: {
                icon: '<i class="ax-iconfont ax-icon-plus-t"></i>',
                text: '',
                className: '',
                props: {},
                show: true,
            },
            boxBtn: {
                icon: '<i class="ax-iconfont ax-icon-addpic"></i>',
                text: '点击或拖拽上传',
                className: '',
                props: {},
                show: true,
            },
            onRendered: '',
            onPasted: '',
            onDropped: '',
            onUploading: '', 
            onUploaded: '', 
            onAllUploaded: '', 
            onError: '', 
            onCompleted: '', 
            onAllCompleted: '', 
            onChanged: '', 
            onRemove: '', 
            onClear: '', 
            onBeforeRemove: '', 
            onBeforeClear: '', 
            onBeforeUpload: '',
        }, options, this.targetDom, this.constructor.name);
        this.name = this.targetDom && this.targetDom.nodeName == 'INPUT' ? this.targetDom.getAttribute('name') : this.options.name;
        this.handlers = {};
        this.sizeLimit = this.options.size * 1024 * 1024; 
        let dftTypes = [{
            name: 'image',
            icon: this.options.icons.image,
            suffix: ['png', 'jpg', 'jpeg', 'bmp', 'gif', 'webp', 'svg', 'tiff']
        }, {
            name: 'video',
            icon: this.options.icons.video,
            suffix: ['mp4', 'mpeg', 'avi', 'wmv', 'mov', 'm4v', 'flv', 'rmvb', '3gp']
        }, {
            name: 'audio',
            icon: this.options.icons.audio,
            suffix: ['mp3', 'wma', 'm4a', 'ogg']
        }];
        if (!axIsEmpty(this.options.fileType)) {
            this.fileTypes = [...this.options.fileType, ...dftTypes];
        } else {
            this.fileTypes = [...dftTypes];
        }
        this.files = [];
        this.details = [];
        this.history = [];
        this.value = [];
        this.inputValue = '';
        this.summary = axAddElem('div', { summary: '' });
        this.init();
    }
    init() {
         axInstance.push(this, this.options.insName, 'upload');
        this.createTips();
        this.createButton();
        this.createSkeleton();
        this.setAttribute();
        if (this.options.type == 'beautify') {
            return false;
        }
        this.chooseBtn.onclick = () => {
            this.inputFile.click();
        }
        this.readyUpload();
        return this;
    }
    createTips() {
        this.tipsText = '';
        this.options.size ? this.tipsText += `要求大小不超过${this.options.size}MB,` : null;
        this.options.min ? this.tipsText += `至少上传${this.options.min}个文件,` : null;
        this.options.max ? this.tipsText += `最多上传${this.options.max}个文件` : null;
        this.tips = axAddElem('div', { tips: '' }, this.tipsText);
    }
    createButton() {
        if (this.options.type == 'gallery') {
            this.chooseBtn = axAddElem('div', Object.assign({ choose: '' }, this.options.boxBtn.props), this.options.boxBtn.icon + '<div text>' + this.options.boxBtn.text + '</div>');
        } else if (this.options.type == 'picture') {
            this.chooseBtn = axAddElem('li', Object.assign(this.options.cubeBtn.className ? { class: this.options.cubeBtn.className } : { choose: '' }, this.options.cubeBtn.props), this.options.cubeBtn.icon + this.options.cubeBtn.text);
        } else {
            this.chooseBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.chooseBtn.className ? 'ax-btn ' + this.options.chooseBtn.className : 'ax-btn', choose: '' }, this.options.chooseBtn.props), this.options.chooseBtn.icon + this.options.chooseBtn.text);
        }
    }
    createSkeleton() {
        if (this.targetDom) {
            if (this.targetDom.nodeName == 'INPUT' && this.targetDom.type == 'file') {
                this.inputFile = this.targetDom;
                this.inputFile.name ? this.inputFile.setAttribute('name', this.name) : null;
                this.parent = axAddElem('div', { class: 'ax-upload' });
                this.inputFile.insertAdjacentElement('beforeBegin', this.parent);
            } else if (this.targetDom.nodeName == 'INPUT' && (this.targetDom.type == 'hidden' || this.targetDom.type == 'text')) {
                this.inputText = this.targetDom;
                this.inputText.name ? this.inputText.setAttribute('name', this.name) : null;
                this.inputText.setAttribute('readonly', '');
                this.inputFile = axAddElem('input', { type: 'file' });
                this.parent = axAddElem('div', { class: 'ax-upload' });
                this.inputText.insertAdjacentElement('beforeBegin', this.parent);
                this.options.multiple ? this.inputFile.setAttribute('multiple', '') : null;
            } else {
                this.parent = this.targetDom;
                this.inputFile = axAddElem('input', { type: 'file' });
                this.inputText = axAddElem('input', { type: 'hidden', readonly: '', name: this.name });
                this.options.multiple ? this.inputFile.setAttribute('multiple', '') : null;
            }
        } else {
            this.parent = axAddElem('div', { class: 'ax-upload' });
            this.inputFile = axAddElem('input', { type: 'file' });
            this.options.multiple ? this.inputFile.setAttribute('multiple', '') : null;
            this.inputText = axAddElem('input', { type: 'hidden', readonly: '', name: this.options.name });
        }
        this.options.mime ? this.inputFile.setAttribute('accept', this.options.mime) : null;
        this.parent.appendChild(this.inputFile);
        if (this.options.type == 'beautify') {
            this.parent.appendChild(this.inputFile);
            this.parent.dataset.placeholder = this.options.beautify.placeholder;
            this.parent.dataset.text = this.options.beautify.text;
            this.parent.classList.add(this.options.beautify.className);
            this.fileChange(this.parent, this.inputFile);
        } else {
            this.list = axAddElem('ul');
            this.parent.appendChild(this.list);
            this.parent.appendChild(this.inputText);
            let info = axAddElem('div', { info: '' }),
                footer = axAddElem('div', { footer: '' }, info);
            if (this.options.tipsShow && this.tipsText) {
                info.appendChild(this.tips);
                this.parent.setAttribute('withtips', '');
            }
            if (this.options.summaryShow) {
                info.appendChild(this.summary);
                this.summary.innerHTML = this.getSummary();
                this.parent.setAttribute('withtips', '');
            }
            if (this.options.type == 'gallery') {
                this.createCtrlv();
                this.parent.appendChild(footer);
                this.parent.insertAdjacentElement('afterBegin', this.chooseBtn);
                this.list.classList.add('ax-grid', 'ax-space-xs');
                this.options.columns ? this.list.classList.add('ax-grid-' + this.options.columns) : null;
                if (this.options.clearBtn.show) {
                    this.clearBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.clearBtn.className ? 'ax-btn ' + this.options.clearBtn.className : 'ax-btn', clear: '' }, this.options.clearBtn.props), this.options.clearBtn.icon + this.options.clearBtn.text);
                    footer.appendChild(this.clearBtn);
                    this.parent.setAttribute('withtips', '');
                }
                if (this.options.uploadBtn.show) {
                    this.uploadBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.uploadBtn.className ? 'ax-btn ' + this.options.uploadBtn.className : 'ax-btn', upload: '' }, this.options.uploadBtn.props), this.options.uploadBtn.icon + this.options.uploadBtn.text);
                    footer.appendChild(this.uploadBtn);
                    this.parent.setAttribute('withtips', '');
                }
            } else if (this.options.type == 'picture') {
                this.parent.appendChild(footer);
                this.list.appendChild(this.chooseBtn);
                if (this.options.clearBtn.show) {
                    this.clearBtn = axAddElem('li', Object.assign({ class: this.options.clearBtn.className, clear: '' }, this.options.clearBtn.props), this.options.clearBtn.icon + this.options.clearBtn.text);
                    this.chooseBtn.insertAdjacentElement('afterEnd', this.clearBtn);
                }
                if (this.options.uploadBtn.show) {
                    this.uploadBtn = axAddElem('li', Object.assign({ class: this.options.uploadBtn.className, upload: '' }, this.options.uploadBtn.props), this.options.uploadBtn.icon + this.options.uploadBtn.text);
                    this.chooseBtn.insertAdjacentElement('afterEnd', this.uploadBtn);
                }
            } else {
                let header = axAddElem('div', { header: '' });
                this.list.insertAdjacentElement('beforeBegin', footer);
                this.parent.insertAdjacentElement('afterBegin', header);
                header.appendChild(this.chooseBtn);
                if (this.options.uploadBtn.show) {
                    this.uploadBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.uploadBtn.className ? 'ax-btn ' + this.options.uploadBtn.className : 'ax-btn', upload: '' }, this.options.uploadBtn.props), this.options.uploadBtn.icon + this.options.uploadBtn.text);
                    header.appendChild(this.uploadBtn);
                }
                if (this.options.clearBtn.show) {
                    this.clearBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.clearBtn.className ? 'ax-btn ' + this.options.clearBtn.className : 'ax-btn', clear: '' }, this.options.clearBtn.props), this.options.clearBtn.icon + this.options.clearBtn.text);
                    header.appendChild(this.clearBtn);
                }
            }
        }
    }
    createCtrlv() {
        if (this.options.pastable) {
            this.ctrlv = axAddElem('i', { ctrlv: '' }, this.options.pastable.before);
            this.parent.appendChild(this.ctrlv);
            this.parent.onclick = () => {
                this.ctrlv.innerHTML = this.options.pastable.ing;
            }
            this.parent.onmouseleave = () => {
                this.ctrlv.innerHTML = this.options.pastable.before;
            }
        }
    }
    sizeStr(data) {
        let str = ''
        if (data / 1024 >= 1024) {
            str = '<i>' + (data / (1024 * 1024)).toFixed(2) + '</i>MB'
        } else if (data / 1024 >= 1) {
            str = '<i>' + (data / 1024).toFixed(2) + '</i>KB'
        } else {
            str = '<i>' + data + '</i>B'
        }
        return str;
    }
    getSummary() {
        let originalSize = 0,
            realSize,
            totalNum = this.details.length,
            uploadedItems = this.details.filter(i => i.progress == 'uploaded'),
            okNum = uploadedItems.length;
        uploadedItems.forEach(i => {
            originalSize += i.file.size;
        });
        realSize = this.sizeStr(originalSize);
        return `提交了<i>${totalNum}</i>个文件,成功上传了<i>${okNum}</i>个,共${realSize}`;
    }
    createItem(file, state) {
        let tpl = '';
        if (this.options.type == 'gallery') {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <div file>
                    <div overlay>
                        <i view class="ax-iconfont ax-icon-zoomin"></i>
                        <a down href="###" class="ax-iconfont ax-icon-download"></a>
                        <i remove class="ax-iconfont ax-icon-trash"></i>
                    </div>
                    <div track><div bar></div></div>
                    <i percent></i>
                    <div message>${(state && !state.valid) ? state.message : ''}</div>
                </div>
                <div info>
                    <div title>${file.name}</div>
                    <div size>${this.sizeStr(file.size)}</div>
                    <div url></div>
                </div>
            </li>
            `;
        } else if (this.options.type == 'picture') {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <div file></div>
                <div overlay>
                    <i view class="ax-iconfont ax-icon-zoomin"></i>
                    <a down href="###" class="ax-iconfont ax-icon-download"></a>
                    <i remove class="ax-iconfont ax-icon-trash"></i>
                </div>
                <div track><div bar></div></div>
                <i percent></i>
                <div message>${(state && !state.valid) ? state.message : ''}</div>
            </li>
            `;
        } else if (this.options.type == 'info') {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <a href="###" file></a>
                <div info>
                    <a href="###" title>${file.name}</a>
                </div>
                <div track><div bar></div></div>
                <i percent></i>
                <i message>${(state && !state.valid) ? state.message : ''}</i>
                <i remove class="ax-iconfont ax-icon-trash"></i>
            </li>
            `;
        } else {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <i icon class="${this.options.icons.attach}"></i>
                <div info>
                    <a href="###" title>${file.name}</a>
                </div>
                <div track><div bar></div></div>
                <i percent></i>
                <i message>${(state && !state.valid) ? state.message : ''}</i>
                <i remove class="ax-iconfont ax-icon-trash"></i>
            </li>
            `;
        }
        let li = axStrToDom(tpl),
            fileDom = li.querySelector('[file]');
        fileDom ? this.fillHeader(file, fileDom) : null;
        if (this.options.type == 'picture') {
            this.chooseBtn.insertAdjacentElement('beforeBegin', li);
        } else {
            this.list.appendChild(li);
        }
        return li;
    }
    fileChange(item, file) {
        let _this = this;
        let text = item.getAttribute('data-text'),
            placeholder = item.getAttribute('data-placeholder');
        if (!text) {
            item.classList.add('ax-simple');
        }
        if (file.classList.contains("ax-xs")) {
            item.classList.add('ax-xs');
        } else if (file.classList.contains('ax-sm')) {
            item.classList.add('ax-sm');
        } else if (file.classList.contains('ax-lg')) {
            item.classList.add('ax-lg');
        }
        let imgWrapper;
        if (this.options.beautify.display) {
            imgWrapper = axIdToDom(this.options.beautify.display);
        }
        file.addEventListener('change', function () {
            item.classList.add('ax-active');
            item.setAttribute('data-placeholder', this.value.replace(/.*(\/|\\)/, ''));
            if (!this.value) {
                item.setAttribute('data-placeholder', placeholder);
                item.classList.remove('ax-active');
            }
            if ([...this.files].length > 0) {
                [...this.files].forEach(i => {
                    _this.value.push({ name: i.name, size: i.size, time: i.lastModified, url: '' })
                });
                if (imgWrapper) {
                    imgWrapper.innerHTML = '';
                    [...this.files].forEach(i => {
                        if (i.type.startsWith('image')) {
                            _this.readFile(i, (data) => {
                                imgWrapper.appendChild(axAddElem('img', { src: data }));
                            });
                        }
                    });
                }
            }
            _this.options.beautify.callback && _this.options.beautify.callback.call(_this, this.files);
            _this.options.onChange && _this.options.onChange.call(_this, this.files);
            'changed' in _this.handlers ? _this.emit('changed', this.files) : null;
            _this.options.onChanged && _this.options.onChanged.call(_this, this.files);
        }, false);
        file.onfocus = () => {
            item.classList.add("ax-focus");
        };
        file.onblur = () => {
            item.classList.remove("ax-focus");
        };
    }
    setAttribute() {
        this.options.type ? this.parent.setAttribute('type', this.options.type) : null;
        this.options.pastable ? this.parent.setAttribute('pastable', '') : null;
        this.parent.setAttribute('state', 'ready');
    }
    readyUpload() {
        this.inputFile.addEventListener('change', () => {
            let files = [...this.inputFile.files];
            this.renderList(files);
            this.inputFile.value = '';
            'changed' in this.handlers ? this.emit('changed', files) : null;
            this.options.changed && this.options.changed.call(this, files);
        }, false);
        if (this.options.pastable) {
            this.parent.addEventListener('paste', (e) => {
                let data = e.clipboardData ? e.clipboardData : window.clipboardData;
                if (data) {
                    let item = data.items[0];
                    if (item && item.kind === 'file' && item.type.includes('image')) {
                        this.renderList([item.getAsFile()]);
                        this.ctrlv ? this.ctrlv.innerHTML = this.options.pastable.after : null;
                    }
                    'pasted' in this.handlers ? this.emit('pasted', item) : null;
                    this.options.onPasted && this.options.onPasted.call(this, item);
                }
            }, false);
        }
        this.parent.addEventListener("dragleave", (e) => {
            e.preventDefault();
            this.parent.removeAttribute('drag');
        });
        this.parent.addEventListener("dragover", (e) => {
            e.preventDefault();
        });
        this.parent.addEventListener("dragenter", (e) => {
            e.preventDefault();
            this.parent.setAttribute('drag', '');
        });
        this.parent.addEventListener("drop", (e) => {
            e.preventDefault();
            this.parent.removeAttribute('drag');
            let items = e.dataTransfer.items;
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (item.kind === "file") {
                    let entry = item.webkitGetAsEntry();
                    this.getEntries(entry);
                }
            }
            'dropped' in this.handlers ? this.emit('dropped', items) : null;
            this.options.onDropped && this.options.onDropped.call(this, items);
        }, false);
        if (this.clearBtn) {
            this.clearBtn.onclick = () => {
                if (this.details.length == 0) {
                    return false;
                }
                if (this.options.onBeforeClear) {
                    this.options.onBeforeClear.call(this);
                } else {
                    this.clear.call(this);
                }
            }
        }
    }
    renderItem(file) {
        let elem,
            fileValid = this.fileValid(file),
            obj = { file: file, state: fileValid },
            render = (obj, elem) => {
                obj.dom = elem;
                obj.progress = 'rendered';
                elem.setAttribute('progress', 'rendered');
            };
        if (fileValid.valid) {
            this.files.push(file);
            elem = this.createItem(file);
        } else {
            elem = this.createItem(file, fileValid);
        }
        render(obj, elem);
        this.details.push(obj);
        let removeDom = elem.querySelector('[remove]');
        if (removeDom) {
            removeDom.onclick = () => {
                if (this.options.onBeforeRemove) {
                    this.options.onBeforeRemove.call(this, obj);
                } else {
                    this.remove(obj.file);
                }
            }
        }
        'rendered' in this.handlers ? this.emit('rendered', obj) : null;
        this.options.onRendered && this.options.onRendered.call(this, obj);
        return elem;
    }
    getEntries(entry) {
        if (entry.isFile) {
            entry.file(i => this.renderList([i]));
        } else {
            let reader = entry.createReader();
            reader.readEntries(k => {
                k.forEach(i => this.getEntries(i));
            }
            );
        }
    }
    renderList(files, callback) {
        if (files.length == 0) {
            return false;
        }
        for (let x = 0, len = files.length; x < len; x++) {
            let item = files[x];
            if (this.history.length == 0) {
                this.history.push(item);
                this.renderItem(item);
            } else {
                if (this.history.every(i => (i.name != item.name && i.size != item.size))) {
                    this.history.push(item);
                    this.renderItem(item);
                } else {
                    continue;
                }
            }
        }
        if (this.options.action == 'auto') {
            this.upload();
        } else {
            if (this.uploadBtn) {
                this.uploadBtn.onclick = () => {
                    this.upload();
                }
            }
        }
        this.parent.setAttribute('state', 'processing');
        callback && callback.call(this);
    }
    upload(callback) {
        if (!this.options.url) {
            console.error('The url is required!');
            return false;
        }
        let globalValid = this.globalValid();
        if (!globalValid.valid) {
            new axMessage({
                content: globalValid.message,
                result: 'error',
            }).show();
            return false;
        }
        let uploadingFiles = this.getUploadingFiles();
        if (this.options.onBeforeUpload && !this.options.onBeforeUpload.call(this, uploadingFiles)) {
            return false;
        }
        uploadingFiles.forEach(i => {
            this.uploadFile(i);
        });
        /* for (let i = 0, len = this.details.length; i < len; i++) {
            let item = this.details[i];
            if (!item.state.valid) {
                continue;
            }
            item.progress != 'uploaded' ? this.uploadFile(item) : null;
        } */
        'uploading' in this.handlers ? this.emit('uploading', '') : null;
        this.options.onUploading && this.options.onUploading.call(this);
        callback && callback.call(this);
    }
    getUploadingFiles() {
        return this.details.filter(i => i.state.valid && i.progress != 'uploaded');
    }
    activeOperate(file, dom, url, name) {
        dom.setAttribute('valid', 'success');
        dom.setAttribute('progress', 'uploaded');
        if (!dom.querySelector('[state]')) {
            dom.querySelector('[percent]').insertAdjacentHTML('afterend', `<i state class="ax-iconfont ax-icon-check"></i>`);
        }
        if (this.options.cloud) {
            url = this.options.cloud.server + url;
        }
        let downBtn = dom.querySelector('[down]'),
            viewBtn = dom.querySelector('[view]');
        if (downBtn) {
            if (this.options.cloud) {
                downBtn.onclick = () => {
                    this.downloadFile(url, file.name);
                }
            } else {
                downBtn.setAttribute('download', '');
                downBtn.setAttribute('href', url);
            }
        }
        if (viewBtn) {
            let mediaSrc = { media: url, caption: name, type: '' };
            if (this.h5Type(file) == 'image') {
                mediaSrc.type = 'image';
            } else if (this.h5Type(file) == 'video') {
                mediaSrc.type = 'video';
            } else if (this.h5Type(file) == 'audio') {
                mediaSrc.type = 'audio';
            }
            if (mediaSrc.type) {
                viewBtn.onclick = function () {
                    new axLightbox({
                        src: mediaSrc,
                    }).init().show();
                }
            }
        }
        if (this.options.type == 'text' || this.options.type == 'info') {
            let titleDom = dom.querySelector('[title]'),
                fileDom = dom.querySelector('[file]');
            titleDom.setAttribute('href', url);
            titleDom.setAttribute('target', '_blank');
            if (fileDom) {
                fileDom.setAttribute('href', url);
                fileDom.setAttribute('target', '_blank');
            }
        }
    }
    downloadFile(url, fileName) {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = 'blob';
        xhr.onload = function () {
            let url = window.URL.createObjectURL(xhr.response),
                dom = axAddElem('a');
            dom.href = url;
            dom.download = fileName;
            dom.click();
        }
        xhr.send();
    }
    uploadFile(obj) {
        let data = new FormData(),
            file = obj.file,
            dom = obj.dom,
            valid = obj.state.valid,
            fixDom = (flag, url, message, dom) => {
                if (flag) {
                    this.activeOperate(file, dom, url, file.name);
                } else {
                    dom.setAttribute('valid', 'error');
                    dom.querySelector('[message]').innerText = message;
                }
                this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
            }
        if (!valid || obj.progress == 'uploaded') {
            return false;
        }
        obj.progress = 'uploading';
        dom.setAttribute('progress', 'uploading');
        if (this.options.cloud) {
            data.append(this.options.cloud.field ? this.options.cloud.field : 'file', file);
            for (let k in this.options.cloud.append) {
                data.append(k, this.options.cloud.append[k]);
            }
        } else {
            data.append(this.name ? this.name : 'file', file);
        }
        axAjax({
            url: this.options.url,
            data: data,
            uploading: (response) => {
                dom.querySelector('[percent]').innerText = response.result;
                dom.querySelector('[bar]').style.width = response.result;
                if (response.percent >= 100) {
                    dom.setAttribute('completed', '');
                    obj.completed = true;
                    this.handlers.hasOwnProperty('completed') ? this.emit('completed', obj) : null;
                    this.options.onCompleted && this.options.onCompleted.call(this, obj);
                    if (this.details.every(i => i.state.valid && i.completed)) {
                        this.handlers.hasOwnProperty('allCompleted') ? this.emit('allCompleted', '') : null;
                        this.options.onAllCompleted && this.options.onAllCompleted.call(this);
                    }
                }
            },
            success: (response) => {
                let msg = '', url = '', size = 0, time = 0, valid,
                    getKeys = (obj, str) => {
                        if (!str) {
                            return '';
                        }
                        if (!str.includes('.')) {
                            return obj[str];
                        }
                        let arr = str.split("."),
                            value;
                        if (arr.length == 1) {
                            value = obj[arr[0]]
                        } else if (arr.length == 2) {
                            value = obj[arr[0]][arr[1]]
                        } else {
                            value = '';
                        }
                        return value;
                    };
                if (this.options.cloud) {
                    let keys = this.options.cloud.keys;
                    url = getKeys(response.content, keys.url);
                    size = getKeys(response.content, keys.size);
                    time = getKeys(response.content, keys.time);
                    msg = getKeys(response.content, keys.message);
                    valid = this.options.cloud.code == response.content.code ? true : false;
                } else {
                    url = response.content.url;
                    size = file.size;
                    time = response.content.time;
                    msg = response.content.message;
                    valid = response.content.valid === true ? true : false;
                }
                obj.state.valid = valid;
                obj.state.time = time;
                obj.state.url = url;
                obj.state.message = msg;
                if (!valid) {
                    this.files = this.files.filter(i => i != file);
                    this.handlers.hasOwnProperty('error') ? this.emit('error', obj, response.content) : null;
                    this.options.onError && this.options.onError.call(this, obj, response.content);
                } else {
                    this.value.push({ name: file.name, url: url, size: size, time: time });
                    this.valueToValue(this.value);
                    obj.progress = 'uploaded';
                    this.handlers.hasOwnProperty('uploaded') ? this.emit('uploaded', obj, response.content) : null;
                    this.options.onUploaded && this.options.onUploaded.call(this, obj, response.content);
                    if (this.details.every(i => i.state.valid && i.progress == 'uploaded')) {
                        this.handlers.hasOwnProperty('allUploaded') ? this.emit('allUploaded', response.content) : null;
                        this.options.onAllUploaded && this.options.onAllUploaded.call(this, obj, response.content);
                    }
                }
                fixDom(valid, url, msg, dom);
            },
            error: () => {
                fixDom(false, '', this.options.message.failed, dom);
            }
        });
    }
    valueToValue(value) {
        let arr = [];
        value.forEach(i => {
            arr.push(i.url);
        });
        this.inputValue = arr.join(this.options.separator);
        if (this.inputText) {
            this.inputText.value = this.inputValue;
            this.inputText.onchange ? this.inputText.onchange() : null;
        }
    }
    getSuffix(file) {
        return file.name.substring(file.name.lastIndexOf('.') + 1);
    }
    h5Type(file) {
        let mediaType;
        if (file.type.startsWith('image')) {
            mediaType = 'image';
        } else if (['mp4', 'ogg', 'webm'].includes(this.getSuffix(file))) {
            mediaType = 'video';
        } else if (['mp3', 'ogg', 'wav'].includes(this.getSuffix(file))) {
            mediaType = 'audio';
        }
        return mediaType;
    }
    readFile(file, callback) {
        let reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (e) => {
            callback(e.target.result);
        }
    };
    fillHeader(file, dom) {
        let elem,
            type = this.h5Type(file),
            iconType = this.fileTypes.filter(i => i.suffix.includes(this.getSuffix(file)))[0];
        if (type == 'image') {
            this.readFile(file, (data) => {
                elem = axAddElem('img', { src: data });
                dom.appendChild(elem);
            });
        } else if (type == 'video') {
            this.readFile(file, (data) => {
                elem = axAddElem('video', { src: data, controls: '' });
                dom.appendChild(elem);
            });
        } else if (type == 'audio') {
            this.readFile(file, (data) => {
                elem = axAddElem('audio', { src: data, controls: '' });
                dom.appendChild(elem);
            });
        } else {
            elem = axAddElem('i', { class: iconType ? iconType.icon : this.options.icons.file, icon: '' });
            dom.appendChild(elem);
        }
    }
    fileValid(file) {
        let msg = this.options.message.passed,
            pass = true,
            suffix = this.getSuffix(file);
        if (this.history.length > this.options.max && this.options.max) {
            msg = this.options.message.exceeded;
            pass = false;
        } else if (this.history.length < this.options.min && this.options.min) {
            msg = this.options.message.exceeded;
            pass = false;
        } else if (this.sizeLimit && (file.size > this.sizeLimit)) {
            msg = this.options.message.tooLarge;
            pass = false;
        } else if (!this.options.accept.includes(suffix)) {
            msg = this.options.message.errorSuffix;
            pass = false;
        }
        return { valid: pass, message: msg }
    }
    globalValid() {
        let msg = this.options.message.passed,
            pass = true;
        if (this.history.length < this.options.min) {
            msg = `请至少上传${this.options.min}个文件!`;
            pass = false;
        } else if (this.history.length < this.options.min) {
            msg = `最多只能上传${this.options.max}个文件!`;
            pass = false;
        }
        return { valid: pass, message: msg }
    }
    remove(file, callback) {
        this.history = this.history.filter(i => i != file);
        this.files = this.files.filter(i => i != file);
        let item = this.details.find(i => i.file == file),
            name = file.name,
            size = file.size,
            url = item.state.url,
            time = item.state.time;
        item.dom.remove();
        this.details = this.details.filter(i => i.file != file);
        if (this.details.length == 0) {
            this.parent.setAttribute('state', 'ready');
        }
        this.value = this.value.filter(i => i.time != time);
        this.valueToValue(this.value);
        this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
        this.options.onRemove ? this.options.onRemove.call(this, url, name, size) : null;
        'remove' in this.handlers ? this.emit('remove', url, name, size) : null;
        callback && callback.call(this, url, name, size);
    }
    clear(callback) {
        this.details.forEach(i => {
            i.dom.remove();
        });
        this.details = [];
        this.history = [];
        this.files = [];
        this.value = [];
        this.valueToValue(this.value);
        this.parent.setAttribute('state', 'ready');
        this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
        this.options.onClear ? this.options.onClear.call(this) : null;
        'clear' in this.handlers ? this.emit('clear', '') : null;
        callback && callback.call(this);
        return this;
    }
    getUrlFile(url, fileName, callback) {
        axAjax({
            url: url,
            type: 'get',
            responseType: 'blob',
            headers: { 'Accept': '' },
            success: (response) => {
                let file = new File([response.content], fileName, { type: response.content.type });
                callback && callback(file);
            }
        });
    }
    show(data) {
        let newData = [];
        if (typeof data == 'string') {
            let arr = data.trim().split(',');
            arr.forEach(i => {
                let obj = { url: i, name: i }
                newData.push(obj);
            });
        } else if (Array.isArray(data) && typeof data[0] == 'string') {
            data.forEach(i => {
                let obj = { url: i, name: i }
                newData.push(obj);
            });
        } else {
            newData = data;
        }
        if (newData.length == 0) {
            return false;
        }
        this.parent.setAttribute('state', 'processing');
        newData.forEach(i => {
            this.getUrlFile(i.url, i.name, (file) => {
                this.history.push(file);
                let elem = this.renderItem(file),
                    item = this.details.find(i => i.file == file);
                item.progress = 'uploaded';
                item.state.message = this.options.message.success;
                item.state.url = i.url;
                item.state.time = i.time || file.lastModified;
                this.activeOperate(file, elem, i.url, i.name || i.url);
                elem.setAttribute('completed', '');
                this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
            })
        });
        this.details.forEach(i => {
            let obj = { name: i.file.name, url: i.state.url, size: i.file.size, time: i.state.time }
            this.value.push(obj);
        });
        this.valueToValue(this.value);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axUpload]').forEach(element => {
        new axUpload(element);
    });
})(); */
/*!
* 插件：即时消息/警告小窗；使用方法：new axMessage({参数})
*/
const axMessages = [];
class axMessage {
    constructor(options) {
        this.options = axExtend({
            insName: '',
            className: '',
            placement: 'center-top',
            content: '',
            result: 'info',
            delay: 3000,
            progress: true,
            title: {
                warning: '操作警告！',
                success: '操作成功！',
                error: '操作失败！',
                question: '操作疑问！',
                info: '信息提示！',
            },
            close: false,
            iconShow: false,
            style: 'simple',
            zIndex:0,
            icon: '',
            onShown:'',
            onHidden:'',
            onUpdated:'',
        }, options);
        this.handlers = {};
        this.init();
    }
    init() {
         axInstance.push(this, this.options.insName, 'message');
        if (this.options.style == 'simple' || !this.options.style) {
            switch (this.options.result) {
                case 'success':
                    this.options.icon = axIcon.font.success;
                    !this.options.content ? this.options.content = this.options.title.success : null;
                    break;
                case 'error':
                    this.options.icon = axIcon.font.error;
                    !this.options.content ? this.options.content = this.options.title.error : null;
                    break;
                case 'question':
                    this.options.icon = axIcon.font.question;
                    !this.options.content ? this.options.content = this.options.title.question : null;
                    break;
                case 'warning':
                    this.options.icon = axIcon.font.warning;
                    !this.options.content ? this.options.content = this.options.title.warning : null;
                    break;
                default:
                    this.options.icon = axIcon.font.info;
                    !this.options.content ? this.options.content = this.options.title.info : null;
            }
        } else if (this.options.style == 'complex') {
            switch (this.options.result) {
                case 'success':
                    this.options.icon = axIcon.svg.success;
                    break;
                case 'error':
                    this.options.icon = axIcon.svg.error;
                    break;
                case 'question':
                    this.options.icon = axIcon.svg.question;
                    break;
                case 'warning':
                    this.options.icon = axIcon.svg.warning;
                    break;
                default:
                    this.options.icon = axIcon.svg.info;
            }
        }
        if (this.options.style == 'simple' || !this.options.style) {
            this.template = axTplEngine(`
            <section data-style="simple">
                <div class="ax-message-content">
                    <# if(this.iconShow){ #><span legend><# this.icon #></span><# } #>
                    <div class="ax-message-body"><# this.content #></div>
                    <# if(this.close){ #><i close></i> <# } #>
                </div>
            </section>
            `, this.options);
        } else if (this.options.style == 'complex') {
            this.template = axTplEngine(`
            <section data-style="complex">
                <div class="ax-message-content">
                    <div class="ax-message-header">
                    <# if(this.iconShow){ #><span class="ax-result ax-result-show" legend><# this.icon #></span><# } #>
                    <span class="ax-message-title"><# if(this.result == 'success'){ #> <# this.title.success #> <# }else if(this.result == 'error'){ #> <# this.title.error #> <# }else if(this.result == 'question'){#> <# this.title.question #> <# }else if(this.result == 'warning'){#> <# this.title.warning #> <# } else {#> <# this.title.info #> <# } #></span></div>
                    <div class="ax-message-body"><# this.content #></div>
                </div>
                <# if(this.close){ #><i close></i> <# } #>
                <# if(this.progress){ #><div class="ax-message-progress" style="transition-duration:<# this.delay #>ms;"></div><# } #>
            </section>
            `, this.options);
        }
        this.targetDom = axStrToDom(this.template);
        this.contentDom = this.targetDom.querySelector('.ax-message-body');
        this.titleDom = this.targetDom.querySelector('.ax-message-title');
        this.closeDom = this.targetDom.querySelector('[close]');
        this.progressDom = this.targetDom.querySelector('.ax-message-progress');
        this.legendDom = this.targetDom.querySelector('[legend]');
        switch (this.options.result) {
            case 'success':
                this.targetDom.setAttribute('data-result', 'success');
                break;
            case 'error':
                this.targetDom.setAttribute('data-result', 'error');
                break;
            case 'question':
                this.targetDom.setAttribute('data-result', 'question');
                break;
            case 'warning':
                this.targetDom.setAttribute('data-result', 'warning');
                break;
            default:
                this.targetDom.setAttribute('data-result', 'info');
        }
        let className = '';
        !this.options.className ? className = ' ' + this.options.className : className = '';
        this.options.close ? this.targetDom.setAttribute('data-close', 'true') : null;
        this.contentDom.innerHTML = this.options.content;
        this.wrapperDom = ''
        this.shown = false;
        this.event = (position) => {
            let wrapper = axMessages.find(k =>k.position === position);
            if (!wrapper) {
                this.wrapperDom = axAddElem('div', { 'class': 'ax-message' + className, 'data-placement': position });
                axMessages.push({ position: position, parent: this.wrapperDom });
            } else {
                this.wrapperDom = wrapper.parent;
            }
        }
        switch (this.options.placement) {
            case 'left-top':
                this.event('left-top');
                break;
            case 'center-top':
                this.event('center-top');
                break;
            case 'right-top':
                this.event('right-top');
                break;
            case 'left-center':
                this.event('left-center');
                break;
            case 'center-center':
                this.event('center-center');
                break;
            case 'right-center':
                this.event('right-center');
                break;
            case 'left-bottom':
                this.event('left-bottom');
                break;
            case 'center-bottom':
                this.event('center-bottom');
                break;
            case 'right-bottom':
                this.event('right-bottom');
                break;
            case 'left':
                this.event('left-top');
                break;
            case 'top':
                this.event('center-top');
                break;
            case 'right':
                this.event('right-top');
                break;
            case 'center':
                this.event('center-center');
                break;
            default:
                this.event('center-top');
        }
        if (this.closeDom) {
            this.closeDom.onclick = () => {
                this.hide();
            };
        }
        this.options.zIndex ? this.wrapperDom.style.zIndex = this.options.zIndex : null;
        axIsVnode(this.wrapperDom) ? document.body.appendChild(this.wrapperDom) : null;
        return this;
    }
    show(callback) {
        if(this.shown){
            return false;
        }
        this.wrapperDom.appendChild(this.targetDom);
        axSlideDown(this.targetDom, '', () => {
            this.shown = true;
            this.handlers.hasOwnProperty('shown') ? this.emit('shown', '') : null;
            this.options.onShown && this.options.onShown.call(this);
            callback && callback.call(this);
            if (!this.options.close) {
                this.options.progress && this.progressDom ? this.progressDom.style.cssText += `width:0;` : null;
                setTimeout(() => {
                    this.hide();
                }, this.options.delay);
            }
        });
        return this;
    }
    hide(callback) {
        if(!this.shown){
            return false;
        }
        axSlideUp(this.targetDom, '', () => {
            this.targetDom.remove();
            this.shown = false;
            this.handlers.hasOwnProperty('hidden') ? this.emit('hidden', '') : null;
            this.options.onHidden && this.options.onHidden.call(this);
            callback && callback.call(this);
        });
        return this;
    }
    update(setting,callback){
        this.targetDom.remove();
        this.options = axExtend(this.options, setting);
        this.init();
        this.handlers.hasOwnProperty('updated') ? this.emit('updated', '') : null;
        this.options.onUpdated && this.options.onUpdated.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
 * 插件：折叠菜单；使用方法：new axMenu('#id',{参数})
 */
class axMenu {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            storageName: '',
            theme: 'light',
            content: '',
            dispose: false,
            active: '',
            disabled: '',
            multiple: false,
            collapseAll: true,
            ajaxType: 'post',
            zIndex: 0,
            trigger: 'click',
            rootStart: -1, 
            idStart: 0,
            arrowShow: true,
            max: 0,
            targetClass: '',
            addToActive: true,
            gapless: false,
            lamp: '',
            full: false,
            nav: {
                enable: false,
                headerWidth: '',
                bodyWidth: '',
                marginLeft: '',
                marginRight: '',
                align: 'left',
            },
            onInit: '',
            onTreeCompleted: '',
            onPlanted: '',
            onTrigger: '',
            onAdd: '',
            onRemove: '',
            onDisable: '',
            onEnable: '',
            onDisableALL: '',
            onEnableAll: '',
            onExpand: '',
            onExpanded: '',
            onCollapse: '',
            onCollapsed: '',
            onSelected: '',
            onUpdate: '',
            onUpdateContent: '',
            onDestroy: '',
            onSave: '',
            onExpandAll: '',
            onCollapseAll: '',
        }, options, this.targetDom, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.triggerShow = function () {
            _this.toggle(this);
        }
        this.triggerSelected = (item) => {
            item.headerDom.setAttribute('selected', '');
            item.selected = true;
            let others = this.flatData.filter(i => i !== item && i.selected && !i.children);
            others.forEach(i => {
                i.headerDom.removeAttribute('selected');
                delete i.selected;
            });
            this.options.onSelected && this.options.onSelected.call(this, item);
            'selected' in this.handlers ? this.emit('selected', item) : null;
            'trigger' in this.handlers ? this.emit('trigger', item) : null;
            this.options.onTrigger && this.options.onTrigger.call(this, item);
            this.save();
        }
        this.rawHTML = ''
        this.init();
    };
    init() {
        axInstance.push(this, this.options.insName, 'menu');
        this.destroyed = false;
        this.flatData = [];
        this.treeData = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.resolveSource();
        return this;
    }
    async resolveSource() {
        if (!axIsEmpty(this.options.content)) {
            this.targetDom.innerHTML = '';
            if (axType(this.options.content) === 'String') {
                await axTreeMethod.fullData({
                    source: this.options.content,
                    ajaxType: this.options.ajaxType,
                    async: true,
                    rootStart: this.options.rootStart,
                    idStart: this.options.idStart,
                    opened: (response) => {
                        this.contentXhr = response.xhr;
                    },
                    before: (response) => {
                        this.targetDom.innerHTML = response.content;
                    },
                    success: () => {
                        this.targetDom.innerHTML = '';
                    }
                }).then((result) => {
                    this.treeData = result.data;
                });
            } else if (axType(this.options.content) === 'Array') {
                if (this.options.content.length === 0) {
                    console.warn('Array is empty!');
                    return false;
                }
                await axTreeMethod.fullData({
                    source: this.options.content,
                    rootStart: this.options.rootStart,
                    idStart: this.options.idStart,
                }).then((result) => {
                    this.treeData = result.data;
                });
            }
            this.arrayToDom(this.treeData);
        } else {
            if (this.targetDom.innerHTML) {
                this.rawHTML = this.targetDom.innerHTML;
                this.treeData = this.ulToArr();
                this.treeData = axTreeMethod.addPath(this.treeData, this.options.rootStart, this.options.idStart).data;
            }
        }
        this.options.onTreeCompleted && this.options.onTreeCompleted.call(this, this.treeData);
        'treeCompleted' in this.handlers ? this.emit('treeCompleted', this.treeData) : null;
        this.processDataFormat(this.treeData);
    }
    processDataFormat(data) {
        this.flatData = axArrToFlat(data);
        this.initParms();
        this.renderFinish();
        this.options.onInit && this.options.onInit.call(this);
        'init' in this.handlers ? this.emit('init', '') : null;
    }
    initParms() {
        this.initAttribute();
        this.initActive();
        this.initDisabled();
    }
    ulToArr() {
        let data = [],
            start = this.options.idStart,
            getJson = (elem, index) => {
                let obj = {}, ul = elem.querySelector('ul');
                obj.id = index;
                obj.wrapperDom = elem;
                obj.headerDom = elem.firstElementChild;
                obj.labelDom = obj.headerDom.querySelector('[label]');
                obj.label = obj.labelDom.textContent.trim();
                obj.tipDom = obj.headerDom.querySelector('[tip]');
                obj.tip = obj.tipDom ? obj.tipDom.textContent.trim() : '';
                obj.url = obj.labelDom.href && !obj.labelDom.href.includes('##') ? obj.labelDom.href : '';
                obj.target = obj.labelDom.target;
                obj.arrowDom = obj.headerDom.querySelector('[arrow]');
                obj.legendDom = obj.headerDom.querySelector('[legend]');
                obj.legendDom ? obj.legend = obj.legendDom.getAttribute('class') : null;
                elem.hasAttribute('expanded') ? obj.expanded = true : null;
                obj.headerDom.hasAttribute('selected') ? obj.selected = true : null;
                obj.headerDom.hasAttribute('disabled') ? obj.disabled = true : null;
                if (ul) {
                    obj.children = [];
                    obj.bodyDom = ul;
                    [...ul.children].forEach(item => {
                        start++;
                        obj.children.push(getJson(item, start));
                    });
                }
                return obj;
            }
        let getData = () => {
            [...this.targetDom.children].forEach(item => {
                data.push(getJson(item, start));
                start++;
            });
        }
        getData();
        return data;
    }
    childToParent(item) {
        item.headerDom.onclick = null;
        item.expanded = true;
        item.wrapperDom.setAttribute('expanded', '');
        item.arrowDom = this.options.arrowShow && item.children ? axAddElem('i', { arrow: '', class: 'ax-iconfont ax-icon-right' }) : null;
        item.headerDom.appendChild(item.arrowDom);
        item.bodyDom = axAddElem('ul', { style: 'display:block' });
        return item;
    }
    createHeaderDom(item) {
        item.labelDom = axAddElem(item.url ? 'a' : 'i', { label: '' }, item.label);
        item.url ? item.labelDom.href = item.url : null;
        item.target ? item.labelDom.target = item.target : null;
        item.legendDom = item.legend ? axAddElem('i', { legend: '', class: `ax-iconfont ${item.legend}` }) : null;
        item.arrowDom = this.options.arrowShow && item.children ? axAddElem('i', { arrow: '', class: 'ax-iconfont ax-icon-right' }) : null;
        item.headerDom = axAddElem('div');
        item.tipDom = item.tip ? axAddElem('i', { tip: '' }, item.tip) : null;
        item.wrapperDom = axAddElem('li');
        item.wrapperDom.appendChild(item.headerDom);
        item.legendDom ? item.headerDom.appendChild(item.legendDom) : null;
        item.headerDom.appendChild(item.labelDom);
        item.tipDom ? item.headerDom.appendChild(item.tipDom) : null;
        item.arrowDom ? item.headerDom.appendChild(item.arrowDom) : null;
    }
    arrayToDom(data) {
        let outer = axAddElem('ul'),
            fragment = document.createDocumentFragment();
        let plantTree = (parent, data) => {
            let ul = axAddElem('ul');
            data.forEach(item => {
                this.createHeaderDom(item);
                if (item.hasOwnProperty('children')) {
                    item.bodyDom = plantTree(item.wrapperDom, item.children);
                }
                ul.appendChild(item.wrapperDom);
            });
            parent.appendChild(ul);
            return ul;
        }
        plantTree(outer, data);
        let list = outer.childNodes[0].childNodes;
        [...list].forEach(item => {
            fragment.appendChild(item);
        });
        this.targetDom.appendChild(fragment);
        this.options.onPlanted && this.options.onPlanted.call(this);
        'planted' in this.handlers ? this.emit('planted', '') : null;
    }
    initAttribute() {
        !this.targetDom.classList.contains('ax-menu') ? this.targetDom.classList.add('ax-menu') : null;
        this.options.targetClass ? axClass.add(this.targetDom, this.options.targetClass) : null;
        this.targetDom.setAttribute('theme', this.options.theme);
        this.options.gapless ? this.targetDom.setAttribute('gapless', '') : null;
        this.options.lamp ? this.targetDom.setAttribute('lamp', this.options.lamp) : null;
        this.options.full && !this.options.nav.enable ? this.targetDom.setAttribute('full', '') : null;
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
        if (this.options.nav.enable) {
            this.targetDom.setAttribute('nav', '');
            this.options.nav.align ? this.targetDom.setAttribute('align', this.options.nav.align) : null;
            if (this.options.nav.headerWidth) {
                let firstObj = this.flatData.filter(k => k.floor === 1);
                firstObj.forEach(k => {
                    k.wrapperDom.style.width = this.options.nav.headerWidth;
                });
            }
            if (this.options.nav.bodyWidth) {
                this.flatData.forEach(k => {
                    k.bodyDom ? k.bodyDom.style.width = this.options.nav.bodyWidth : null;
                })
            }
            if (this.options.nav.marginLeft) {
                this.flatData.filter(k => k.floor === 1).forEach(k => {
                    k.wrapperDom.style.marginLeft = this.options.nav.marginLeft;
                })
            }
            if (this.options.nav.marginRight) {
                this.flatData.filter(k => k.floor === 1).forEach(k => {
                    k.wrapperDom.style.marginRight = this.options.nav.marginRight;
                })
            }
        }
    }
    getPathIds(data) {
        if (data.length === 0) {
            return [];
        }
        let idsArr = [],
            idsItems = !this.options.multiple ? data.slice(0, 1) : data;
        idsItems.forEach(k => {
            let item = axFindItem(k, this.flatData), idsPath;
            if (item) {
                idsPath = item.path.split('>');
                idsArr.push(...idsPath);
            }
        });
        return [...new Set(idsArr)].map(k => parseInt(k));
    }
    initActive() {
        if (this.flatData.length === 0) {
            return false;
        }
        if (this.options.multiple && !this.options.collapseAll) {
            this.expandAll();
        } else {
            let itemsActive = this.options.active !== '' ? axValueToArr(this.options.active) : [],
                idsActive;
            itemsActive.push(...this.flatData.filter(k => k.selected), ...this.flatData.filter(k => k.expanded));
            idsActive = this.getPathIds(itemsActive);
            this.flatData.forEach(k => {
                if (idsActive.includes(k.id)) {
                    if (k.children) {
                        this.expand(k);
                    } else {
                        this.triggerSelected(k);
                    }
                }
            });
        }
    }
    initDisabled() {
        if (this.flatData.length === 0) {
            return false;
        }
        let items = this.flatData.filter(k => k.disabled),
            itemArr = this.options.disabled !== '' ? axValueToArr(this.options.disabled) : [];
        itemArr.push(...items);
        itemArr.forEach(k => {
            let item = axFindItem(k, this.flatData);
            if (item) {
                item.disabled = true;
                item.headerDom.setAttribute('disabled', '');
            }
        });
    }
    renderFinish() {
        if (!this.options.dispose) {
            this.flatData.forEach(k => {
                if (k.children) {
                    if (!k.disabled) {
                        let triggerDom = k.url && k.arrowDom ? k.arrowDom : k.headerDom;
                        if (this.options.trigger === 'click') {
                            triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
                        } else if (this.options.trigger === 'hover') {
                            this.hover = new axHover(k.wrapperDom, {
                                enter: () => {
                                    this.expand(k);
                                    'trigger' in this.handlers ? this.emit('trigger', k) : null;
                                    this.options.onTrigger && this.options.onTrigger.call(this, k);
                                },
                                leave: () => {
                                    this.collapse(k);
                                }
                            });
                        }
                    }
                } else {
                    if (!k.disabled) {
                        k.headerDom.onclick = () => {
                            this.triggerSelected(k);
                        }
                    }
                }
                k.callback && k.callback.call(this, k);
            });
        }
        this.save();
    }
    workToggle(item, type = 'disable') {
        let triggerDom = item.url && item.arrowDom ? item.arrowDom : item.headerDom;
        if (type === 'enable') {
            item.disabled ? delete item.disabled : null;
            item.headerDom.removeAttribute('disabled');
            if (!item.children) {
                item.headerDom.onclick = () => {
                    this.triggerSelected(item);
                }
            } else {
                triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
            }
        } else if (type === 'disable') {
            item.disabled = true;
            item.headerDom.setAttribute('disabled', '');
            if (!item.children) {
                item.headerDom.onclick = null;
            } else {
                triggerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
            }
        }
        this.save();
    }
    getDisabled() {
        return this.flatData.filter(k => k.disabled);
    }
    getExpanded() {
        return this.flatData.filter(k => k.expanded);
    }
    getActive() {
        return this.flatData.filter(k => k.expanded || k.selected);
    }
    getSelected() {
        return this.flatData.find(k => k.selected);
    }
    collapseAll(callback) {
        if (this.destroyed) {
            return this;
        }
        this.flatData.filter(k => k.expanded).forEach(k => {
            this.collapse(k);
        });
        'collapseAll' in this.handlers ? this.emit('collapseAll', '') : null;
        this.options.onCollapseAll && this.options.onCollapseAll.call(this);
        callback && callback.call(this);
    }
    expandAll(callback) {
        if (this.destroyed || !this.options.multiple) {
            return this;
        }
        this.flatData.forEach(k => {
            this.expand(k);
        });
        'expandAll' in this.handlers ? this.emit('expandAll', '') : null;
        this.options.onExpandAll && this.options.onExpandAll.call(this);
        callback && callback.call(this);
    }
    disable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let disableFun = (k) => {
            let item = axFindItem(k, this.flatData);
            if (item) {
                this.workToggle(item, 'disable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                disableFun(k);
            });
        } else {
            disableFun(obj);
        }
        this.save();
        let disableds = this.flatData.filter(k => k.disabled);
        'disable' in this.handlers ? this.emit('disable', disableds) : null;
        this.options.onDisable && this.options.onDisable.call(this, disableds);
        callback && callback.call(this, disableds);
    }
    disableAll(callback) {
        this.disable(this.flatData);
        'disableAll' in this.handlers ? this.emit('disableAll', '') : null;
        this.options.onDisableAll && this.options.onDisableAll.call(this);
        callback && callback.call(this);
    }
    enable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let enableFun = (k) => {
            let item = axFindItem(k, this.flatData);
            if (item) {
                this.workToggle(item, 'enable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                enableFun(k);
            });
        } else {
            enableFun(obj);
        }
        this.save();
        let enableds = this.flatData.filter(k => !k.disabled);
        'enable' in this.handlers ? this.emit('enable', enableds) : null;
        this.options.onEnable && this.options.onEnable.call(this, enableds);
        callback && callback.call(this, enableds);
    }
    enableAll(callback) {
        this.enable(this.flatData);
        'enableAll' in this.handlers ? this.emit('enableAll', '') : null;
        this.options.onEnableAll && this.options.onEnableAll.call(this);
        callback && callback.call(this);
    }
    toggle(obj) {
        let item = axFindItem(obj, this.flatData) || axFindItem(obj, this.flatData, { dom: 'arrowDom' });
        if (item.expanded) {
            this.collapse(item);
        } else {
            this.expand(item);
        }
        'trigger' in this.handlers ? this.emit('trigger', item) : null;
        this.options.onTrigger && this.options.onTrigger.call(this, item);
    }
    collapse(obj, callback) {
        let type = axType(obj),
            item = type === 'Object' ? obj : axFindItem(obj, this.flatData);
        if (!item || !item.children) {
            return false;
        }
        'collapse' in this.handlers ? this.emit('collapse', item) : null;
        this.options.onCollapse && this.options.onCollapse.call(this, item);
        delete item.expanded;
        item.wrapperDom.removeAttribute('expanded');
        axSlideUp(item.bodyDom, '', () => {
            'collapsed' in this.handlers ? this.emit('collapsed', item) : null;
            this.options.onCollapsed && this.options.onCollapsed.call(this, item);
            callback && callback.call(this, item);
        });
        this.save();
    }
    expand(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        let item = axFindItem(obj, this.flatData), others;
        if (!axIsEmpty(item) && item.children) {
            'expand' in this.handlers ? this.emit('expand', item) : null;
            this.options.onExpand && this.options.onExpand.call(this, item);
            item.expanded = true;
            item.wrapperDom.setAttribute('expanded', '');
            axSlideDown(item.bodyDom, '', () => {
                'expanded' in this.handlers ? this.emit('expanded', item) : null;
                this.options.onExpanded && this.options.onExpanded.call(this, item);
                callback && callback.call(this, item);
            });
            if (!this.options.multiple) {
                others = this.flatData.filter(k => (k !== item && k.expanded && k.floor === item.floor && k.children));
                others.forEach(k => {
                    this.collapse(k);
                });
            }
            this.save();
        }
    }
    active(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        let activeArr = [],
            activeItems = [],
            activeFun = (k) => {
                let item = axFindItem(k, this.flatData);
                if (item) {
                    let ids = item.path.split('>').map(k => parseInt(k));
                    ids.forEach(k => {
                        this.expand(k);
                    });
                    if (!item.children) {
                        this.triggerSelected(item);
                    }
                }
            }
        if (Array.isArray(obj)) {
            if (!this.options.multiple) {
                activeArr = obj.slice(0, 1);
            } else {
                activeArr = obj
            }
        } else {
            activeArr = [obj]
        }
        activeItems = activeArr.map(k => axFindItem(k, this.flatData)).filter(Boolean);
        activeArr.forEach(k => {
            activeFun(k);
        });
        'active' in this.handlers ? this.emit('active', activeItems) : null;
        this.options.onActive && this.options.onActive.call(this, activeItems);
        callback && callback.call(this, activeItems);
        this.save();
    }
    add(data, target, isChild = false, isFront = false, callback) {
        if (this.destroyed) {
            return this;
        }
        if (this.flatData.length >= this.options.max && this.options.max !== 0) {
            console.warn('The number of children exceeds the maximum!');
            return false;
        }
        let type = axType(data),
            items = [],
            appendFun = (source, target, isChild, isFront) => {
                let targetData;
                if (source.hasOwnProperty('pId') && source.pId !== this.options.rootStart) {
                    targetData = axFindItem(source.pId, this.flatData);
                    isChild = true;
                } else {
                    if (target === undefined || target === 'end') {
                        targetData = this.flatData.filter(k => k.floor === 1).slice(-1)[0];
                    } else if (target === 'start') {
                        targetData = this.flatData.filter(k => k.floor === 1)[0];
                        isFront = true;
                    } else {
                        targetData = axFindItem(target, this.flatData);
                    }
                }
                let sourceData = axTreeMethod.createData(source, targetData, this.flatData, isChild);
                this.createHeaderDom(sourceData);
                if (isChild) {
                    if (targetData.children) {
                        axTreeMethod.existChildPush(sourceData, targetData);
                    } else {
                        axTreeMethod.noExistChildPush(sourceData, targetData, () => {
                            return this.childToParent(targetData);
                        });
                    }
                } else {
                    let parent = this.flatData.find(i => i.id == targetData.pId),
                        children = parent ? parent.children : this.treeData,
                        index = children.indexOf(targetData);
                    if (isFront) {
                        index == 0 ? children.unshift(sourceData) : children.splice(index, 0, sourceData);
                        targetData.wrapperDom.insertAdjacentElement('beforeBegin', sourceData.wrapperDom);
                    } else {
                        children.splice(index + 1, 0, sourceData);
                        targetData.wrapperDom.insertAdjacentElement('afterEnd', sourceData.wrapperDom);
                    }
                }
                this.flatData.push(sourceData);
                items.push(sourceData);
            };
        if (type === 'Array' && data.length > 0) {
            data.forEach(k => {
                appendFun(k, target, isChild, isFront);
            });
        } else {
            appendFun(data, target, isChild, isFront);
        }
        if (items.length > 0) {
            if (this.options.addToActive) {
                if (this.options.multiple) {
                    items.forEach(k => {
                        k.children ? this.expand(k) : null;
                    });
                } else {
                    let lastItem = items[items.length - 1];
                    lastItem.children ? this.expand(lastItem) : null;
                }
            }
            this.renderFinish();
        }
        'add' in this.handlers ? this.emit('add', items) : null;
        this.options.onAdd && this.options.onAdd.call(this, items);
        callback && callback.call(this, items);
        return this;
    }
    remove(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.flatData.length === 0) {
            console.warn('The data is already empty!');
            return false;
        }
        let removeItem = (child) => {
            let item = axFindItem(child, this.flatData),
                data;
            if (item) {
                data = axTreeMethod.remove(item, this.flatData, this.treeData);
                this.flatData = data.flat;
                this.treeData = data.tree;
            }
        };
        if (Array.isArray(data)) {
            data.forEach(k => {
                removeItem(k);
            });
        } else {
            removeItem(data);
        }
        this.save();
        'remove' in this.handlers ? this.emit('remove', '') : null;
        this.options.onRemove && this.options.onRemove.call(this);
        callback && callback.call(this);
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            let idsActive = [...this.flatData.filter(k => k.selected), ...this.flatData.filter(k => k.expanded)].filter(Boolean).map(k => k.id),
                idsDisabled = this.flatData.filter(k => k.disabled).map(k => k.id);
            if (!props) {
                axLocalStorage.set(this.options.storageName, { active: idsActive, disabled: idsDisabled, content: this.flatData });
            } else {
                !props.hasOwnProperty('active') ? props.active = idsActive : null;
                !props.hasOwnProperty('disabled') ? props.disabled = idsDisabled : null;
                !props.hasOwnProperty('content') ? props.content = this.flatData : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            'save' in this.handlers ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
            return this;
        }, 0)
    }
    destroy(callback) {
        this.flatData.forEach(k => {
            let triggerDom = k.url && k.arrowDom ? k.arrowDom : k.headerDom;
            triggerDom.removeEventListener(this.options.trigger, this.triggerShow);
            triggerDom.onclick = null;
            k.headerDom.onclick = null;
        });
        this.destroyed = true;
        this.contentXhr ? this.contentXhr.abort() : null;
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    updateContent(item, content, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(item, this.flatData);
        if (me) {
            if (axType(content) === 'String') {
                me.label = content;
                me.labelDom.innerHTML = content;
            } else if (axType(content) === 'Object') {
                if (content.label) {
                    me.label = content.label;
                    me.labelDom.innerHTML = content.label;
                }
                if (content.url && me.url) {
                    me.url = content.url;
                    me.labelDom.href = content.url;
                }
                if (content.target && me.url) {
                    me.target = content.target;
                    me.labelDom.target = content.target;
                }
            }
            'updateContent' in this.handlers ? this.emit('updateContent', me) : null;
            this.options.onUpdateContent && this.options.onUpdateContent.call(this, me);
            callback && callback.call(this, me);
            this.save();
        }
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        this.targetDom.innerHTML = this.rawHTML ? this.rawHTML : '';
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* 
document.querySelectorAll('[axMenu]').forEach(element => {
    new axMenu(element);
}); */
/*!
* 插件：黏住顶部或盒子；使用方法：new axStick('#id',{参数})
*/
const axSticks = [];
class axStick {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            refer: 'body',
            space: '0px',
            width: '',
            zIndex: '',
        }, options, this.targetDom,this.constructor.name);
        this.handlers = {};
        this.height = this.targetDom.offsetHeight;
        this.width = this.targetDom.offsetWidth;
        this.left = axOffset(this.targetDom).left;
        this.top = axOffset(this.targetDom).top;
        this.bottom = axOffset(this.targetDom).top + this.height;
        this.style = this.targetDom.getAttribute('style');
        this.placeholder = axAddElem('DIV', { style: `width:${this.width}px;height:${this.height}px;display:none;` });
        this.targetDom.insertAdjacentElement('beforebegin', this.placeholder);
        this.init();
        return this;
    }
    init() {
        axInstance.push(this, this.options.insName, 'stick');
        this.refer = this.targetDom.closest(this.options.refer);
        this.referHeight = this.refer.offsetHeight;
        this.referWidth = this.refer.offsetWidth;
        this.referLeft = axOffset(this.refer).left;
        this.referTop = axOffset(this.refer).top;
        this.referBottom = axOffset(this.refer).top + this.referHeight;
        if (this.options.refer !== 'body' && (getComputedStyle(this.refer).position !== 'fixed' || getComputedStyle(this.refer).position !== 'absolute')) {
            this.refer.style.position = 'relative';
        }
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
        getComputedStyle(this.targetDom).float !== 'none' ? this.placeholder.style.float = getComputedStyle(this.targetDom).float : null;
        window.addEventListener("scroll", () => {
            if (this.height > window.innerHeight) {
                if (this.bottom < document.documentElement.scrollTop + window.innerHeight && this.referBottom > document.documentElement.scrollTop + window.innerHeight) {
                    this.targetDom.style.cssText += `width:${this.targetDom.offsetWidth}px;`;
                    this.targetDom.style.cssText += `left:${axOffset(this.targetDom).left}px;`
                    this.targetDom.style.cssText += `position:fixed;bottom:${this.options.space};margin:0;`;
                    this.placeholder.style.display = 'block';
                    'sticked' in this.handlers ? this.emit('sticked', 'fixed') : null;
                } else if (this.referBottom < document.documentElement.scrollTop + window.innerHeight) {
                    this.targetDom.style.position = 'absolute';
                    this.targetDom.style.left = this.left - this.referLeft + 'px';
                    this.targetDom.style.cssText += `position:absolute;bottom:${this.options.space};margin:0;`;
                    this.placeholder.style.display = 'none';
                    'sticked' in this.handlers ? this.emit('sticked', 'absolute') : null;
                } else if (axOffset(this.refer).top > document.documentElement.scrollTop) {
                    this.targetDom.setAttribute('style', this.style);
                    this.placeholder.style.display = 'none';
                    'unsticked' in this.handlers ? this.emit('unsticked', '') : null;
                }
            } else {
                if (this.top < document.documentElement.scrollTop) {
                    if (!this.options.width) {
                        this.targetDom.style.cssText += `width:${this.targetDom.offsetWidth}px;`;
                        this.targetDom.style.cssText += `left:${this.left}px;`
                    } else {
                        this.targetDom.style.cssText += `width:${this.options.width};`;
                        this.targetDom.style.cssText += `left:calc(50% - ${this.options.width}/2);`;
                    }
                    this.targetDom.style.cssText += `position:fixed;top:${this.options.space};bottom:auto;margin:0;`;
                    this.placeholder.style.display = 'block';
                    'sticked' in this.handlers ? this.emit('sticked', 'fixed') : null;
                    if (this.height > this.referBottom - document.documentElement.scrollTop) {
                        this.targetDom.style.position = 'absolute';
                        this.targetDom.style.left = this.left - this.referLeft + 'px';
                        this.targetDom.style.top = 'auto';
                        this.targetDom.style.bottom = 0;
                        'sticked' in this.handlers ? this.emit('sticked', 'absolute') : null;
                    }
                } else {
                    this.targetDom.setAttribute('style', this.style);
                    this.placeholder.style.display = 'none';
                    'unsticked' in this.handlers ? this.emit('unsticked', '') : null;
                }
            }
        }, false);
        return this;
    }
    destroy(callback) {
        this.targetDom.lastChild.removeEventListener('click', this.event, false);
        this.targetDom.innerHTML = this.html;
        callback && callback.call(this);
    }
    update(setting, callback) {
        this.targetDom.style = this.style;
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axStick]').forEach(element => {
        new axStick(element);
    });
})();
 */
/*!
 * 插件：下拉菜单单选和多选；使用方法：axSelect('#id',{参数})
 */
class axSelect {
    constructor(inputDom, options) {
        this.inputDom = axIdToDom(inputDom);
        if (!this.inputDom) return false;
        this.options = axExtend({
            insName: '',
            storageName: '',
            least: 0,
            most: 0,
            content: '',
            async: false,
            trigger: 'click',
            selected: '',
            disabled: '',
            clearShow: false,
            removable: false,
            separator: ',',
            dropdownShow: true,
            ajaxType: 'post',
            absentAddable: false,
            idStart: 0,
            width: '',
            size: 'md',
            readonly: false,
            enterSelect: true,
            className: '',
            language: {
                inputPlaceholder: '请选择...',
                searchPlaceholder: '输入关键字...',
                editPlaceholder: '输入关键字...',
                absent: `列表中没有"<# this.value #>"可供选择！`,
                absentAddable: `列表中没有"<# this.value #>"，但是作为新项加入了列表！`,
                empty: '没有找到符合"<# this.value #>"的选项！',
                emptyAddable: '没有找到符合"<# this.value #>"的选项，请使用回车键添加！',
                most: `只能最多选择"<# this.value #>"项！`,
                addFail: `添加失败！列表中已经有了"<# this.value #>"这一项。`,
            },
            search: {
                enable: false,
                fuzzy: true, 
                limit: 0,
                reorder: false,
                editable: true,
            },
            dialog: {},
            popup: {},
            onInit: '',
            onBeforeAdd: '',
            onAdd: '',
            onBeforeRemove: '',
            onRemove: '',
            onSelect: '',
            onUnselect: '',
            onDisabled: '',
            onEnabled: '',
            onClear: '',
            onAbsentSelect: '',
            onToggleSelect: '',
            onMost: '',
            onLeast: '',
            onUpdate: '',
            onDestroy: '',
            onSave: '',
        }, options, this.inputDom, this.constructor.name);
        this.handlers = {};
        if (this.inputDom.nodeName === 'SELECT') {
            if (this.inputDom.hasAttribute('multiple')) {
                this.inputType = 'select-multiple';
            } else {
                this.inputType = 'select-single';
            }
        } else if (this.inputDom.nodeName === 'INPUT') {
            this.inputType = 'input';
        }
        this.clickSelect = (obj) => {
            if (~~obj.disabled || obj.children) {
                return false;
            }
            let tagObj = { id: obj.id, value: obj.value || obj.label };
            if (this.inputType === 'select-single') {
                if (~~obj.selected) {
                    return false;
                } else {
                    this.toggleList(obj, this.data);
                    this.tagsIns.clear();
                    this.tagsIns.add(tagObj);
                }
            } else {
                this.selectedAttrToggle(obj, !~~obj.selected);
                if (~~obj.selected) {
                    this.tagsIns.add(tagObj);
                } else {
                    this.tagsIns.remove(tagObj);
                }
            }
        }
        this.keydownSelect = (data) => {
            if (axIsEmpty(data)) {
                document.onkeydown = null;
                return false;
            }
            document.onkeydown = (e) => {
                let usableItems = data.filter(k => !k.children && !~~k.disabled),
                    curItem = usableItems.find(k => k.active),
                    curIndex = usableItems.findIndex(k => k === curItem) || 0;
                if (e.code === 'ArrowDown') {
                    axPreventDefault(e);
                    this.keyToggleActive('down', curItem, curIndex, usableItems);
                } else if (e.code === 'ArrowUp') {
                    axPreventDefault(e);
                    this.keyToggleActive('up', curItem, curIndex, usableItems);
                } else if (e.code === 'Enter') {
                    if (curItem && this.options.enterSelect) {
                        if (this.inputType === 'select-single') {
                            this.select(curItem);
                        } else {
                            !~~curItem.selected ? this.select(curItem) : this.unselect(curItem);
                        }
                    }
                }
            }
        }
        this.bodyClickBlur = (e) => {
            if (!this.selectDom.contains(e.target)) {
                this.selectDom.classList.remove('ax-opened');
                document.removeEventListener('click', this.bodyClickBlur);
            }
        }
        this.init();
        return this;
    }
    beforeInit() {
        if (this.selectDom) {
            this.tagsIns.destroy();
            this.tagsIns = null;
            if (this.popupIns) {
                this.popupIns.destroy();
                this.popupIns = null;
            }
            this.tagsDom.innerHTML = '';
            this.listDom.innerHTML = '';
            this.searchDom ? this.searchDom.remove() : null;
        }
    }
    async init() {
        this.beforeInit();
        axInstance.push(this, this.options.insName, 'select');
        this.destroyed = false;
        this.maxIndex = this.options.idStart;
        this.value = '';
        this.selected = [];
        this.searchResult = [];
        this.data = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.inputDom.style.width && !this.options.width ? this.options.width = this.inputDom.style.width : null;
        this.createSkeleton();
        let contentType = axType(this.options.content);
        if (this.inputType === 'input' && contentType === 'String' && this.options.async) {
            await this.getAsyncData((content) => {
                this.data = axArrToFlat(content);
            });
        } else {
            if (this.inputType.includes('select')) {
                this.getDataFromNode(this.inputDom);
            } else if (this.inputType === 'input') {
                if (!axIsEmpty(this.options.content)) {
                    if (contentType === 'String') {
                        if (this.options.content.trim().startsWith('#')) {
                            this.getDataFromNode(this.options.content);
                        } else {
                            this.getDataFromStr(this.options.content);
                        }
                    } else if (contentType === 'Array') {
                        this.data = axArrToFlat(this.options.content);
                        !isNaN(this.data[0].id) ? this.maxIndex = Math.max(...this.data.map(k => k.id)) + 1 : null;
                    } else if (contentType.includes('HTML')) {
                        this.getDataFromNode(this.options.content);
                    }
                } else if (this.inputDom.value) {
                    this.getDataFromStr(this.inputDom.value);
                }
            }
        }
        this.initRender();
        this.renderFinish();
        this.handlers.hasOwnProperty('init') ? this.emit('init', '') : null;
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    getAsyncData(callback) {
        return axAjax({
            type: this.options.ajaxType,
            url: this.options.content,
            opened: (response) => {
                this.contentXhr = response.xhr;
            },
            success: (response) => {
                if (axIsEmpty(response.content) && !Array.isArray(response.content)) {
                    console.warn('No data obtained from database!');
                    return false;
                }
                this.tagsDom.innerHTML = '';
                this.listDom.innerHTML = '';
                callback && callback(response.content);
            }
        }, this.tagsDom);
    }
    getDataFromNode(elememt) {
        let elem = axIdToDom(elememt),
            listData;
        if (elem.nodeName === 'UL') {
            listData = axUlToArr(elem, 0);
        } else if (elem.nodeName === 'SELECT' || elem.nodeName === 'DATALIST') {
            listData = axSelectToArr(elem, 0);
        } else {
            return false;
        }
        this.data = axArrToFlat(listData.data);
        this.maxIndex = listData.index;
    }
    getDataFromStr(str) {
        let strArr = str.split(this.options.separator);
        this.data = strArr.map((k, i) => {
            return { id: i, label: k, value: k }
        });
        this.maxIndex = strArr.length + 1;
    }
    setAttribute() {
        this.options.className ? axClass.add(this.selectDom, this.options.className) : null;
        this.selectDom.setAttribute('type', this.inputType);
        if (this.options.width) {
            this.selectDom.style.width = this.options.width;
        }
        !axIsMobi() && this.selectDom.getBoundingClientRect().width ? this.options.popup.width = this.selectDom.getBoundingClientRect().width + 'px' : null;
        this.selectDom.setAttribute('size', this.options.size);
        if (this.options.readonly) {
            this.readonly();
        }
    }
    initDataStd() {
        let selectedType = axType(this.options.selected),
            disabledType = axType(this.options.disabled),
            handleFun = (obj, type) => {
                let objType = axType(obj), item;
                if (objType === 'Number' || objType === 'Object') {
                    item = axFindItem(obj, this.data);
                } else if (objType === 'String') {
                    item = axFindItem(obj, this.data) || axFindItem(obj, this.data, { string: 'value' });
                }
                if (item) {
                    item[type] = true;
                    item.dom.setAttribute(type, '');
                }
            };
        if (selectedType === 'Array') {
            for (let k of this.options.selected) {
                handleFun(k, 'selected');
            }
        } else if (selectedType === 'String') {
            this.options.selected.split(',').forEach(k => {
                handleFun(k, 'selected');
            });
        } else {
            handleFun(this.options.selected, 'selected');
        }
        if (disabledType === 'Array') {
            for (let k of this.options.disabled) {
                handleFun(k, 'disabled');
            }
        } else if (disabledType === 'String') {
            this.options.disabled.split(',').forEach(k => {
                handleFun(k, 'disabled');
            });
        } else {
            handleFun(this.options.disabled, 'disabled');
        }
    }
    createSkeleton() {
        /* !this.selectDom ? this.selectDom = axAddElem('div', { class: 'ax-select' }) : null;
        this.inputDom.style.display = 'none';
        !this.selectDom.contains(this.inputDom) ? this.inputDom.insertAdjacentElement('beforebegin', this.selectDom) : null;
        this.tagsDom = axAddElem('div', { class: 'ax-tags' });
        this.clearDom = axAddElem('i', { clear: '' });
        this.selectDom.appendChild(this.inputDom);
        this.selectDom.appendChild(this.tagsDom);
        this.options.clearShow ? this.selectDom.appendChild(this.clearDom) : null;
        if (this.options.dropdownShow) {
            this.arrowDom = axAddElem('i', { arrow: '' });
            this.selectDom.appendChild(this.arrowDom);
            this.wrapperDom = axAddElem('div', { class: 'ax-select-wrapper' });
            this.listDom = axAddElem('ul');
            this.wrapperDom.appendChild(this.listDom);
        } */
        if (!this.selectDom) {
            this.selectDom = axAddElem('div', { class: 'ax-select' });
            this.inputDom.style.display = 'none';
            this.inputDom.insertAdjacentElement('beforebegin', this.selectDom);
            this.selectDom.appendChild(this.inputDom);
            this.tagsDom = axAddElem('div', { class: 'ax-tags' });
            this.selectDom.appendChild(this.tagsDom);
            if (this.options.dropdownShow) {
                this.arrowDom = axAddElem('i', { arrow: '' });
                this.selectDom.appendChild(this.arrowDom);
                this.wrapperDom = axAddElem('div', { class: 'ax-select-wrapper' });
                this.listDom = axAddElem('ul');
                this.wrapperDom.appendChild(this.listDom);
            }
        }
        if (!this.selectDom.contains(this.clearDom)) {
            this.clearDom = axAddElem('i', { clear: '' });
            this.options.clearShow ? this.arrowDom.insertAdjacentElement('beforebegin', this.clearDom) : null;
        }
        this.setAttribute();
    }
    initRender() {
        this.data.forEach(k => {
            this.fillItem(k, this.listDom);
        });
    }
    fillItem(obj, parent, placement = 'end') {
        obj.dom = axAddElem('li', '', `${obj.legend ? '<i class="ax-iconfont ' + obj.legend + '" legend></i>' : ''}${obj.image ? '<i image><img src="' + obj.image + '"/></i>' : ''}<i label>${obj.label}</i>${obj.tip ? '<i tip>' + obj.tip + '</i>' : ''}`);
        if (obj.children) {
            obj.dom.setAttribute('parent', '');
        } else {
            ~~obj.selected ? obj.dom.setAttribute('selected', '') : null;
            ~~obj.disabled ? obj.dom.setAttribute('disabled', '') : null;
        }
        if (parent) {
            placement !== 'end' ? parent.insertAdjacentElement('afterbegin', obj.dom) : parent.appendChild(obj.dom);
        }
    }
    reRenderList(data) {
        this.initDataStd();
        this.listDom.innerHTML = '';
        if (data[0].hasOwnProperty('weight')) {
            data.forEach(k => {
                let pattern = new RegExp(k.keys.join('|'), 'g'),
                    labelDom = k.source.dom.querySelector('[label]');
                labelDom.innerHTML = labelDom.innerHTML.replace(/<[^>]+>/g, '').replace(pattern, match => `<s>${match}</s>`);
                this.listDom.appendChild(k.source.dom);
            });
        } else {
            data.forEach(k => {
                k.dom.querySelector('[label]').innerHTML = k.dom.querySelector('[label]').innerHTML.replace(/<[^>]+>/g, '');
                this.listDom.appendChild(k.dom);
            });
        }
    }
    selectedAttrToggle(obj, state) {
        if (state) {
            if (!~~obj.selected) {
                if (this.inputType !== 'single-multiple' && this.options.most !== 0) {
                    if (this.data.filter(k => ~~k.selected).length >= this.options.most) {
                        new axMessage({
                            content: axTplEngine(this.options.language.most, { value: this.options.most }),
                            result: 'error',
                            iconShow: true,
                        }).show();
                        this.handlers.hasOwnProperty('most') ? this.emit('most', this.options.most) : null;
                        this.options.onMost && this.options.onMost.call(this, this.options.most);
                        return false;
                    }
                }
                Reflect.set(obj, 'selected', true);
                obj.dom.setAttribute('selected', '');
                if (this.inputType.includes('select')) {
                    obj.node ? obj.node.setAttribute('selected', '') : null;
                }
            }
        } else {
            if (~~obj.selected) {
                Reflect.deleteProperty(obj, 'selected');
                obj.dom.removeAttribute('selected');
                this.inputType.includes('select') && obj.node ? obj.node.removeAttribute('selected') : null;
            }
        }
        'toggleSelect' in this.handlers ? this.emit('toggleSelect', obj) : null;
        this.options.onToggleSelect && this.options.onToggleSelect.call(this, obj);
    }
    toggleList(item, list) {
        this.selectedAttrToggle(item, true);
        let selectedItem = list.find(k => k != item && ~~k.selected);
        if (selectedItem) {
            this.selectedAttrToggle(selectedItem, false);
        }
    }
    /*     activeAttrToggle(obj) {
            if (!obj.active) {
                let oldActive = this.data.find(k => k.active);console.log(oldActive)
                if (oldActive) {
                    Reflect.deleteProperty(oldActive, 'active');
                    oldActive.dom.removeAttribute('active');
                }
                obj.active = true;
                obj.dom.setAttribute('active', ''); 
            }
        } */
    keyToggleActive(direction, item, index, arr) {
        if (this.popupIns.state === 'hidden') {
            this.popupIns.show();
            if (!item) {
                arr[0].active = true;
                arr[0].dom.setAttribute('active', '');
            }
        } else if (this.popupIns.state === 'shown') {
            let nextItem, offset = 0;
            if (direction === 'up') {
                if (index > 0) {
                    if (item) {
                        Reflect.deleteProperty(item, 'active');
                        item.dom.removeAttribute('active');
                    }
                    nextItem = arr[index - 1];
                    nextItem.active = true;
                    nextItem.dom.setAttribute('active', '');
                    index--;
                    if (nextItem.dom.offsetTop > this.wrapperDom.clientHeight) {
                        offset = nextItem.dom.offsetTop + nextItem.dom.getBoundingClientRect().height - this.wrapperDom.clientHeight;
                    }
                    axScrollTo(offset, { parent: this.wrapperDom, duration: 200 });
                }
            } else if (direction === 'down') {
                if (index + 1 < arr.length) {
                    if (item) {
                        Reflect.deleteProperty(item, 'active');
                        item.dom.removeAttribute('active');
                    }
                    nextItem = arr[index + 1];
                    nextItem.active = true;
                    nextItem.dom.setAttribute('active', '');
                    index++;
                    if (!axChildVisible(nextItem.dom, this.wrapperDom)) {
                        offset = (nextItem.dom.offsetTop + nextItem.dom.getBoundingClientRect().height) - this.wrapperDom.clientHeight;
                    }
                    axScrollTo(offset, { parent: this.wrapperDom, duration: 200 });
                }
            }
        }
    }
    renderFinish() {
        this.rawData = [...this.data];
        let inputTip = '';
        if (this.options.most > 0 && this.options.least > 0) {
            inputTip = `最多选择${this.options.most}项，至少选择${this.options.least}项`;
        } else if (this.options.most > 0) {
            inputTip = `最多选择${this.options.most}项`;
        } else if (this.options.most > 0) {
            inputTip = `至少选择${this.options.most}项`;
        } else {
            inputTip = this.options.language.inputPlaceholder;
        }
        this.tagsIns = new axTags(this.tagsDom, {
            content: this.data.filter(k => ~~k.selected).map(k => { return { id: k.id, value: k.value || k.label } }),
            removable: this.inputType === 'select-single' ? false : this.options.removable,
            compact: this.inputType === 'select-single' ? false : true,
            text: this.inputType === 'select-single' ? true : false,
            theme: this.inputType === 'select-single' ? 'auto' : 'light',
            emptyShow: this.inputType.includes('select') || (this.inputType === 'input' && !this.options.search.enable) ? true : false,
            emptyTip: `<i class="ax-color-ignore">${inputTip}</i>`,
            edit: {
                enable: this.inputType.includes('select') ? false : this.options.search.enable,
                addable: this.options.search.editable,
                deletable: this.options.search.editable,
                placeholder: this.options.language.editPlaceholder,
            },
        });
        if (this.inputType.includes('select')) {
            this.searchDom = axAddElem('input', { type: 'text', placeholder: this.options.language.searchPlaceholder });
        } else if (this.inputType === 'input') {
            this.searchDom = this.tagsIns.inputDom;
        }
        if (this.options.dropdownShow) {
            this.options.search.enable && this.inputType.includes('select') ? this.wrapperDom.insertAdjacentElement('afterbegin', this.searchDom) : null;
            this.popupIns = new axPopup(this.selectDom, axExtend({
                content: this.wrapperDom,
                trigger: this.options.trigger,
                footerShow: false,
                close: false,
                padding: false,
                triggerStrict: true,
                arrow: false,
                theme: 'select',
                placement: 'bottom-start',
            }, this.options.popup));
            this.popupIns.on('show', () => {
                this.searchDom && this.inputType === 'input' ? this.searchDom.focus() : null;
            });
            this.popupIns.on('shown', () => {
                this.searchDom && this.inputType.includes('select') ? this.searchDom.focus() : null;
                axPreventScroll(this.wrapperDom);
            });
            this.popupIns.on('hide', () => {
                this.keydownSelect();
            });
            this.popupIns.on('hidden', () => {
            });
            this.selectDom.onclick = () => {
                this.keydownSelect(this.searchResult.length > 0 ? this.searchResult.map(k => k.source) : this.data);
            }
            if (this.clearDom) {
                this.clearDom.onclick = () => {
                    this.clear();
                }
            }
            if (this.inputType === 'input' && this.searchDom) {
                this.searchDom.onclick = () => {
                    this.popupIns.state === 'hidden' ? this.popupIns.show() : null;
                }
            }
            for (let k of this.data) {
                if (~~k.disabled || k.children) {
                    continue;
                } else {
                    k.dom.onclick = () => {
                        this.clickSelect(k);
                        if (this.inputType === 'select-multiple' && this.options.least !== 0) {
                            if (this.data.filter(k => ~~k.selected).length < this.options.least) {
                                new axMessage({
                                    content: `至少选择${this.options.least}项!`,
                                    result: 'warning',
                                    iconShow: true,
                                }).show();
                                this.handlers.hasOwnProperty('least') ? this.emit('least', this.options.least) : null;
                                this.options.onLeast && this.options.onLeast.call(this, this.options.least);
                            }
                        }
                    }
                }
            }
            this.tagsIns.on('remove', (tags) => {
                tags.forEach(k => {
                    let item = axFindItem({ id: k.id, value: k.value }, this.data);
                    item ? this.selectedAttrToggle(item, false) : null;
                });
            });
            if (this.searchDom) {
                this.searchDom.oninput = axDebounce(() => {
                    let value = this.searchDom.value;
                    if (!value) {
                        this.reRenderList(this.data);
                        this.keydownSelect(this.data);
                    } else {
                        this.searchResult = axArrSearch(value, 'label', this.data, { fuzzy: this.options.search.fuzzy, reorder: this.options.search.reorder, limit: this.options.search.limit });
                        if (this.searchResult.length === 0) {
                            if (this.inputType === 'input') {
                                this.options.enterSelect ? this.searchDom.addEventListener('keyup', this.tagsIns.inputEdit) : null;
                                this.listDom.innerHTML = `<li message><i label>${axTplEngine(this.options.language.emptyAddable, { value: value })}</i></li>`;
                            } else {
                                this.listDom.innerHTML = `<li message><i label>${axTplEngine(this.options.language.empty, { value: value })}</i></li>`;
                            }
                            this.keydownSelect();
                        } else {
                            this.inputType === 'input' && this.options.enterSelect ? this.searchDom.removeEventListener('keyup', this.tagsIns.inputEdit) : null;
                            this.reRenderList(this.searchResult);
                            this.keydownSelect(this.searchResult.map(k => k.source));
                        }
                    }
                })
            }
            this.tagsIns.contentProxy.instance.on('complete', (data) => {
                this.selected = data.target.map(k => {
                    return { id: k.id, value: k.value }
                });
                this.value = data.target.map(k => k.value).join(this.options.separator);
                this.inputType === 'input' ? this.inputDom.value = this.value : null
                this.inputType !== 'select-single' && this.popupIns ? this.popupIns.popupPosition.update() : null;
                this.save();
            });
            /* 
            this.searchDom.addEventListener('input', axDebounce(() => {
                let value = this.searchDom.value;
                if (!value) {
                    this.reRenderList(this.data);
                    this.keydownSelect(this.data);
                } else {
                    this.searchResult = axArrSearch(value, 'label', this.data, { fuzzy: this.options.search.fuzzy, reorder: this.options.reorder, limit: this.options.search.limit });
                    if (this.searchResult.length === 0) {
                        if (this.inputType === 'input') {
                            this.options.enterSelect ? this.searchDom.addEventListener('keyup', this.tagsIns.inputEdit) : null;
                            this.listDom.innerHTML = `<li message><i label>${axTplEngine(this.options.language.emptyAddable, { value: value })}</i></li>`;
                        } else {
                            this.listDom.innerHTML = `<li message><i label>${axTplEngine(this.options.language.empty, { value: value })}</i></li>`;
                        }
                        this.keydownSelect();
                    } else {
                        this.inputType === 'input' && this.options.enterSelect ? this.searchDom.removeEventListener('keyup', this.tagsIns.inputEdit) : null;
                        this.reRenderList(this.searchResult);
                        this.keydownSelect(this.searchResult.map(k => k.source));
                    }
                }
            })
            ); */
        } else {
            this.selectDom.onclick = () => {
                if (!this.selectDom.classList.contains('ax-opened')) {
                    this.selectDom.classList.add('ax-opened');
                }
                this.searchDom && this.inputType === 'input' ? this.searchDom.focus() : null;
                document.addEventListener('click', this.bodyClickBlur, false);
            }
        }
    }
    select(data, callback) {
        if (axIsEmpty(data) || this.destroyed) {
            return this;
        }
        let dataType = axType(data),
            oldItems = [],
            absentItems = [],
            dataFun = (obj) => {
                let item = axFindItem(obj, this.data);
                if (item) {
                    oldItems.push(item);
                    let tagObj = { id: item.id, value: item.value || item.label };
                    if (!~~item.selected) {
                        if (this.inputType === 'select-single') {
                            this.toggleList(item, this.data);
                            this.tagsIns.clear();
                            this.tagsIns.add(tagObj);
                        } else {
                            this.selectedAttrToggle(item, !~~item.selected);
                            this.tagsIns.add(tagObj);
                        }
                    }
                } else {
                    absentItems.push(obj);
                }
            };
        if (dataType === 'Array') {
            data.forEach(k => {
                dataFun(k);
            });
        } else if (dataType === 'String') {
            data.split(',').forEach(k => {
                dataFun(k);
            });
        } else {
            dataFun(data);
        }
        if (absentItems.length > 0) {
            let absentStr = absentItems.map(k => k.label || k).join(',');
            if (this.options.absentAddable) {
                new axDialog(axExtend({
                    content: axTplEngine(this.options.language.absentAddable, { value: absentStr }),
                    confirm: {
                        callback: () => {
                            absentItems.forEach(k => {
                                this.add(k, 'end', (data) => {
                                    data.forEach(k => {
                                        k.dom.setAttribute('selected', '');
                                        k.selected = true;
                                        this.tagsIns.add({ id: k.id, value: k.value || k.label });
                                        oldItems.push(...data);
                                    });
                                });
                            });
                            this.handlers.hasOwnProperty('absentSelect') ? this.emit('absentSelect', oldItems) : null;
                            this.options.onAbsentSelect && this.options.onAbsentSelect.call(this, oldItems);
                        }
                    }
                }, this.options.dialog)).show();
            } else {
                new axMessage({
                    content: axTplEngine(this.options.language.absent, { value: absentStr }),
                    iconShow: true,
                }).show();
            }
        }
        this.handlers.hasOwnProperty('select') ? this.emit('select', oldItems) : null;
        this.options.onSave && this.options.onSave.call(this, oldItems);
        callback && callback.call(this, oldItems);
        return this;
    }
    unselect(data, callback) {
        if (this.destroyed) {
            return this;
        }
        let dataType = axType(data),
            oldItems = [],
            dataFun = (obj) => {
                let item = axFindItem(obj, this.data);
                if (item) {
                    oldItems.push(item);
                    let tagObj = { id: item.id, value: item.value };
                    if (~~item.selected) {
                        this.selectedAttrToggle(item, false);
                        this.tagsIns.remove(tagObj);
                    }
                } else {
                    this.tagsIns.remove(obj);
                }
            };
        if (dataType === 'Array') {
            data.forEach(k => {
                dataFun(k);
            });
        } else if (dataType === 'String') {
            data.split(',').forEach(k => {
                dataFun(k);
            });
        } else {
            dataFun(data);
        }
        this.handlers.hasOwnProperty('unselect') ? this.emit('unselect', oldItems) : null;
        this.options.onSave && this.options.onSave.call(this, oldItems);
        callback && callback.call(this, oldItems);
        return this;
    }
    arrAdd(data, placement) {
        data.forEach(k => {
            this.fillItem(k, this.listDom, placement);
            placement !== 'end' ? this.data.unshift(k) : this.data.push(k);
            k.dom.onclick = () => {
                this.clickSelect(k);
            }
        });
    }
    add(data, placement = 'end', callback) {
        if (axIsEmpty(data) || this.destroyed) {
            return this;
        }
        let dataType = axType(data),
            newItems = [],
            dataFun = (obj) => {
                let objType = axType(obj);
                if (objType === 'String') {
                    let strArr = obj.split(this.options.separator),
                        msgIns = new axMessage({ content: '', result: 'error', iconShow: true });
                    for (let k of strArr) {
                        if (this.data.find(i => i.label === k)) {
                            msgIns.update({ content: axTplEngine(this.options.language.addFail, { value: k }) }).show();
                            continue;
                        } else {
                            newItems.push({ id: this.maxIndex, label: k, value: k })
                            this.maxIndex++;
                        }
                    }
                } else if (objType === 'Object') {
                    if (axFindItem(obj, this.data)) {
                        msgIns.update({ content: axTplEngine(this.options.language.addFail, { value: obj.label }) }).show();
                    } else {
                        if (!obj.hasOwnProperty('id')) {
                            obj.id = this.maxIndex;
                            this.maxIndex++;
                        }
                        newItems.push(obj);
                    }
                }
            }
        if (dataType === 'Array') {
            data.forEach(k => {
                dataFun(k);
            });
        } else if (dataType === 'String') {
            dataFun(data);
        }
        if (this.options.onBeforeAdd) {
            this.options.onBeforeAdd.call(newItems);
        } else {
            this.arrAdd(newItems, placement);
        }
        this.handlers.hasOwnProperty('add') ? this.emit('add', newItems) : null;
        this.options.onAdd && this.options.onAdd.call(this, newItems);
        callback && callback.call(this, newItems);
        this.save();
        return this;
    }
    arrRemove(data) {
        if (data.length > 0) {
            data.forEach(k => {
                k.dom.remove();
            });
            this.data = this.data.filter(k => !data.includes(k));
        }
    }
    remove(data, callback) {
        if (axIsEmpty(data) || this.destroyed) {
            return this;
        }
        let dataType = axType(data),
            oldItems = [],
            dataFun = (obj) => {
                let item = axFindItem(obj, this.data);
                item ? oldItems.push(item) : null;
            }
        if (dataType === 'Array') {
            data.forEach(k => {
                dataFun(k);
            });
        } else if (dataType === 'String') {
            data.split(',').forEach(k => {
                dataFun(k);
            });
        } else {
            dataFun(data);
        }
        if (this.options.onBeforeRemove) {
            this.options.onBeforeRemove.call(oldItems);
        } else {
            this.arrRemove(oldItems);
        }
        this.handlers.hasOwnProperty('remove') ? this.emit('remove', oldItems) : null;
        this.options.onRemove && this.options.onRemove.call(this, oldItems);
        callback && callback.call(this, oldItems);
        this.save();
        return this;
    }
    clear(callback) {
        this.tagsIns.clear();
        for (let k of this.data) {
            if (~~k.selected) {
                Reflect.deleteProperty(k, 'selected');
                k.dom.removeAttribute('selected');
                k.node ? k.node.removeAttribute('selected') : null;
            }
        }
        this.handlers.hasOwnProperty('clear') ? this.emit('clear', '') : null;
        this.options.onClear && this.options.onClear.call(this);
        callback && callback.call(this);
        return this;
    }
    readonly(callback) {
        this.inputDom.setAttribute('readonly', '');
        this.selectDom.setAttribute('readonly', '');
        callback && callback.call(this);
        return this;
    }
    readable(callback) {
        this.inputDom.removeAttribute('readonly');
        this.selectDom.removeAttribute('readonly');
        callback && callback.call(this);
        return this;
    }
    disable(data, callback) {
        if (this.destroyed) {
            return this;
        }
        let dataType = axType(data),
            oldItems = [],
            dataFun = (obj) => {
                let item = axFindItem(obj, this.data);
                item ? oldItems.push(item) : null;
            }
        if (dataType === 'Array') {
            data.forEach(k => {
                dataFun(k);
            });
        } else if (dataType === 'String') {
            data.split(',').forEach(k => {
                dataFun(k);
            });
        } else {
            dataFun(data);
        }
        oldItems.forEach(k => {
            if (!~~k.disabled) {
                k.dom.setAttribute('disabled', '');
                k.disabled = true;
            }
        });
        this.handlers.hasOwnProperty('disabled') ? this.emit('disabled', oldItems) : null;
        this.options.onDisabled && this.options.onDisabled.call(this, oldItems);
        callback && callback.call(this, oldItems);
        this.save();
        return this;
    }
    enable(data, callback) {
        if (this.destroyed) {
            return this;
        }
        let dataType = axType(data),
            oldItems = [],
            dataFun = (obj) => {
                let item = axFindItem(obj, this.data);
                item ? oldItems.push(item) : null;
            }
        if (dataType === 'Array') {
            data.forEach(k => {
                dataFun(k);
            });
        } else if (dataType === 'String') {
            data.split(',').forEach(k => {
                dataFun(k);
            });
        } else {
            dataFun(data);
        }
        oldItems.forEach(k => {
            if (~~k.disabled) {
                k.dom.removeAttribute('disabled');
                Reflect.deleteProperty(k, 'disabled');
            }
        });
        this.handlers.hasOwnProperty('enabled') ? this.emit('enabled', oldItems) : null;
        this.options.onEnabled && this.options.onEnabled.call(this, oldItems);
        callback && callback.call(this, oldItems);
        this.save();
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        if (!props) {
            this.options.content = this.data;
            axLocalStorage.set(this.options.storageName, this.options);
        } else {
            axLocalStorage.set(this.options.storageName, props);
        }
        let localValue = axLocalStorage.get(this.options.storageName);
        this.handlers.hasOwnProperty('save') ? this.emit('save', localValue) : null;
        this.options.onSave && this.options.onSave.call(this, localValue);
        callback && callback.call(this, localValue);
        return this;
    }
    async update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.save();
        await this.init();
        this.handlers.hasOwnProperty('update') ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.selectDom.onclick = null;
        this.clearDom ? this.clearDom.onclick = null : null;
        this.searchDom ? this.searchDom.onclick = null : null;
        this.searchDom ? this.searchDom.removeEventListener('keyup', this.tagsIns.inputEdit) : null;
        document.removeEventListener('click', this.bodyClickBlur);
        this.contentXhr ? this.contentXhr.abort() : null;
        this.popupIns ? this.popupIns.destroy() : null;
        this.tagsIns.destroy();
        this.destroyed = true;
        this.handlers.hasOwnProperty('destroy') ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* 
document.querySelectorAll('[axSelect]').forEach(element => {
    new axSelect(element);
}); */
/*!
 * 插件：查看更多；使用方法：new axDropdown('#id',{参数})
 */
class axDropdown {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'list',
            content: '',
            node: 'a',
            nowrap: true,
            breakShow: true,
            arrowShow: true,
            grid: {
                enable: false,
                columns: 0,
                fenceShow: false,
            },
            onInit: '',
            onBeforeSet: '',
            onAfterSet: '',
            onConfirm: '',
            onUpdate: '',
            onUpdateContent: '',
            plugin: {
                value: '',
            },
            popup: {
                in: 'slideDown',
                out: 'slideUp',
                size: 'sm',
                placement: 'bottom-start',
                close: false,
            },
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.init();
        return this;
    }
    init() {
        axInstance.push(this, this.options.insName, 'dropdown');
        this.plugin = null;
        this.popup = null;
        this.value = '';
        this.valueArr = [];
        this.list = [];
        if (this.options.plugin.value) {
            this.initValue = this.options.plugin.value;
        } else {
            this.initValue = '';
        }
        if (this.targetDom.nodeName == 'INPUT' || this.targetDom.nodeName == 'TEXTAREA') {
            this.targetDom.setAttribute('readonly', '');
            if (this.targetDom.value) {
                this.options.plugin.value = this.targetDom.value;
                this.initValue = this.targetDom.value;
            } else {
                if (this.initValue) {
                    this.targetDom.value = this.initValue;
                }
            }
        }
        if (this.options.type === 'checkbox' || this.options.type === 'radio') {
            if (!axIsEmpty(this.options.content)) {
                this.options.plugin.children = this.options.content;
            }
            this.options.plugin.type = this.options.type;
            if (this.options.grid.enable) {
                this.options.plugin.display = 'grid';
                this.options.grid.columns ? this.options.plugin.columns = this.options.grid.columns : null;
                if (this.options.grid.fenceShow) {
                    this.options.plugin.parentClass = 'ax-fence';
                    this.options.plugin.childClass = 'ax-padding-left'
                    this.options.popup.padding = false;
                }
            } else {
                this.options.plugin.display = 'block';
            }
            this.plugin = new axCheckbox('', this.options.plugin);
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                content: this.plugin.parent,
                cancel: '',
                diy: {
                    text: '重置',
                    callback: () => {
                        this.plugin.reset();
                    }
                },
                confirm: {
                    type: 'prevent',
                    callback: () => {
                        this.value = this.plugin.getValues('string');
                        this.valueArr = this.plugin.getValues('array');
                        if (this.options.onBeforeSet) {
                            this.options.onBeforeSet.call(this, this.value);
                        } else {
                            this.setToHide(this.value);
                        }
                        this.options.onConfirm && this.options.onConfirm.call(this, this.value);
                        'confirm' in this.handlers ? this.emit('confirm', this.value) : null;
                    }
                }
            }));
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    if (this.targetDom.value != this.plugin.getValues('string')) {
                        this.updateValues(this.targetDom.value);
                    }
                }
            });
        } else if (this.options.type === 'list') {
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, { footerShow: false, padding: false }));
            let listDom = null;
            if (axType(this.options.content) === 'String') {
                if (axStrType(this.options.content)) {
                    listDom = axIdToDom(this.options.content);
                    this.popup.content.innerHTML = axIdToDom(this.options.content).innerHTML;
                } else {
                    this.popup.content.innerHTML = this.options.content;
                }
            } else if (axType(this.options.content).includes('HTML')) {
                this.popup.content.innerHTML = this.options.content.innerHTML;
            } else if (axType(this.options.content) === 'Array') {
                listDom = axAddElem('div', { class: 'ax-list-wrapper' });
                this.renderList(this.options.content, listDom);
                this.popup.content.innerHTML = '';
                this.popup.content.appendChild(listDom);
            }
        } else if (this.options.type === 'button') {
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, { footerShow: false, padding: false }));
            let listDom = axAddElem('div', { class: 'ax-list-wrapper' });
            this.renderList(this.options.content, listDom);
            this.list.forEach(k => {
                if (!k.props.disabled) {
                    k.dom.onclick = (e) => {
                        axPreventDefault(e);
                        this.value = k.props.value;
                        this.valueArr = [k.props.value];
                        k.dom.setAttribute('checked','');
                        this.list.filter(i => i.dom != k.dom).forEach(x => {
                            x.dom.removeAttribute('checked');
                        });
                        if (this.options.onBeforeSet) {
                            this.options.onBeforeSet.call(this, k.props.value)
                        } else {
                            this.setToHide(k.props.value);
                        }
                    }
                }
            });
            this.popup.content.innerHTML = '';
            this.popup.content.appendChild(listDom);
            this.initValue ? this.updateValues(this.initValue) : null;
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    this.updateValues(this.targetDom.value);
                }
            });
        } else if (this.options.type === 'text' || this.options.type === 'textarea') {
            this.options.plugin.type = this.options.type;
            this.options.content ? this.options.plugin.value = this.options.content : null;
            this.plugin = new axInput('', this.options.plugin);
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                content: this.plugin.parent,
                cancel: '',
                diy: {
                    text: '重置',
                    callback: () => {
                        this.plugin.set(this.initValue);
                    }
                },
                confirm: {
                    type: 'prevent',
                    callback: () => {
                        this.value = this.plugin.getValues('string');
                        this.valueArr = this.plugin.getValues('array');
                        if (this.options.onBeforeSet) {
                            this.options.onBeforeSet.call(this, this.value);
                        } else {
                            this.setToHide(this.value);
                        }
                        this.options.onConfirm && this.options.onConfirm.call(this, this.value);
                        'confirm' in this.handlers ? this.emit('confirm', this.value) : null;
                    }
                }
            }));
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    if (this.targetDom.value != this.plugin.getValues()) {
                        this.updateValues(this.targetDom.value);
                    }
                }
                setTimeout(() => {
                    let value = this.plugin.field.value;
                    this.plugin.field.value = '';
                    this.plugin.field.focus();
                    this.plugin.field.value = value;
                }, 100);
            });
            if (this.options.type === 'text') {
                this.plugin.field.onkeyup = (e) => {
                    if (e.code === 'Enter') {
                        this.popup.options.confirm.callback();
                    }
                }
            }
        } else if (this.options.type === 'number') {
            this.options.plugin.width = '100%';
            this.plugin = new axAmount('', this.options.plugin);
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                content: this.plugin.parent,
                cancel: '',
                diy: {
                    text: '重置',
                    callback: () => {
                        this.plugin.reset();
                    }
                },
                confirm: {
                    type: 'prevent',
                    callback: () => {
                        this.value = this.plugin.value;
                        this.valueArr.push(this.plugin.value);
                        if (this.options.onBeforeSet) {
                            this.options.onBeforeSet.call(this, this.value);
                        } else {
                            this.setToHide(this.value);
                        }
                        this.options.onConfirm && this.options.onConfirm.call(this, this.value);
                        'confirm' in this.handlers ? this.emit('confirm', this.value) : null;
                    }
                }
            }));
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    if (this.targetDom.value != this.plugin.value) {
                        this.updateValues(this.targetDom.value);
                    }
                }
            });
            setTimeout(() => {
                let value = this.plugin.field.value;
                this.plugin.field.value = '';
                this.plugin.field.focus();
                this.plugin.field.value = value;
            }, 100);
            this.plugin.field.onkeyup = (e) => {
                if (e.code === 'Enter') {
                    this.popup.options.confirm.callback();
                }
            }
        } else if (this.options.type === 'switch') {
        } else if (this.options.type === 'html') {
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                footerShow: false,
                content: this.options.content,
            }));
        }
        this.setAttribute();
        this.options.onInit && this.options.onInit.call(this);
    }
    setAttribute() {
        if (this.options.arrowShow) {
            if (this.targetDom && !this.targetDom.querySelector('.ax-at-right')) {
                let arrow = axAddElem('i', { class: 'ax-dropdown-arrow' });
                this.targetDom.appendChild(arrow);
            }
        }
        this.popup.targetDom.classList.add('ax-dropdown');
    }
    setToHide(value, callback) {
        value = value || this.value;
        if (this.targetDom.nodeName === 'INPUT') {
            this.targetDom.value = value;
        }
        this.options.onAfterSet && this.options.onAfterSet.call(this, value);
        'set' in this.handlers ? this.emit('set', value) : null;
        callback && callback.call(this, value);
        this.popup.hide();
    }
    updateToShow(value) {
        this.popup.show();
        setTimeout(() => {
            this.updateValues(value);
        }, 100);
    }
    updateValues(value) {
        if (['checkbox', 'radio', 'text', 'textarea', 'number'].includes(this.options.type)) {
            this.plugin.set(value);
        } else if (this.options.type === 'button') {
            let str = ''
            if (Array.isArray(value)) {
                str = value[0];
            } else {
                str = value;
            }
            this.list.forEach(k => {
                if (k.props.value === str) {
                    k.dom.setAttribute('checked','');
                } else {
                    k.dom.removeAttribute('checked');
                }
            });
        }
    }
    getValues(type = 'string',) {
        if (type === 'string') {
            return this.value;
        } else if (type === 'array') {
            return this.valueArr;
        }
    }
    renderList(arr, parent) {
        if (this.options.grid.enable) {
            let classNames = 'ax-grid';
            this.options.grid.columns ? classNames += ` ax-grid-${this.options.grid.columns}` : null;
            this.options.grid.fenceShow ? classNames += ' ax-fence' : null;
            axClass.add(parent, classNames);
        }
        arr.forEach((k, i) => {
            let outer = axAddElem(this.options.node, { class: 'ax-bulletin ax-hover', ...k.props }, `<div class="ax-bulletin-body"></div>`),
                inner = outer.querySelector('.ax-bulletin-body'),
                caption = null;
            k.disabled ? outer.setAttribute('disabled', '') : null;
            if (this.options.node === 'a') {
                if (this.options.type === 'list') {
                    outer.target = k.target ? k.target : '_blank';
                    outer.href = k.url ? k.url : '###';
                } else {
                    outer.href = '###';
                }
            }
            if (this.options.nowrap) {
                if (this.options.node != 'a' && k.url) {
                    caption = axAddElem('a', { caption: '' }, k.label)
                    if (this.options.type === 'list') {
                        caption.target = k.target ? k.target : '_blank';
                        caption.href = k.url ? k.url : '###';
                    } else {
                        caption.href = '###';
                    }
                } else {
                    caption = axAddElem('i', { caption: '' }, k.label);
                }
                inner.appendChild(caption);
            } else {
                inner.textContent = k.label;
            }
            if (!axIsEmpty(k.prefix)) {
                if (k.prefix.type === 'legend') {
                    inner.insertAdjacentElement('beforebegin', axAddElem('i', { class: 'ax-iconfont ' + k.prefix.data,legend:'' }));
                } else if (k.prefix.type === 'avatar') {
                    inner.insertAdjacentElement('beforebegin', axAddElem('i', { avatar: '' },`<img src="${k.prefix.data}" />`));
                }
                else if (k.prefix.type === 'image') {
                    inner.insertAdjacentElement('beforebegin', axAddElem('i', { image: '' }, `<img src="${k.prefix.data}"/>`));
                }
            }
            if (k.suffix) {
                inner.insertAdjacentElement('afterend', axAddElem('i', { arrow: '' }, k.suffix));
            }
            parent.appendChild(outer);
            if (!this.options.grid.enable && this.options.breakShow && i + 1 != this.options.content.length) {
                parent.insertAdjacentHTML('beforeend', '<hr/>');
            }
            this.list.push({ props: k, dom: outer })
            if (!k.disabled) {
                k.callback && k.callback(outer, k);
            }
        });
    }
    update(setting, callback) {
        this.popup.targetDom.remove();
        this.popup.destroy();
        this.options.content = axExtend(this.options.content, setting);
        this.init();
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update') : null;
        callback && callback.call(this);
        return this;
    }
    updateContent(data, callback) {
        this.popup.targetDom.remove();
        this.popup.destroy();
        this.options.content = data;
        this.init();
        this.options.onUpdateContent && this.options.onUpdateContent.call(this);
        'updateContent' in this.handlers ? this.emit('updateContent') : null;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        this.popup.show();
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        this.popup.hide();
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axDropdown]').forEach(element => {
        new axDropdown(element);
    });
})(); */
/*!
* 插件：表单数量步进增减；使用方法：new axAmount('#id',{参数})
*/
const axAmounts = [];
class axAmount {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            insName: '',
            width: '',
            placeholder: '输入数量',
            value: '',
            min: '',
            max: '',
            step: 1,
            precision: 0,
            rule: '',
            disabled: false,
            increase: true,
            decrease: true,
            cookie: '',
            onInit: '',
            onMined: '',
            onMaxed: '',
            onUpdated: '',
            onChanged: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.value = '';
        this.activeIn = true;
        this.activeDe = true;
        this.init();
    }
    init() {
         axInstance.push(this, this.options.insName, 'amount');
        if (this.options.min !== '' && this.options.mam !== '' && this.options.min > this.options.mam) {
            console.error('The minimum value is greater than the maximum value!');
            return false;
        }
        this.createSkeleton();
        this.ruleToSet();
        this.initValue();
        this.getCookie();
        this.rawValue = this.value;
        this.setAttribute();
        let eventKey = (e) => {
            if (e.code === 'ArrowUp' || e.code === 'ArrowRight') {
                e.preventDefault();
                eventIncrease();
            } else if (e.code === 'ArrowLeft' || e.code === 'ArrowDown') {
                e.preventDefault();
                eventDecrease();
            }
        }
        let eventIncrease = () => {
            if (!this.activeDe) {
                this.options.decrease = true;
                this.decrease.removeAttribute('disabled');
            }
            let val = Number(this.field.value),
                old = Number(this.field.value);
            if (this.options.max === '') {
                val = val + this.options.step;
            } else if (this.options.max !== '' && val < this.options.max) {
                val = val + this.options.step;
            }
            if (this.options.max !== '' && ((val + this.options.step) > this.options.max)) {
                this.options.increae = false;
                this.increase.setAttribute('disabled', 'true');
                this.activeIn = false;
                this.options.onMaxed && this.options.onMaxed.call(this);
                'maxed' in this.handlers ? this.emit('maxed', '') : null;
            }
            this.field.value = val.toFixed(this.options.precision);
            this.value = this.field.value;
            this.setCookie();
            if (this.field.value > old) {
                this.options.onChanged && this.options.onChanged.call(this, old, this.field.value);
                'changed' in this.handlers ? this.emit('changed', old, this.field.value) : null;
            }
        }
        let eventDecrease = () => {
            if (!this.activeIn) {
                this.options.increae = true;
                this.increase.removeAttribute('disabled');
            }
            let val = Number(this.field.value),
                old = Number(this.field.value);
            if (this.options.min === '') {
                val = val - this.options.step;
            } else if (this.options.min !== '' && val > this.options.min) {
                val = val - this.options.step;
            }
            if (this.options.min !== '' && ((val - this.options.step) < this.options.min)) {
                this.options.decreae = false;
                this.decrease.setAttribute('disabled', 'true');
                this.activeDe = false;
                this.options.onMined && this.options.onMined.call(this);
                'mined' in this.handlers ? this.emit('mined', '') : null;
            }
            this.field.value = val.toFixed(this.options.precision);
            this.value = this.field.value;
            this.setCookie();
            if (this.field.value < old) {
                this.options.onChanged && this.options.onChanged.call(this, old, this.field.value);
                'changed' in this.handlers ? this.emit('changed', old, this.field.value) : null;
            }
        }
        if (this.options.disabled || this.field.hasAttribute('disabled')) {
            this.increase.removeEventListener('click', eventIncrease, false);
            this.decrease.removeEventListener('click', eventDecrease, false);
            this.field.setAttribute('disabled', '');
        } else {
            if (!this.options.increase || this.increase.hasAttribute('disabled')) {
                this.increase.removeEventListener('click', eventIncrease, false);
                this.increase.setAttribute('disabled', '');
            } else {
                this.increase.addEventListener('click', eventIncrease, false);
                this.field.addEventListener('keydown', eventKey, false);
            }
            if (!this.options.decrease || this.decrease.hasAttribute('disabled')) {
                this.decrease.removeEventListener('click', eventDecrease, false);
                this.decrease.setAttribute('disabled', '');
            } else {
                this.decrease.addEventListener('click', eventDecrease, false);
                this.field.addEventListener('keydown', eventKey, false);
            }
            this.field.onblur = () => {
                this.value =  this.correctValue(Number(this.field.value));
                this.field.value = this.value;
                this.setCookie();
            }
            this.field.addEventListener('keyup',(e)=>{
                if (e.code === 'Enter') {
                    this.field.blur();
                }
            },false)
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    ruleToSet() {
        switch (this.options.rule) {
            case 'currency':
                this.options.min = 0.00; this.options.max = ''; this.options.step = 0.01; this.options.precision = 2;
                break;
            case 'quantity':
                this.options.min = 1; this.options.max = 999; this.options.step = 1; this.options.precision = 0;
                break;
            case 'percent':
                this.options.min = 0; this.options.max = 100; this.options.step = 1; this.options.precision = 0;
                break;
            case 'month':
                this.options.min = 1; this.options.max = 12; this.options.step = 1; this.options.precision = 0;
                break;
            case 'day':
                this.options.min = 1; this.options.max = 31; this.options.step = 1; this.options.precision = 0;
                break;
            case 'hour':
                this.options.min = 0; this.options.max = 24; this.options.step = 1; this.options.precision = 0;
                break;
            case 'minute':
                this.options.min = 0; this.options.max = 59; this.options.step = 1; this.options.precision = 0;
                break;
            case 'second':
                this.options.min = 0; this.options.max = 59; this.options.step = 1; this.options.precision = 0;
                break;
        }
    }
    initValue() {
        if (this.options.value !== '') {
            if (this.options.min !== '' && this.options.value < this.options.min) {
                this.value = this.options.min;
            } else if (this.options.max !== '' && this.options.value > this.options.max) {
                this.value = this.options.max;
            } else {
                this.value = this.options.value;
            }
            this.field.value = this.value;
        } else {
            if (this.field.value) {
                if (this.options.min !== '' && this.options.min > Number(this.field.value)) {
                    this.field.value = this.options.min;
                }
                if (this.options.max !== '' && this.options.max < Number(this.field.value)) {
                    this.field.value = this.options.max;
                }
                this.value = this.field.value;
            }
        }
    }
    getCookie() {
        let cookieValue = axCookie.get(this.options.cookie);
        if (this.options.cookie && cookieValue) {
            this.value = cookieValue;
            this.field.value = cookieValue;
        }
    }
    setCookie() {
        if (this.options.cookie) {
            axCookie.set(this.options.cookie, Number(this.field.value));
        }
    }
    setAttribute() {
        if (this.options.disabled) {
            this.field.setAttribute('disabled', 'true');
            this.increase.setAttribute('diabled', 'true');
            this.decrease.setAttribute('diabled', 'true');
        }
        if (!this.options.increase) {
            this.increase.setAttribute('diabled', 'true');
        }
        if (!this.options.decrease) {
            this.decrease.setAttribute('diabled', 'true');
        }
        !this.field.getAttribute('placeholder') ? this.field.setAttribute('placeholder', this.options.placeholder) : null;
        this.options.width ? this.parent.style.width = this.options.width : null;
    }
    createSkeleton() {
        if (!this.targetDom || this.targetDom.nodeName === 'INPUT') {
            this.parent = axAddElem('div', { class: 'ax-amount' });
            this.field = this.targetDom ? this.targetDom : axAddElem('input', { type: 'text' });
            this.decrease = axAddElem('a', { href: '###', decrease: '' }, '<i class="ax-iconfont ax-icon-minus"></i>');
            this.increase = axAddElem('a', { href: '###', increase: '' }, '<i class="ax-iconfont ax-icon-plus"></i>');
            this.field.insertAdjacentElement('beforeBegin', this.parent);
            this.parent.appendChild(this.field);
            this.parent.appendChild(this.decrease);
            this.parent.appendChild(this.increase);
        } else {
            this.parent = this.targetDom;
            this.field = this.parent.querySelector('input');
            this.increase = this.parent.querySelector('[increase]');
            this.decrease = this.parent.querySelector('[decrease]');
        }
    }
    correctValue(value){
        if (this.options.min !== '' && value < this.options.min) {
            value = this.options.min;
        } else if (this.options.max !== '' && value > this.options.max) {
            value = this.options.max;
        }
        return value;
    }
    set(value, callback) {
        value =  this.correctValue(value);
        this.field.value = value;
        this.value = value;
        if (this.options.cookie) {
            this.value = axCookie.set(this.options.cookie, value);
        }
        callback && callback.call(this, value);
        return this;
    }
    reset(callback) {
        this.set(this.rawValue);
        callback && callback.call(this, this.rawValue);
        if (this.options.cookie) {
            this.value = axCookie.set(this.options.cookie, this.rawValue);
        }
        return this;
    }
    update(setting, callback) {
        this.options = axExtend(this.options, setting);
        this.options.onUpdated && this.options.onUpdated.call(this);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* 
document.querySelectorAll('[axAmount]').forEach(element => {
    new axAmount(element);
}); */
/*!
* 插件：页面社交分享；使用方法：new axShare('#id',{参数})
*/
class axShare {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            source: '',
            title: '',
            des: '',
            url: window.location.href,
            image: '',
            key: '',
            origin: window.location.origin,
            qrTitle: '<p>在微信里点击“发现”，再点击“扫一扫，”<br />便可将本文分享至朋友圈。</p>',
            qrSize: 180,
            newPage: true,
            dialogText: '确定分享本页面？',
            onShare: '',
        }, options, this.targetDom,'axShare');
        this.handlers = {};
        if (!this.options.source) {
            this.options.source = document.querySelector('meta[name="site"]') || document.title;
        }
        if (!this.options.title) {
            this.options.title = document.querySelector('meta[name="title"]') || document.title;
        }
        if (!this.options.des) {
            this.options.des = document.querySelector('meta[name="description"]') || '';
        }
        if (!this.options.image) {
            this.options.image = (document.images[0] || 0).src || '';
        }
        this.init();
    }
    init() {
          axInstance.push(this, this.options.insName, 'share');
        this.shareUrl = {
            qzone: 'http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + this.options.url + '&title=' + this.options.title + '&desc=' + this.options.des + '&summary=' + this.options.summary + '&site=' + this.options.source + '&pics=' + this.options.image,
            youdao: 'http://note.youdao.com/memory/?title=' + this.options.title + '&pic=' + this.options.image + '&summary=' + this.options.des + '&url=' + this.options.url,
            qq: 'http://connect.qq.com/widget/shareqq/index.html?url=' + this.options.url + '&title=' + this.options.title + '&source=' + this.options.source + '&desc=' + this.options.des + '&pics=' + this.options.image + '&summary=' + this.options.summary,
            weibo: 'https://service.weibo.com/share/share.php?url=' + this.options.url + '&title=' + this.options.title + '&pic=' + this.options.image + '&appkey=' + this.options.key,
            daoban: 'http://shuo.douban.com/!service/share?href=' + this.options.url + '&name=' + this.options.title + '&text=' + this.options.des + '&image=' + this.options.image + '&starid=0&aid=0&style=11',
            linkedin: 'http://www.linkedin.com/shareArticle?mini=true&ro=true&title=' + this.options.title + '&url=' + this.options.url + '&summary=' + this.options.summary + '&source=' + this.options.source + '&armin=armin',
            facebook: 'https://www.facebook.com/sharer/sharer.php?u=' + this.options.url,
            twitter: 'https://twitter.com/intent/tweet?text=' + this.options.title + '&url=' + this.options.url + '&via=' + this.options.origin,
            google: 'https://plus.google.com/share?url=' + this.options.url,
            pinterest: 'https://www.pinterest.com/pin/create/button/?url=' + this.options.url + '&description=' + this.options.des + '&media=' + this.options.image,
            tumblr: 'https://www.tumblr.com/widgets/share/tool?shareSource=legacy&canonicalUrl=&url=' + this.options.url + '&title=' + this.options.title,
        }
        for (let k in this.shareUrl) {
            this.changeHref(k);
        }
        if (this.targetDom.querySelector('[share="wechat"]')) {
            if(typeof QRCode == 'undefined'){
                console.error('Please import the QRCode plugin first!');
                return false;
            }else{
                this.createQrcode()
            }
        }
    }
    changeHref(name) {
        let a = this.targetDom.querySelector('[share=' + name + ']');
        if (a) {
            if (a.hasAttribute('confirm')) {
                a.addEventListener('click', (e)=>{
                    axPreventDefault(e);
                    new axDialog({
                        content: this.options.dialogText,
                        footerType: 'right',
                        confirm: {
                            callback: ()=> {
                                if (this.options.newPage) {
                                    window.open(this.shareUrl[name]);
                                    this.hide();
                                } else {
                                    window.location.href = this.shareUrl[name];
                                }
                                this.options.onShare && this.options.onShare.call(this, name);
                            }
                        }
                    }).show();
                }, false);
            } else {
                if (this.options.newPage) {
                    a.setAttribute('target', '_blank');
                } else {
                    a.removeAttribute('target')
                }
                a.setAttribute('href', this.shareUrl[name]);
                a.addEventListener('click', (e) => {
                    this.options.onShare && this.options.onShare.call(this, name);
                }, false);
            }
        }
    }
    createQrcode() {
        let wechat = this.targetDom.querySelector('[share="wechat"]')
        if (wechat.length === 0) {
            return false;
        }
        let qr = axAddElem('div', { class: 'ax-qrcode' });
        let qrBody = axAddElem('div', { class: 'ax-qrcode-body' });
        let qrTitle = axAddElem('div', { class: 'ax-qrcode-title' }, this.options.qrTitle);
        new QRCode(qrBody, { text: this.options.url, width: this.options.qrSize, height: this.options.qrSize });
        qr.appendChild(qrBody);
        qr.appendChild(qrTitle);
        new axPopup(wechat, {
            content: qr,
            padding: true,
            placement: 'bottom',
            close: false,
            footerShow: false,
        });
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axShare]').forEach(element => {
        new axShare(element);
    });
})(); */
/*!
* 插件：自动完成插件；使用方法：new axComplete('#id',{参数})
*/
class axComplete {
    constructor(elem, options) {
        this.inputDom = axIdToDom(elem);
        if (!this.inputDom) {
            return false
        }
        this.options = axExtend({
            insName: '',
            content: '',
            async: '',
            ajaxType: 'post',
            fuzzy: true,
            reorder: false,
            limit: 20,
            ignore: true,
            keys: 'label',
            template: '',
            className: '',
            breakShow: true,
            msgShow: true,
            msgPlace: 'inside',
            highlight: true,
            fill: 'label',
            idStart: 0,
            language: {
                message: '共有<# this.value #>个结果符合要求',
            },
            popup: { rel: '', triggerRel: 'click' },
            onInit: '',
            onSearch: '',
            onSelected: '',
            onUpdate: '',
            onDestroy: '',
        }, options, this.inputDom, this.constructor.name);
        /* data:[{id:0,label:'张三',value:'张三',age:''},
          {id:1,label:'李四',value:'李四',age:''},
          {id:2,label:'王五',value:'王五',age:''},] 
          keys:['label','age']
          */
        this.handlers = {};
        this.inputEdit = () => {
            let value = this.inputDom.value;
            this.search(value);
        }
        this.init();
        return this;
    }
    beforeInit() {
        this.inputDom.removeEventListener('input', this.inputEdit);
        this.popupIns ? (this.popupIns.destroy(), this.popupIns = null) : null;
        this.contentXhr ? this.contentXhr.abort() : null;
    }
    async init() {
        this.beforeInit();
        axInstance.push(this, this.options.insName, 'complete');
        this.destroyed = false;
        this.createSkeleton();
        this.setAttribute();
        this.popupIns = new axPopup(this.inputDom, axExtend({
            content: this.wrapperDom,
            trigger: 'input',
            padding: false,
            placement: 'bottom-start',
            close: false,
            footerShow: false,
        }, this.options.popup));
        this.popupIns.on('show', () => {
            let value = this.inputDom.value;
            this.inputDom.value = '';
            this.inputDom.focus();
            this.inputDom.value = value;
        });
        this.popupIns.on('hidden', () => {
            !this.inputDom.value ? this.reset() : null;
        });
        this.inputDom.addEventListener('input', this.inputEdit, false);
        this.rawData = [];
        this.sliceData = [];
        this.filterData = [];
        let contentType = axType(this.options.content);
        if (contentType === 'String' && this.options.async) {
            await this.getAsyncData(this.options.async, '', (data) => {
                this.getRawData(data);
            });
        } else {
            this.getRawData(this.options.content);
        }
        this.handlers.hasOwnProperty('init') ? this.emit('init', '') : null;
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createSkeleton() {
        this.wrapperDom = axAddElem('div', { class: 'ax-complete' });
        this.listDom = axAddElem('ul');
        this.wrapperDom.appendChild(this.listDom);
        this.msgDom = axAddElem('div', { class: 'ax-complete-msg' }, axTplEngine(this.options.language.message, { value: 0 }));
        if (this.options.msgShow) {
            if (this.options.msgPlace === 'newline') {
                this.inputDom.insertAdjacentElement('afterend', this.msgDom);
            } else if (axStrType(this.options.msgPlace)) {
                axIdToDom(this.options.msgPlace).appendChild(this.msgDom);
            } else {
                this.wrapperDom.insertAdjacentElement('afterbegin', this.msgDom);
            }
        }
    }
    setAttribute() {
        if (this.options.className) {
            axClass.add(this.wrapperDom, this.options.className);
        }
        this.inputDom.setAttribute('autocomplete', 'off');
    }
    getRawData(content) {
        let contentType = axType(content);
        if (contentType === 'String') {
            if (axStrType(content)) {
                this.rawData = axSelectToArr(content, this.options.idStart).data;
            } else {
                let splitArr = axSplitToArr(content);
                this.rawData = splitArr.map((k, i) => {
                    return { id: this.options.idStart + i, label: k, value: k }
                });
            }
        } else if (contentType === 'Array') {
            if (typeof content[0] == 'object') {
                content.forEach((k, i) => {
                    !k.hasOwnProperty('id') ? k.id = this.options.idStart + i : null;
                    !k.hasOwnProperty('value') ? k.value = k.label : null;
                });
                this.rawData = content;
            } else if (typeof content[0] == 'string') {
                this.rawData = content.map((k, i) => {
                    return { id: this.options.idStart + i, label: k, value: k }
                });
            }
        }
        this.rawData.forEach(k => {
            k.dom = axStrToDom(axTplEngine(this.getTemplate(), k));
            k.dom.onclick = () => {
                this.inputDom.value = k[this.options.fill];
                this.popupIns.hide();
                this.handlers.hasOwnProperty('selected') ? this.emit('selected', k) : null;
                this.options.onSelected && this.options.onSelected.call(this, k);
            }
        });
        this.sliceData = this.getSliceData();
        this.reRenderList(this.sliceData);
    }
    getSliceData() {
        return this.options.limit > 0 ? this.rawData.slice(0, this.options.limit) : this.rawData;
    }
    getFilterData(value) {
        this.filterData = axArrSearch(value, this.options.keys, this.rawData, { fuzzy: this.options.fuzzy, reorder: this.options.reorder, limit: this.options.limit, ignore: this.options.ignore });
    }
    getAsyncData(type = 'json', value, callback) {
        return axAjax({
            data: type === 'sql' ? { value: axSplitToArr(value, ' ', 'one').join(','), keys: this.options.keys, fuzzy: this.options.fuzzy, limit: this.options.limit, reorder: this.options.reorder, ignore: this.options.ignore } : '',
            type: this.options.ajaxType,
            url: this.options.content,
            opened: (response) => {
                this.contentXhr = response.xhr;
            },
            success: (response) => {
                if (axIsEmpty(response.content)) {
                    console.warn(`No data obtained from the ${type === 'sql' ? 'database' : 'json'}!`);
                    return false;
                }
                this.listDom.innerHTML = '';
                callback && callback(response.content);
            }
        }, this.listDom);
    }
    reRenderList(data) {
        this.listDom.innerHTML = '';
        if (axIsEmpty(data)) {
            return false;
        }
        let fragment = document.createDocumentFragment();
        if (data[0].hasOwnProperty('weight')) {
            data.forEach(k => {
                if (this.options.highlight) {
                    let pattern = new RegExp(k.keys.join('|'), 'g'),
                        labelDom = k.source.dom.querySelector('[label]') || k.source.dom.querySelector('[caption]');
                    labelDom.innerHTML = labelDom.innerHTML.replace(/<[^>]+>/g, '').replace(pattern, match => `<s>${match}</s>`);
                }
                fragment.appendChild(k.source.dom);
            });
            this.output = data;
        } else {
            data.forEach(k => {
                if (this.options.highlight) {
                    let labelDom = k.dom.querySelector('[label]') || k.dom.querySelector('[caption]');
                    labelDom.innerHTML = labelDom.innerHTML.replace(/<[^>]+>/g, '');
                }
                fragment.appendChild(k.dom);
            });
        }
        this.listDom.appendChild(fragment);
    }
    getTemplate() {
        let tpl = `<li>
                        ${this.options.breakShow ? '<hr/>' : ''}
                        <div class="ax-bulletin ax-hover">
                            <div class="ax-bulletin-body"><i caption><# this.label #></i></div>
                        </div>
                    </li>
                        `;
        return this.options.template || tpl;
    }
    async search(value, callback) {
        if (this.destroyed) {
            return this;
        }
        let arr = [];
        if (value) {
            if (typeof this.options.content === 'String' && this.options.async === 'sql') {
                await this.getAsyncData('sql', value, (data) => {
                    this.getRawData(data);
                    this.popupIns.show();
                    arr = this.sliceData;
                    this.msgDom.innerHTML = axTplEngine(this.options.language.message, { value: arr.length });
                });
            } else {
                this.getFilterData(value);
                if (this.filterData.length === 0) {
                    this.listDom.innerHTML = '';
                } else {
                    this.reRenderList(this.filterData);
                    this.popupIns.show();
                    arr = this.filterData;
                }
            }
            arr.length === 0 && (this.options.msgPlace !== 'inside' || !this.options.msgShow) ? this.popupIns.hide() : null;
            this.msgDom.innerHTML = axTplEngine(this.options.language.message, { value: arr.length });
        } else {
            this.popupIns.hide();
        }
        this.handlers.hasOwnProperty('search') ? this.emit('search', arr) : null;
        this.options.onSearch && this.options.onSearch.call(this, arr);
        callback && callback.call(this, data);
        return this;
    }
    async update(content, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.content = content;
        if (typeof this.options.content === 'String' && this.options.async === 'sql') {
            await this.getAsyncData('sql', '', (data) => {
                this.getRawData(data);
            });
        } else {
            this.getRawData(this.options.content);
        }
        this.handlers.hasOwnProperty('update') ? this.emit('update', this.sliceData) : null;
        this.options.onUpdate && this.options.onUpdate.call(this, this.sliceData);
        callback && callback.call(this, this.sliceData);
        return this;
    }
    async reset(callback) {
        if (this.destroyed) {
            return this;
        }
        this.inputDom.value = '';
        if (typeof this.options.content === 'String' && this.options.async === 'sql') {
            await this.getAsyncData('sql', '', (data) => {
                this.getRawData(data);
            });
        } else {
            this.getRawData(this.sliceData);
        }
        this.handlers.hasOwnProperty('reset') ? this.emit('reset', this.sliceData) : null;
        this.options.onReset && this.options.onReset.call(this, this.sliceData);
        callback && callback.call(this, this.sliceData);
        return this;
    }
    destroy(callback) {
        this.beforeInit();
        this.destroyed = true;
        this.contentXhr ? this.contentXhr.abort() : null;
        this.handlers.hasOwnProperty('destroy') ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* document.querySelectorAll('[axComplete]').forEach(element => {
    new axComplete(element);
});
 */
/*!
 * 插件：页签切换；使用方法：axDate('#id',{参数})
 */
class axDate {
    constructor(elem, options) {
        this.inputDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            storageName: '',
            content: '',
            format: 'YYYY/MM/DD',
            mode: 'single',
            maxSelection: 100,
            rows: 1,
            cols: 1,
            minDate: '',
            maxDate: '',
            flexible: false,
            footerShow: true,
            nowHide: false,
            nowShow: false,
            clearShow: true,
            closeShow: true,
            cancelShow: false,
            resultShow: false,
            confirmHide: true,
            autoFill: false,
            autoCorrect: true,
            forceSelect: false,
            language: {
                month: ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'],
                week: ['一', '二', '三', '四', '五', '六', '日'],
                year: {
                    prev: '上一页',
                    next: '下一页',
                    placeholder: '输入年份',
                },
                range: '至',
                unit: {
                    Y: '年',
                    M: '月',
                    D: '日',
                    h: '时',
                    m: '分',
                    s: '秒',
                },
                time: {
                    select: '时间选择',
                    start: '开始时间',
                    end: '结束时间'
                },
                button: {
                    clear: '清除',
                    close: '关闭',
                    cancel: '清除并关闭',
                    now: '现在',
                    confirm: '确定',
                },
                toolTip: {
                    restore: '还原',
                    reset: '归零',
                    now: '现在',
                    close: '关闭',
                },
                empty: '<i class="ax-color-ignore">还未选择日期!</i>',
                message: {
                    requireTwoValue: '区间模式至少需要选择两个日期！',
                    requireYearFormat: '请填入3或4位年份数字!',
                    requireOneSelected: '请至少选择一个日期!',
                },
                noEvent: '<i class="ax-color-ignore">今天没有需要安排的事项!</i>',
            },
            weekStart: 'monday',
            separator: ',',
            buttonDom: '',
            positionDom: '',
            display: 'popup',
            toDrawer: true,
            bubble: {},
            fillNow: false,
            next: '',
            lunar: {
                enable: false,
                handler: '',
                map: {},
                template: `<div>农历：<#this.animal#>年 <#this.month#><#this.date#></div>
                        <div>干支：<#this.gzYear#>年 <#this.gzMonth#>月 <#this.gzDate#>日</div>
                        <div>节日/节气：<#this.term#> <#this.lunarFestival#> <#this.solarFestival#></div>
                        `,
                arrange: ['solarFestival', 'lunarFestival', 'term', 'date'],
                tags: [],
            },
            event: {
                enable: false,
                display: 'popup',
                template: `<div label><#this.label#></div><div content><#this.content#></div>`,
                list: [],
            },
            menu: [],
            onInit: '',
            onClear: '',
            onSet: '',
            onSetRange: '',
            onCreatePanels: '',
            onCancel: '',
            onConfirm: '',
            onSetTime: '',
            onUpdate: '',
            onDestroy: '',
            onSave: '',
        }, options, this.inputDom, this.constructor.name);
        this.handlers = {};
        this.triggerShow = () => {
            this.active(this);
        }
        this.content = [];
        this.raw = [];
        this.monthStr = `
            <li><span content><i label>01${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>02${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>03${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>04${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>05${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>06${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>07${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>08${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>09${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>10${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>11${this.options.language.unit.M}</i></span></li>
            <li><span content><i label>12${this.options.language.unit.M}</i></span></li>
        `;
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'date');
        this.destroyed = false;
        this.data = {
            startDate: '',
            selectedDates: [],
            type: '',
            panels: [
                /* {
                    yearDom: '',
                    monthDom: '',
                    year:'',
                    month:'',
                    listDom: '',
                    list: [
                        {
                            value: {},
                            wrapperDom:'',
                            label: '',
                            labelDom: '',
                            contentDom:'',
                            busy:'',
                            tag:'',
                            lunar:'',
                            lunarDom:'',
                            term:'',
                            selected: '',
                            disabled: '',
                            exceed: '',
                            workDay:'',
                            restDay:'',
                            range:'',
                        }
                    ],
                } */
            ],
            menu: [],
            year: {
                panelDom: '',
                listDom: '',
                list: []
            },
            /*
            year:{
                panelDom:'',
                prevDom:'',
                nextDom:'',
                inputDom:'',
                goDom:'',
                listDom:'',
                list:[
                    {
                        value:'',
                        wrapperDom:'',
                        label:'',
                        labelDom:'',
                        contentDom:'',
                        disabled:'',
                    },
                ]
            }
            */
            month: {
                panelDom: '',
                listDom: '',
                list: []
            },
            /*
            month:{
                panelDom:'',
                listDom:'',
                list:[
                    {
                        value:'',
                        wrapperDom:'',
                        label:'',
                        labelDom:'',
                        contentDom:'',
                        disabled:'',
                    },
                ]
            }
            */
            time: [],
            /*  time: [
                 {
                    value:{},
                    panelDom:'',
                    closeDom:'',
                    resetDom:'',
                    restoreDom:'',
                     hh: [
                         {
                             value:'',
                             wrapperDom:'',
                             contentDom: '',
                             selected: '',
                             disabled: '',
                         }
                     ],
                     mm: [],
                     ss: []
                 },
                 {
                    value:{}
                 }
             ] */
        };
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.options.format = axTrim(this.options.format);
        this.data.type = axDateMethod.type(this.options.format);
        this.options.mode === 'range' && this.options.cols === 1 ? this.options.cols = 2 : null;
        if (axClient() === 'phone') {
            this.options.display !== 'inline' && this.options.toDrawer ? this.options.display = 'drawer' : null;
            if (this.options.lunar.enable) {
                this.options.cols = 1;
                this.options.rows = 1;
            } else {
                if (this.options.cols > 1) {
                    this.options.cols = 1;
                    this.options.rows = 2;
                }
            }
            this.bilateralCondition = false;
        } else {
            this.bilateralCondition = (this.data.type !== 'time' && this.options.cols > 1) || (this.data.type === 'time' && this.options.mode === 'range');
        }
        this.separator = this.options.mode === 'range' && this.options.language.range ? this.options.language.range : this.options.separator;
        this.positionDom = this.options.positionDom ? axIdToDom(this.options.positionDom) : this.inputDom;
        this.buttonDom = this.options.buttonDom ? axIdToDom(this.options.buttonDom) : this.inputDom;
        this.selectedDatesProxy = new axObserve(this.data.selectedDates, {
            deep: true,
        });
        this.selectedDatesProxy.instance.on('complete', (data) => {
            if (this.resultDom) {
                let newContent = data.target.map(k => axDateMethod.fillFormat(k, this.options.format)),
                    oldContent = this.resultIns.content.map(k => k.value);
                if (this.options.resultShow && this.resultIns && JSON.stringify(newContent) != JSON.stringify(oldContent)) {
                    this.resultIns.update({
                        content: newContent,
                    });
                }
            }
            this.options.autoFill ? this.confirm(false) : null;
        });
        if (this.data.type !== 'time') {
            this.handleDayContent();
        }
        this.createSkeleton();
        if (this.data.type !== 'time') {
            this.createPanels();
        } else {
            this.handleTimeContent();
        }
        if (this.options.display === 'inline') {
            this.positionDom.insertAdjacentElement('afterend', this.targetDom);
        } else if (this.options.display === 'popup') {
            this.bubbleIns = this.bubbleIns || new axPopup(this.positionDom, axExtend({
                size: '',
                padding: false,
                placement: 'bottom-start',
                close: false,
                footerShow: false,
                rel: this.options.buttonDom,
                content: this.targetDom,
            }, this.options.bubble));
        } else if (this.options.display === 'dialog') {
            this.bubbleIns = this.bubbleIns || new axDialog(axExtend({
                size: '',
                padding: false,
                footerShow: false,
                content: this.targetDom,
                rel: this.options.buttonDom,
            }, this.options.bubble), this.buttonDom);
        } else if (this.options.display === 'drawer') {
            this.options.flexible = true;
            this.bubbleIns = this.bubbleIns || new axDrawer(axExtend({
                size: '',
                padding: false,
                footerShow: false,
                content: this.targetDom,
                placement: 'bottom',
                rel: this.options.buttonDom,
            }, this.options.bubble), this.buttonDom);
        }
        if (this.bubbleIns) {
            this.bubbleIns.on('show', () => {
                this.checkBeforeShow();
            })
        }
        this.setAttribute();
        this.renderFinish();
        this.handlers.hasOwnProperty('init') ? this.emit('init', '') : null;
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createPanel(index, dateObj) {
        let curDate = axDateMethod.toDate(dateObj, this.data.type),
            panelObj = {},
            getWeek = () => {
                if (this.options.weekStart === 'monday') {
                    return `<li>${this.options.language.week[0]}</li>
                            <li>${this.options.language.week[1]}</li>
                            <li>${this.options.language.week[2]}</li>
                            <li>${this.options.language.week[3]}</li>
                            <li>${this.options.language.week[4]}</li>
                            <li>${this.options.language.week[5]}</li>
                            <li>${this.options.language.week[6]}</li>`;
                } else {
                    return `<li>${this.options.language.week[6]}</li>
                            <li>${this.options.language.week[0]}</li>
                            <li>${this.options.language.week[1]}</li>
                            <li>${this.options.language.week[2]}</li>
                            <li>${this.options.language.week[3]}</li>
                            <li>${this.options.language.week[4]}</li>
                            <li>${this.options.language.week[5]}</li>`;
                }
            };
        if (this.data.type.includes('date')) {
            curDate.setMonth(curDate.getMonth() + index);
            panelObj.month = curDate.getMonth();
            panelObj.year = curDate.getFullYear();
            panelObj.panelDom = axStrToDom(`
                            <li panel='${this.options.lunar.enable ? 'lunar' : 'date'}'>
                                <div header>
                                    <span year><i>${panelObj.year}</i>${this.options.language.unit.Y}</span><span month><i>${panelObj.month + 1}</i>${this.options.language.unit.M}</span>
                                </div>
                                <div body days>
                                    <ul column>
                                        ${getWeek()}
                                    </ul>
                                    <ul list></ul>
                                </div>
                            </li>
                            `);
            panelObj.type = 'date';
            panelObj.headerDom = panelObj.panelDom.querySelector('[header]');
            panelObj.yearDom = panelObj.headerDom.querySelector('[year]');
            panelObj.monthDom = panelObj.headerDom.querySelector('[month]');
            panelObj.listDom = panelObj.panelDom.querySelector('[list]');
            panelObj.list = this.createPanelDayList(panelObj.listDom, curDate);
        } else if (this.data.type === 'month') {
            curDate.setFullYear(curDate.getFullYear() + index);
            panelObj.year = curDate.getFullYear();
            panelObj.panelDom = axStrToDom(`
                        <li panel='month'>
                            <div header>
                                <span year><i>${panelObj.year}</i>${this.options.language.unit.Y}</span>
                            </div>
                            <div body>
                                <ul list>${this.monthStr}</ul>
                            </div>
                        </li>
                        `);
            panelObj.type = 'month';
            panelObj.headerDom = panelObj.panelDom.querySelector('[header]');
            panelObj.yearDom = panelObj.headerDom.querySelector('[year]');
            panelObj.listDom = panelObj.panelDom.querySelector('[list]');
            panelObj.list = this.createPanelMonthList(panelObj.listDom, curDate);
        } else if (this.data.type === 'year') {
            curDate.setFullYear(curDate.getFullYear() + 18 * index - 7);
            panelObj.year = curDate.getFullYear();
            panelObj.panelDom = axStrToDom(`
            <li panel='year'>
                <div header>
                    <span year><i>${panelObj.year}</i>${this.options.language.unit.Y}~<i>${panelObj.year + 17}</i>${this.options.language.unit.Y}</span>
                </div>
                <div body>
                    <ul list></ul>
                </div>
            </li>
            `);
            panelObj.type = 'year';
            panelObj.headerDom = panelObj.panelDom.querySelector('[header]');
            panelObj.listDom = panelObj.panelDom.querySelector('[list]');
            panelObj.list = this.createPanelYearList(panelObj.listDom, curDate);
        }
        panelObj.bodyDom = panelObj.panelDom.querySelector('[body]');
        this.data.panels.push(panelObj);
        this.panelsDom.appendChild(panelObj.panelDom);
    }
    createPanels(dateObj, force = false, callback) {
        if (this.destroyed) {
            return false;
        }
        let index = this.options.rows * this.options.cols,
            startDate;
        if (dateObj) {
            startDate = axDateMethod.toDate(dateObj, this.data.type);
        } else {
            startDate = this.data.startDate;
        }
        if (!force && this.inCurPanels(startDate)) {
            return false;
        };
        this.data.panels = [];
        this.panelsDom.innerHTML = '';
        for (let k = 0; k < index; k++) {
            this.createPanel(k, startDate);
        }
        this.data.startDate = startDate;
        let curItems = this.getCurGrids();
        curItems.forEach(k => {
            if (this.inSelectedDate(k) && !k.selected) {
                this.selectedAttrToggle(k, true);
            }
        });
        this.options.mode === 'range' ? this.setRangeAttr(curItems) : null;
        let nowObj = axDateMethod.toObj(new Date(), false, this.data.type),
            nowItem = curItems.find(k => JSON.stringify(k.value) == JSON.stringify(nowObj));
        if (nowItem) {
            nowItem.wrapperDom.setAttribute('now', '');
        }
        this.renderFinish();
        this.handlers.hasOwnProperty('createPanels') ? this.emit('createPanels', '') : null;
        this.options.onCreatePanels && this.options.onCreatePanels.call(this);
        callback && callback.call(this);
        return this;
    }
    inSelectedDate(dateObj) {
        let value = this.getDateValue(dateObj, this.data.type);
        return this.selectedDatesProxy.proxy.some(k => {
            let { hh, mm, ss, ...rest } = k;
            return JSON.stringify(rest) == JSON.stringify(value);
        });
    }
    showEvent(obj) {
        this.todayDom.innerHTML = axDateMethod.fillFormat(obj.value, 'YYYY年MM月DD日 周WW');
        if (this.options.lunar.enable && this.options.lunar.handler) {
            let lunarObj = { ...this.options.lunar.map },
                lunarValue = this.options.lunar.handler(obj.value.YYYY, obj.value.MM + 1, obj.value.DD);
            for (let k in lunarObj) {
                if (lunarObj.hasOwnProperty(k)) {
                    lunarObj[k] = lunarValue[lunarObj[k]];
                }
            }
            this.lunarDom.innerHTML = axTplEngine(this.options.lunar.template, lunarObj)
        }
        let item = this.options.event.list.find(k => JSON.stringify(axDateMethod.toObj(k.date, false, 'date')) == JSON.stringify(axDateMethod.toObj(obj.value, false, 'date')));
        this.eventDom.innerHTML = item && item.content ? axTplEngine(this.options.event.template, item) : this.options.language.noEvent;
    }
    inCurPanels(dateObj, curGrids) {
        let type = this.data.type === 'datetime' ? 'date' : this.data.type,
            date = axType(dateObj) === 'Object' ? { ...dateObj } : dateObj,
            obj = axDateMethod.toObj(date, false, type),
            grids = curGrids || this.getCurGrids(),
            result;
        result = grids.some(k => JSON.stringify(k.value) == JSON.stringify(obj));
        return result;
    }
    setAttribute() {
        !this.bilateralCondition ? this.targetDom.setAttribute('footerType', 'line') : null;
        this.targetDom.setAttribute('mode', this.options.mode);
        this.data.type ? this.targetDom.setAttribute('type', this.data.type) : null;
        this.targetDom.setAttribute('display', this.options.display)
        this.inputDom.nodeName === 'INPUT' ? this.inputDom.setAttribute('readonly', '') : null;
        this.options.flexible ? this.targetDom.setAttribute('flexible', '') : null;
        this.targetDom.setAttribute('footerShow', this.options.footerShow);
        this.options.lunar.enable ? this.targetDom.setAttribute('lunar', '') : null;
    }
    inputValueToDates(toDate = true) {
        let str, result = [];
        if (this.inputDom.nodeName === 'INPUT') {
            str = this.inputDom.value.trim();
        } else {
            str = this.inputDom.innerText.trim();
        }
        if (!str || isNaN(parseFloat(str.substr(0, 2)))) {
            return result;
        }
        if (str) {
            if (toDate) {
                result = str.split(this.separator).map(k => new Date(k));
            } else {
                result = axTrim(str);
            }
        }
        return result;
    }
    contentToArr() {
        let type = axType(this.options.content),
            result = [];
        if (this.data.type === 'time') {
            if (this.inputDom && (this.inputDom.value || this.inputDom.innerText)) {
                result = this.inputValueToDates(false);
            } else {
                if (axIsEmpty(this.options.content)) {
                    result = axDateMethod.fillFormat(new Date(), this.options.format);
                } else {
                    if (type === 'String') {
                        result = this.options.content.split(this.separator);
                    } else if (type === 'Array') {
                        result = this.options.content;
                    }
                }
            }
        } else {
            if (!axIsEmpty(this.options.content)) {
                let type = axType(this.options.content);
                if (type === 'Array') {
                    result = this.options.content.map(k => typeof k === 'string' ? new Date(k) : k);
                } else if (type === 'Date') {
                    result.push(this.options.content);
                } else if (type === 'String') {
                    result = this.options.content.split(this.separator).map(k => new Date(k));
                }
            } else if (this.inputDom && (this.inputDom.value || this.inputDom.innerText)) {
                result = this.inputValueToDates(true);
            } else {
                result = this.options.fillNow ? [new Date()] : [];
            }
        }
        return result;
    }
    handleDayContent() {
        this.content = this.contentToArr();
        if (this.content.length > 1 && this.options.mode === 'range') {
            this.content.sort(function (a, b) { return a - b });
            this.content.length > 2 ? this.content = this.content.slice(0, 2) : null;
        }
        this.data.startDate = this.content.length === 0 ? new Date() : this.content[0];
        let selectedContent = this.datesToObjs(this.content);
        this.selectedDatesProxy.proxy.splice(0, this.data.selectedDates.length, ...selectedContent);
        this.raw = [...selectedContent];
        if (this.inputDom) {
            let value = this.selectedDatesProxy.proxy.map(k => axDateMethod.fillFormat(k, this.options.format)).join(this.separator)
            this.fillInput(value);
        }
    }
    timeStrSTD(data, type = 'object') {
        let dataType = axType(data),
            objArr = [],
            strArr = [],
            dataFun = (obj) => {
                let objType = axType(obj), arr, result;
                if (objType === 'String') {
                    arr = axTrim(obj).split(':').map(k => ~~k);
                    if (arr.length === 1) {
                        arr.push(0, 0);
                    } else if (arr.length === 2) {
                        arr.push(0);
                    }
                    result = { hh: arr[0], mm: arr[1], ss: arr[2] }
                } else if (objType === 'Object') {
                    for (let k in obj) {
                        if (obj.hasOwnProperty(k)) {
                            obj[k] = ~~obj[k];
                        }
                    }
                    !obj.hasOwnProperty('mm') ? obj.mm = 0 : null;
                    !obj.hasOwnProperty('ss') ? obj.ss = 0 : null;
                    result = obj;
                }
                return result;
            }
        if (dataType === 'Array') {
            data.forEach(k => {
                objArr.push(dataFun(k));
            });
        } else {
            objArr.push(dataFun(data));
        }
        if (type === 'string') {
            strArr = objArr.map(k => `${axDateMethod.fillZero(k.hh)}:${axDateMethod.fillZero(k.mm)}:${axDateMethod.fillZero(k.ss)}`);
            return strArr;
        } else {
            return objArr;
        }
    }
    handleTimeContent() {
        this.content = this.timeStrSTD(this.contentToArr());
        if (this.options.mode === 'range') {
            if (this.content.length === 0) {
                this.setTime([{ hh: 0, mm: 0, ss: 0 }, { hh: 0, mm: 0, ss: 0 }]);
            } else if (this.content.length === 1) {
                this.setTime([this.content[0], { hh: 0, mm: 0, ss: 0 }]);
            } else {
                this.setTime(this.content);
            }
        } else {
            if (this.content.length === 0) {
                this.setTime({ hh: 0, mm: 0, ss: 0 });
            } else {
                this.setTime(this.content[0]);
            }
        }
        this.raw = [...this.content];
        if (this.inputDom && !axIsEmpty(this.options.content)) {
            let value = this.timeStrSTD(this.content, 'string').join(this.separator)
            if (this.inputDom.nodeName === 'INPUT') {
                this.inputDom.value = value;
            } else {
                this.inputDom.innerText = value;
            }
        }
    }
    datesToObjs(dates) {
        let selectedContent = [];
        if (this.data.type === 'year') {
            selectedContent = dates.map(k => {
                return { YYYY: k.getFullYear() }
            });
        } else if (this.data.type === 'month') {
            selectedContent = dates.map(k => {
                return { YYYY: k.getFullYear(), MM: k.getMonth() }
            });
        } else if (this.data.type === 'time') {
            selectedContent = dates.map(k => {
                return { hh: k.getHours(), mm: k.getMinutes(), ss: k.getSeconds() }
            });
        } else if (this.data.type === 'date') {
            selectedContent = dates.map(k => {
                return { YYYY: k.getFullYear(), MM: k.getMonth(), DD: k.getDate() }
            });
        } else if (this.data.type === 'datetime') {
            selectedContent = dates.map(k => {
                return { YYYY: k.getFullYear(), MM: k.getMonth(), DD: k.getDate(), hh: k.getHours(), mm: k.getMinutes(), ss: k.getSeconds() }
            });
        }
        return selectedContent;
    }
    checkBeforeShow() {
        if (!this.options.autoCorrect) {
            return false;
        }
        if (this.data.type !== 'time') {
            let value = this.inputValueToDates(),
                selectedDates = this.datesToObjs(value),
                isSame = JSON.stringify(selectedDates) == JSON.stringify(this.data.selectedDates);
            if (!isSame) {
                this.data.startDate = value.length > 0 ? value[0] : axDateMethod.toDate(this.data.selectedDates[0], this.data.type);
                this.createPanels();
                this.clear();
                this.set(selectedDates);
            }
        } else {
            let timeObj = this.timeStrSTD(this.inputValueToDates(false));
            this.setTime(timeObj);
        }
    }
    createSkeleton() {
        let outerHTML = '', footerHTML = '';
        if (this.data.type !== 'time') {
            outerHTML = `<div outer>
                            <div prev></div>
                                <div next></div>
                                <ul panels ${this.bilateralCondition ? 'style="grid-template-columns:repeat(' + this.options.cols + ', 1fr)"' : ''}></ul>
                            </div>`;
        }
        if (this.options.footerShow) {
            footerHTML = `<div footer>
                            ${this.bilateralCondition ? '<div left></div><div right></div>' : ''}
                            </div>`;
        }
        this.targetDom = axStrToDom(`
        <div class="ax-date">
            <div wrapper>
                ${this.options.menu.length > 0 ? '<ul menu></ul>' : ''}
                <div main>
                    ${this.options.resultShow && this.data.type !== 'time' ? '<div result></div>' : ''}
                    ${outerHTML}
                    ${footerHTML}
                </div>
            </div>
        </div>
    `);
        this.wrapperDom = this.targetDom.querySelector('[wrapper]');
        this.menuDom = this.targetDom.querySelector('[menu]');
        this.resultDom = this.targetDom.querySelector('[result]');
        this.outerDom = this.targetDom.querySelector('[outer]');
        this.prevDom = this.targetDom.querySelector('[prev]');
        this.nextDom = this.targetDom.querySelector('[next]');
        this.mainDom = this.targetDom.querySelector('[main]');
        this.panelsDom = this.targetDom.querySelector('[panels]');
        if (this.options.footerShow) {
            this.footerDom = this.targetDom.querySelector('[footer]');
            this.timeBtnWrapperDom = this.bilateralCondition ? this.footerDom.querySelector('[left]') : this.footerDom;
            this.handleBtnsWrapperDom = this.bilateralCondition ? this.footerDom.querySelector('[right]') : this.footerDom;
            this.confirmDom = axAddElem('i', { class: `ax-btn${!this.bilateralCondition ? ' ax-text' : ''} `, confirm: '' }, this.options.language.button.confirm);
            this.clearDom = this.options.clearShow ? axAddElem('i', { class: 'ax-btn ax-text', clear: '' }, this.options.language.button.clear) : '';
            this.closeDom = this.options.closeShow ? axAddElem('i', { class: 'ax-btn ax-text', close: '' }, this.options.language.button.close) : '';
            this.cancelDom = this.options.cancelShow ? axAddElem('i', { class: 'ax-btn ax-text', cancel: '' }, this.options.language.button.cancel) : '';
            this.nowDom = this.options.nowShow ? axAddElem('i', { class: 'ax-btn ax-text', now: '' }, this.options.language.button.now) : '';
            this.timeBtnDom = this.data.type.includes('time') ? axAddElem('i', { class: 'ax-btn ax-text', time: '' }, this.options.language.time.select) : '';
            this.yearSearchDom = this.data.type === 'year' ? axAddElem('span', { search: '' }, `<input type="text" placeholder="${this.options.language.year.placeholder}" /><i go>arrow-right</i>`) : '';
            this.confirmDom ? this.handleBtnsWrapperDom.appendChild(this.confirmDom) : null;
            this.nowDom ? this.handleBtnsWrapperDom.insertAdjacentElement('afterbegin', this.nowDom) : null;
            this.clearDom ? this.handleBtnsWrapperDom.insertAdjacentElement('afterbegin', this.clearDom) : null;
            this.closeDom ? this.handleBtnsWrapperDom.insertAdjacentElement('afterbegin', this.closeDom) : null;
            this.cancelDom ? this.handleBtnsWrapperDom.insertAdjacentElement('afterbegin', this.cancelDom) : null;
            this.timeBtnDom ? this.timeBtnWrapperDom.insertAdjacentElement('afterbegin', this.timeBtnDom) : null;
            this.yearSearchDom ? this.timeBtnWrapperDom.insertAdjacentElement('afterbegin', this.yearSearchDom) : null;
        }
        if (this.options.event.enable) {
            this.detailDom = axAddElem('div', { detail: '' });
            this.todayDom = axAddElem('div', { today: '' });
            this.eventDom = axAddElem('div', { event: '' }, this.options.language.noEvent);
            this.detailDom.appendChild(this.todayDom);
            this.detailDom.appendChild(this.eventDom);
            if (this.options.lunar.enable && this.options.lunar.handler) {
                this.lunarDom = axAddElem('div', { lunar: '' });
                this.todayDom.insertAdjacentElement('afterend', this.lunarDom);
            }
            if (this.options.event.display === 'inline') {
                this.wrapperDom.appendChild(this.detailDom);
            } else if (this.options.event.display === 'popup') {
                this.detailIns = this.detailIns || new axPopup(this.panelsDom, {
                    content: this.detailDom,
                    trigger: 'hovor',
                    placement: 'bottom',
                    size: 'sm',
                    footerShow: false,
                });
            }
        }
        if (this.data.type.includes('time') && this.options.footerShow) {
            this.createTimeSelectPanel();
        }
        this.createMenu();
        if (this.data.type !== 'time') {
            if (this.resultDom) {
                this.resultIns = this.resultIns || new axTags(this.resultDom, {
                    content: '',
                    closable: true,
                    text: true,
                    emptyTip: this.options.language.empty,
                });
            }
            if (this.data.type === 'year' || this.data.type === 'month') {
                this.prevDom.innerHTML = `<i prevYear class= "ax-iconfont ax-icon-left-double"></i> `;
                this.nextDom.innerHTML = `<i nextYear class= "ax-iconfont ax-icon-right-double"></i> `;
            } else if (this.data.type.includes('date')) {
                this.prevDom.innerHTML = `<i prevYear class= "ax-iconfont ax-icon-left-double"></i> <i prevMonth class="ax-iconfont ax-icon-left"></i>`;
                this.nextDom.innerHTML = `<i nextYear class= "ax-iconfont ax-icon-right-double"></i> <i nextMonth class="ax-iconfont ax-icon-right"></i>`;
            }
            this.prevYearDom = this.prevDom.querySelector('[prevYear]');
            this.prevMonthDom = this.prevDom.querySelector('[prevMonth]');
            this.nextYearDom = this.targetDom.querySelector('[nextYear]');
            this.nextMonthDom = this.targetDom.querySelector('[nextMonth]');
            if (this.data.type === 'month' || this.data.type.includes('date')) {
                this.createYearPanel();
            }
            if (this.data.type.includes('date')) {
                this.createMonthPanel();
            }
        }
    }
    createMenu() {
        if (this.options.menu.length > 0) {
            this.data.menu = this.options.menu;
            let fragment = document.createDocumentFragment();
            this.data.menu.forEach(k => {
                let elem = axAddElem('li', '', k.label);
                k.dom = elem;
                fragment.appendChild(elem);
            });
            this.menuDom.appendChild(fragment);
            this.data.menu.forEach(k => {
                k.dom.onclick = () => {
                    k.action && k.action.call(this);
                    k.dom.setAttribute('selected', '');
                    k.selected = true;
                    this.data.menu.filter(i => i !== k).forEach(o => {
                        Reflect.deleteProperty(o, 'selected');
                        o.dom.removeAttribute('selected');
                    });
                }
            });
        }
    }
    createMonthPanel(callback) {
        this.data.month.panelDom = axAddElem('div', { panel: 'month' }, `<div body><ul list>${this.monthStr}</ul></div>`);
        this.data.month.listDom = this.data.month.panelDom.querySelector('[list]');
        [...this.data.month.listDom.children].forEach((k, i) => {
            let obj = {
                wrapperDom: k,
                contentDom: k.querySelector('[content]'),
                value: i,
            };
            this.data.month.list.push(obj);
        });
        this.panelsDom.insertAdjacentElement('afterend', this.data.month.panelDom);
        callback && callback();
    }
    createYearPanel(callback) {
        this.data.year.panelDom = axAddElem('div', { panel: 'year' }, `
    <div body>
                        <ul list></ul>
                        <ul pages>
                            <li><i prev>${this.options.language.year.prev}</i></li>
                            <li><input type="text" placeholder=${this.options.language.year.placeholder} class="ax-sm"/><i go>arrow-right</i></li>
                            <li><i next>${this.options.language.year.next}</i></li>
                        </ul>
                    </div>
    `);
        this.data.year.listDom = this.data.year.panelDom.querySelector('[list]');
        this.data.year.prevDom = this.data.year.panelDom.querySelector('[prev]');
        this.data.year.nextDom = this.data.year.panelDom.querySelector('[next]');
        this.data.year.inputDom = this.data.year.panelDom.querySelector('input');
        this.data.year.goDom = this.data.year.panelDom.querySelector('[go]');
        this.panelsDom.insertAdjacentElement('afterend', this.data.year.panelDom);
        callback && callback();
    }
    createYearList(panel, index, offset) {
        this.data.year.listDom.innerHTML = '';
        this.data.year.list = [];
        for (let k = 0; k < 15; k++) {
            let year = index || index === 0 ? index + k : panel.year - 7 + k,
                obj = {
                    wrapperDom: axAddElem('li', '', `<span content> <i label>${year}年</i></span> `),
                    value: year,
                }
            obj.contentDom = obj.wrapperDom.querySelector('[content]');
            obj.labelDom = obj.wrapperDom.querySelector('[label]');
            this.data.year.listDom.appendChild(obj.wrapperDom);
            this.data.year.list.push(obj);
        }
        this.data.year.list.forEach(k => {
            if (panel.year === k.value) {
                this.selectedAttrToggle(k, true);
            } else {
                this.selectedAttrToggle(k, false);
            }
            k.contentDom.onclick = () => {
                if (k.disabled) {
                    return false;
                }
                if (panel.year !== k.value) {
                    let startValue = k.value;
                    if (this.data.type === 'month') {
                        startValue = k.value - offset;
                    } else if (this.data.type.includes('date')) {
                        startValue = k.value - (this.data.panels[offset].year - this.data.panels[0].year);
                    }
                    this.data.startDate.setFullYear(startValue);
                    this.createPanels('', true);
                    axHide(this.data.year.panelDom);
                }
            }
        });
    }
    goto(dateObj, setSelected = false, callback) {
        if (this.destroyed) {
            return false;
        }
        let date = axDateMethod.toDate(dateObj, this.data.type);
        if (setSelected) {
            this.set(date)
        } else {
            this.createPanels(date);
        }
        callback && callback.call(this);
    }
    offset(dateObj, callback) {
        if (this.destroyed) {
            return false;
        }
        if (this.data.selectedDates.length > 0) {
            let dates = this.data.selectedDates.map(k => axDateMethod.toObj(axDateMethod.getChain(k, dateObj), false, this.data.type));
            this.set(dates);
        } else {
            this.data.startDate = axDateMethod.getChain(axDateMethod.toObj(new Date(), false, this.data.type), dateObj);
            this.set(this.data.startDate);
        }
        callback && callback.call(this);
    }
    selectedAttrToggle(obj, state) {
        if (state) {
            if (!obj.selected) {
                Reflect.set(obj, 'selected', true);
                obj.wrapperDom.setAttribute('selected', '');
            }
        } else {
            if (obj.selected) {
                Reflect.deleteProperty(obj, 'selected');
                obj.wrapperDom.removeAttribute('selected');
            }
        }
    }
    setSelected(dateObj, curGrid, curGrids) {
        let curObj = this.findFromPanels(dateObj, curGrid, curGrids),
            curItems = curObj.list,
            curItem = curObj.target,
            fillTime = (dateObj) => {
                let obj = {};
                if (this.options.mode === 'range') {
                    if (this.selectedDatesProxy.proxy.length === 1) {
                        obj = this.data.type.includes('time') ? { ...dateObj, ...this.data.time[1].value } : dateObj;
                    } else {
                        obj = this.data.type.includes('time') ? { ...dateObj, ...this.data.time[0].value } : dateObj;
                    }
                } else {
                    if (this.data.time.length > 0) {
                        obj = this.data.type.includes('time') ? { ...dateObj, ...this.data.time[0].value } : dateObj;
                    } else {
                        obj = dateObj;
                    }
                }
                return obj;
            },
            selectedFun = (obj) => {
                let value;
                if (this.data.type.includes('time')) {
                    if (dateObj.hasOwnProperty('hh') && dateObj.hasOwnProperty('mm') && dateObj.hasOwnProperty('ss')) {
                        value = dateObj;
                    } else {
                        value = fillTime(obj.value);
                    }
                } else {
                    value = dateObj.value || dateObj;
                }
                if (!obj.disabled) {
                    if (this.options.mode === 'range') {
                        let length = this.selectedDatesProxy.proxy.length;
                        if (length < 2) {
                            this.selectedDatesProxy.proxy.push(value);
                            if (length === 1) {
                                let rangeStart = { ...this.data.selectedDates[0] },
                                    rangeEnd = { ...this.data.selectedDates[1] };
                                if (axDateMethod.toDate(rangeStart) > axDateMethod.toDate(rangeEnd)) {
                                    this.selectedDatesProxy.proxy.sort((a, b) => axDateMethod.toDate(a) - axDateMethod.toDate(b));
                                    this.assignDaytime();
                                }
                                this.setRange(this.data.selectedDates);
                            }
                        } else {
                            this.clear(false);
                            this.selectedDatesProxy.proxy.splice(0, this.selectedDatesProxy.proxy.length, value);
                        }
                    } else {
                        if (this.options.mode === 'single') {
                            if (this.inSelectedDate(value)) {
                                return false;
                            };
                            this.clear(false);
                            this.selectedDatesProxy.proxy.splice(0, this.selectedDatesProxy.proxy.length, value);
                        } else if (this.options.mode === 'multiple') {
                            !this.inSelectedDate(value) ? this.selectedDatesProxy.proxy.push(value) : null;
                        }
                    }
                    this.selectedAttrToggle(obj, true);
                }
            };
        if (!curItems.includes(dateObj) && !curItem) {
            this.createPanels(dateObj.hasOwnProperty('value') ? dateObj.value : dateObj);
            curItem = this.findFromPanels(dateObj).target;
        }
        !curItem.selected ? selectedFun(curItem) : null;
        this.options.event.enable && curItem ? this.showEvent(curItem) : null;
    }
    setUnselected(dateObj, curGrid, curGrids) {
        if (axIsEmpty(dateObj)) {
            return false;
        }
        let curItems = curGrids || this.getCurGrids(),
            curItem = this.findFromPanels(dateObj, curGrid, curItems).target,
            selectedDates = [];
        if (curItem) {
            this.selectedAttrToggle(curItem, false);
        }
        selectedDates = this.data.selectedDates.filter(k => !axDateMethod.isSameDay(k, dateObj.hasOwnProperty('value') ? dateObj.value : dateObj));
        this.selectedDatesProxy.proxy.splice(0, this.data.selectedDates.length, ...selectedDates);
        if (this.options.mode === 'range' && this.data.selectedDates.length < 2) {
            curItems.forEach(k => {
                this.removeRangeAttr(k)
            });
        }
    }
    /*     setDisabled(dateObj) {
            if (axIsEmpty(dateObj)) {
                return false;
            }
        } */
    setRangeAttr(grids) {
        if (this.data.selectedDates.length !== 2) {
            return false;
        }
        let curGrids = grids || this.getCurGrids(),
            type = this.data.type === 'datetime' ? 'date' : this.data.type;
        curGrids.forEach(k => {
            this.removeRangeAttr(k);
            this.selectedAttrToggle(k, false);
            if (axDateMethod.toDate(k.value, type) > axDateMethod.toDate(this.data.selectedDates[0], type) && axDateMethod.toDate(k.value, type) < axDateMethod.toDate(this.data.selectedDates[1], type)) {
                k.wrapperDom.setAttribute('contain', '');
            }
        });
        let gridStart = this.findFromPanels(this.data.selectedDates[0], '', curGrids).target,
            gridEnd = this.findFromPanels(this.data.selectedDates[1], '', curGrids).target;
        if (gridStart) {
            gridStart.wrapperDom.setAttribute('start', '');
            this.selectedAttrToggle(gridStart, true);
        }
        if (gridEnd) {
            gridEnd.wrapperDom.setAttribute('end', '');
            this.selectedAttrToggle(gridEnd, true);
        }
    }
    removeRangeAttr(dateObj) {
        if (dateObj.wrapperDom.hasAttribute('start')) {
            dateObj.wrapperDom.removeAttribute('start');
        }
        if (dateObj.wrapperDom.hasAttribute('end')) {
            dateObj.wrapperDom.removeAttribute('end');
        }
        if (dateObj.wrapperDom.hasAttribute('contain')) {
            dateObj.wrapperDom.removeAttribute('contain');
        }
    }
    limitRange(dateObj, type, prop) {
        if (!this.options.minDate || !this.options.maxDate || dateObj.disabled) {
            return false;
        }
        let valueDate = axDateMethod.toDate(dateObj.value, type),
            minDate = axDateMethod.toDate(this.options.minDate, type),
            maxDate = axDateMethod.toDate(this.options.maxDate, type),
            condition,
            setFun = (obj) => {
                if (condition) {
                    obj.disabled = true;
                    obj.wrapperDom.setAttribute('disabled', '');
                }
            };
        if (type === 'date' || type === 'month') {
            condition = (this.options.minDate && valueDate < minDate) || (this.options.maxDate && valueDate > maxDate);
        } else if (type === 'year') {
            condition = (this.options.minDate && dateObj.value.YYYY < ~~this.options.minDate) || (this.options.maxDate && dateObj.value.YYYY > ~~this.options.maxDate);
        } else if (type === 'time') {
            minDate = axDateMethod.toObj(this.options.minDate, false, type);
            maxDate = axDateMethod.toObj(this.options.maxDate, false, type);
            condition = dateObj.value < minDate[prop] || dateObj.value > maxDate[prop];
        }
        setFun(dateObj);
    }
    getDateValue(dateObj, type) {
        let objType = axType(dateObj),
            value = {};
        if (objType === 'Object') {
            if (dateObj.hasOwnProperty('value')) {
                value = dateObj.value;
            } else {
                value = dateObj;
            }
        } else if (objType === 'Number') {
            value = this.data.selectedDates[dateObj];
        } else if (objType === 'String' || objType === 'Date') {
            value = axDateMethod.toObj(dateObj, false, this.data.type);
        }
        let { hh, mm, ss, ...rest } = value;
        if (type === 'year') {
            Reflect.deleteProperty(rest, 'DD');
            Reflect.deleteProperty(rest, 'MM');
        } else if (type === 'month') {
            Reflect.deleteProperty(rest, 'DD');
        }
        return rest;
    }
    getCurGrids() {
        return this.data.panels.map(k => k.list).flat(Infinity).filter(k => !k.exceed);
    }
    findFromPanels(dateObj, grid, grids) {
        let value = this.getDateValue(dateObj, this.data.type),
            curItems = grids || this.getCurGrids(),
            curItem = grid || curItems.find(k => JSON.stringify(k.value) == JSON.stringify(value));
        return { target: curItem, list: curItems };
    }
    renderFinish() {
        if (this.data.type !== 'time') {
            let curGrids = this.getCurGrids();
            this.data.panels.forEach(o => {
                o.list.forEach(k => {
                    k.contentDom.onclick = () => {
                        if (k.disabled) {
                            return false;
                        }
                        if (this.data.selectedDates.length > this.options.maxSelection) {
                            console.warn(`The selected items have exceeded the ${this.options.maxSelection} limit!`);
                            return false;
                        }
                        let curItem = curGrids.find(i => JSON.stringify(i.value) == JSON.stringify(k.value));
                        if (this.options.mode === 'multiple') {
                            if (curItem) {
                                curItem.selected ? this.setUnselected(k, curItem, curGrids) : this.setSelected(k, curItem, curGrids);
                            } else {
                                this.setSelected(k, curItem, curGrids);
                            }
                        } else {
                            this.setSelected(k, curItem, curGrids);
                        }
                        this.handlers.hasOwnProperty('set') ? this.emit('set', k) : null;
                        this.options.onSet && this.options.onSet.call(this, k);
                    }
                    if (this.detailIns) {
                        k.contentDom.onmouseenter = () => {
                            this.showEvent(k);
                            this.detailIns.updatePosition(k.contentDom).show();
                        }
                    }
                })
            });
            if (this.resultIns) {
                this.resultIns.on('remove', (removeItems, indexs) => {
                    let curGrids = this.getCurGrids(),
                        curGrid = this.findFromPanels(indexs[0], '', curGrids).target;
                    if (curGrid) {
                        this.selectedAttrToggle(curGrid, false);
                    }
                    this.selectedDatesProxy.proxy.splice(indexs[0], 1);
                    curGrids.forEach(k => {
                        this.removeRangeAttr(k);
                    });
                });
                this.resultIns.on('update', () => {
                    this.resultIns.content.forEach(k => {
                        k.dom.onclick = (e) => {
                            if (!e.target.hasAttribute('close')) {
                                if (!this.findFromPanels(k.value).target) {
                                    this.createPanels(k.value);
                                }
                            }
                        }
                    });
                });
            }
            if (this.prevYearDom) {
                this.prevYearDom.onclick = () => {
                    let years = -1;
                    if (this.data.type === 'year') {
                        years = -18 * this.options.cols * this.options.rows;
                    } else if (this.data.type === 'month') {
                        years = -this.options.cols * this.options.rows;
                    }
                    this.createPanels(axDateMethod.getChain(this.data.startDate, { YYYY: years }), true);
                }
            }
            if (this.nextYearDom) {
                this.nextYearDom.onclick = () => {
                    let years = 1;
                    if (this.data.type === 'year') {
                        years = 18 * this.options.cols * this.options.rows;
                    } else if (this.data.type === 'month') {
                        years = this.options.cols * this.options.rows;
                    }
                    this.createPanels(axDateMethod.getChain(this.data.startDate, { YYYY: years }), true);
                }
            }
            if (this.data.type.includes('date')) {
                this.prevMonthDom.onclick = () => {
                    this.createPanels(axDateMethod.getChain(this.data.startDate, { MM: -1 }), true);
                }
                this.nextMonthDom.onclick = () => {
                    this.createPanels(axDateMethod.getChain(this.data.startDate, { MM: 1 }), true);
                }
            }
            this.data.panels.forEach((k, i) => {
                if (k.yearDom) {
                    k.yearDom.onclick = () => {
                        this.data.year.panelDom.style.top = k.panelDom.offsetTop + k.headerDom.clientHeight + 'px';
                        this.data.year.panelDom.style.left = k.panelDom.offsetLeft + 'px';
                        if (this.data.month.panelDom) {
                            if (axIsVisible(this.data.month.panelDom)) {
                                axHide(this.data.month.panelDom);
                            }
                        }
                        this.createYearList(k, '', i);
                        axToggle(this.data.year.panelDom);
                    }
                    this.data.year.prevDom.onclick = () => {
                        this.createYearList(k, this.data.year.list[0].value - 15, i);
                    }
                    this.data.year.nextDom.onclick = () => {
                        this.createYearList(k, this.data.year.list[14].value + 1, i);
                    }
                    this.data.year.goDom.onclick = () => {
                        this.searchYearToRefresh(this.data.year.inputDom);
                    }
                    this.data.year.inputDom.onkeyup = (e) => {
                        if (e.code === 'Enter') {
                            this.searchYearToRefresh(this.data.year.inputDom);
                        }
                    }
                }
                if (k.monthDom) {
                    k.monthDom.onclick = () => {
                        this.data.month.panelDom.style.top = k.panelDom.offsetTop + k.headerDom.clientHeight + 'px';
                        this.data.month.panelDom.style.left = k.panelDom.offsetLeft + 'px';
                        if (axIsVisible(this.data.year.panelDom)) {
                            axHide(this.data.year.panelDom);
                        }
                        this.data.month.list.forEach(o => {
                            if (k.month === o.value) {
                                this.selectedAttrToggle(o, true);
                            } else {
                                this.selectedAttrToggle(o, false);
                            }
                            o.contentDom.onclick = () => {
                                if (k.month !== o.value) {
                                    this.data.startDate.setMonth(o.value - i);
                                    this.createPanels('', true);
                                    axHide(this.data.month.panelDom);
                                }
                            }
                        });
                        axToggle(this.data.month.panelDom);
                    }
                }
            });
            this.data.selectedDates.forEach((k, i) => {
                let item = this.findFromPanels(k, '', curGrids).target;
                if (item) {
                    this.selectedAttrToggle(item, true);
                    if (i === 0 && this.options.event.enable) {
                        this.showEvent(item);
                    }
                }
            });
            if (this.yearSearchDom) {
                let yearSearch = this.yearSearchDom.querySelector('[go]'),
                    yearInput = this.yearSearchDom.querySelector('input')
                yearSearch.onclick = () => {
                    this.searchYearToRefresh(yearInput, false);
                }
                yearInput.onkeyup = (e) => {
                    if (e.code === 'Enter') {
                        this.searchYearToRefresh(yearInput, false);
                    }
                }
            }
            if (this.timePanelsDom) {
                if (this.options.mode === 'range') {
                    if (this.data.selectedDates.length === 0) {
                        this.setTime([{ hh: 0, mm: 0, ss: 0 }, { hh: 0, mm: 0, ss: 0 }]);
                    } else if (this.data.selectedDates.length === 1) {
                        this.setTime([this.data.selectedDates[0], { hh: 0, mm: 0, ss: 0 }]);
                    } else {
                        this.setTime(this.data.selectedDates);
                    }
                } else {
                    if (this.data.selectedDates.length === 0) {
                        this.setTime({ hh: 0, mm: 0, ss: 0 });
                    } else {
                        this.setTime(this.data.selectedDates[0]);
                    }
                }
                if (this.timeBtnDom) {
                    this.timeBtnDom.onclick = () => {
                        axSlideToggle(this.timePanelsDom, 'inline-grid', () => {
                            this.openTimeToPrevent();
                        });
                    }
                }
            }
        }
        if (this.options.footerShow) {
            this.confirmDom.onclick = () => {
                this.confirm();
            }
            if (this.nowDom) {
                this.nowDom.onclick = () => {
                    this.now();
                }
            }
            if (this.clearDom) {
                this.clearDom.onclick = () => {
                    this.clear(true);
                }
            }
        }
        if (this.data.type.includes('time') && this.data.time.length > 0) {
            let timeCols = this.data.time.map(k => k.colsDom).flat(Infinity);
            if (this.options.display === 'inline') {
                this.openTimeToPrevent(timeCols);
            } else {
                if (this.bubbleIns) {
                    this.bubbleIns.on('shown', () => {
                        this.openTimeToPrevent(timeCols);
                    });
                }
            }
        }
        if (this.bubbleIns) {
            this.bubbleIns.on('shown', () => {
                this.setResultWidth();
            });
        } else {
            this.setResultWidth();
        }
        this.save();
    }
    setResultWidth() {
        if (this.resultDom) {
            this.resultDom.style.maxWidth = this.panelsDom.getBoundingClientRect().width + 'px';
        }
    }
    openTimeToPrevent(cols) {
        let timeCols = cols || this.data.time.map(k => k.colsDom).flat(Infinity);
        timeCols.forEach(k => {
            this.showForemost(k);
            axPreventScroll(k);
        });
    }
    searchYearToRefresh(input, hide = true) {
        let value = input.value;
        if (value && !isNaN(value) && (value.length === 3 || value.length === 4)) {
            this.data.startDate.setFullYear(~~value);
            this.createPanels();
            hide ? axHide(this.data.year.panelDom) : null;
        } else {
            new axMessage({
                result: 'error',
                iconShow: true,
                content: this.options.language.message.requireYearFormat,
            }).show();
        }
    }
    createPanelDayList(elem, dateObj) {
        elem.innerHTML = '';
        let curDate = axDateMethod.toDate(dateObj, this.data.type);
        curDate.setDate(1);
        let list = [],
            startIndex,
            curMonth = curDate.getMonth(),
            curYear = curDate.getFullYear(),
            monthDays = axDateMethod.getDays(curDate),
            preDate = axDateMethod.getChain(curDate, { MM: -1 }),
            prevMonth = preDate.getMonth(),
            prevYear = preDate.getFullYear(),
            nextDate = axDateMethod.getChain(curDate, { MM: 1 }),
            nextMonth = nextDate.getMonth(),
            nextYear = nextDate.getFullYear(),
            fragment = document.createDocumentFragment();
        if (this.options.weekStart === 'monday') {
            if (curDate.getDay() === 0) {
                startIndex = 7;
            } else {
                startIndex = curDate.getDay();
            }
        } else {
            if (curDate.getDay() === 0) {
                startIndex = 1;
            } else {
                startIndex = curDate.getDay() + 1;
            }
        }
        let day = 1;
        for (let gridIndex = 1; gridIndex <= 42;) {
            let dayObj = {
                wrapperDom: axAddElem('li'),
                contentDom: axAddElem('span', { content: '' }),
                labelDom: axAddElem('i', { label: '' }),
            }, label;
            dayObj.wrapperDom.appendChild(dayObj.contentDom);
            dayObj.contentDom.appendChild(dayObj.labelDom);
            if (gridIndex < startIndex) {
                label = axDateMethod.getDays({ YYYY: prevYear, MM: prevMonth }) - startIndex + gridIndex + 1;
                dayObj.value = { YYYY: prevYear, MM: prevMonth, DD: label };
                dayObj.exceed = true;
                dayObj.wrapperDom.setAttribute('exceed', '');
            } else if (gridIndex >= startIndex + monthDays) {
                label = gridIndex - startIndex - monthDays + 1;
                dayObj.value = { YYYY: nextYear, MM: nextMonth, DD: label };
                dayObj.exceed = true;
                dayObj.wrapperDom.setAttribute('exceed', '');
            } else {
                label = day;
                dayObj.value = { YYYY: curYear, MM: curMonth, DD: label };
                day++;
            }
            dayObj.label = label;
            dayObj.labelDom.innerText = label;
            this.limitRange(dayObj, 'date');
            if (this.options.lunar && this.options.lunar.handler) {
                let lunarObj = this.options.lunar.handler(dayObj.value.YYYY, dayObj.value.MM + 1, dayObj.value.DD);
                if (lunarObj && lunarObj != -1) {
                    let lunarContent = '', attr = '';
                    for (let v of this.options.lunar.arrange) {
                        if (this.options.lunar.map.hasOwnProperty(v) && lunarObj[this.options.lunar.map[v]]) {
                            lunarContent = lunarObj[this.options.lunar.map[v]];
                            if (v.includes('Festival')) {
                                attr = 'festival';
                            } else if (v === 'term') {
                                attr = v;
                            }
                            break;
                        }
                    }
                    dayObj.lunarDom = axAddElem('u', '', lunarContent);
                    attr ? dayObj.lunarDom.setAttribute(attr, '') : null;
                    dayObj.labelDom.insertAdjacentElement('afterend', dayObj.lunarDom);
                }
                if (this.options.lunar.tags.length > 0) {
                    for (let v of this.options.lunar.tags) {
                        let date = axDateMethod.toObj(v.date, false, this.data.type),
                            tagDom = axAddElem('s', v.props, v.content);
                        if (JSON.stringify(date) == JSON.stringify(dayObj.value)) {
                            dayObj.contentDom.appendChild(tagDom);
                            break;
                        }
                    }
                }
            }
            if (this.options.event.enable) {
                for (let v of this.options.event.list) {
                    let date = axDateMethod.toObj(v.date, false, this.data.type);
                    if (JSON.stringify(date) == JSON.stringify(dayObj.value)) {
                        dayObj.busy = true;
                        dayObj.wrapperDom.setAttribute('busy', '');
                        break;
                    }
                }
            }
            gridIndex++;
            fragment.appendChild(dayObj.wrapperDom);
            list.push(dayObj);
        }
        elem.appendChild(fragment);
        return list;
    }
    createPanelMonthList(elem, dateObj) {
        let list = [];
        [...elem.children].forEach((k, i) => {
            let obj = {
                wrapperDom: k,
                contentDom: k.querySelector('[content]'),
                value: { YYYY: dateObj.getFullYear(), MM: i }
            };
            this.limitRange(obj, 'month');
            list.push(obj);
        });
        return list;
    }
    createPanelYearList(elem, dateObj) {
        let list = [],
            fragment = document.createDocumentFragment();
        for (let k = 0; k < 18; k++) {
            let year = dateObj.getFullYear() + k,
                wrapper = axAddElem('li', '', `<span content><i label>${year}年</i></span>`),
                obj = {
                    wrapperDom: wrapper,
                    value: { YYYY: year },
                }
            obj.contentDom = obj.wrapperDom.querySelector('[content]');
            this.limitRange(obj, 'year');
            list.push(obj);
            fragment.appendChild(wrapper);
        }
        elem.appendChild(fragment);
        return list;
    }
    createLoopStr(max) {
        let str = '<li>';
        for (let n = 0; n < max; n++) {
            str += `<div> <span content><i label>${axDateMethod.fillZero(n)}</i></span></div> `
        }
        str += '</li>'
        return str;
    }
    createTimeList(label) {
        return `
    <li panel = "time">
                        <span tools><i restore title='${this.options.language.toolTip.restore}'></i><i reset title='${this.options.language.toolTip.reset}'></i><i now title='${this.options.language.toolTip.now}'></i><i hide title='${this.options.language.toolTip.close}'></i></span>
                        <div header>
                            <span time>${label}</span>
                        </div>
                        <div body>
                            <ul column>
                                <li>${this.options.language.unit.h}</li>
                                <li>${this.options.language.unit.m}</li>
                                <li>${this.options.language.unit.s}</li>
                            </ul>
                            <ul list>
                            ${this.createLoopStr(24)}
                            ${this.createLoopStr(60)}
                            ${this.createLoopStr(60)}
                            </ul>
                        </div>
                    </li>
    `;
    }
    toggleTimeList(item, list) {
        this.selectedAttrToggle(item, true);
        let selectedItem = list.find(k => k != item && k.selected);
        if (selectedItem) {
            this.selectedAttrToggle(selectedItem, false);
        }
    }
    getTimeListArr(parent, type) {
        let children = parent.children,
            arr = [];
        [...children].forEach((k, i) => {
            let obj = {
                wrapperDom: k,
                contentDom: k.querySelector('[content]'),
                value: i
            };
            if (!this.options.format.includes(type)) {
                obj.disabled = true;
                obj.wrapperDom.setAttribute('disabled', '');
            }
            this.limitRange(obj, 'time', type);
            arr.push(obj);
        });
        return arr;
    }
    showForemost(parent) {
        let type = axType(parent),
            fun = (elem) => {
                let selectedItem = elem.querySelector('[selected]'),
                    toTop = selectedItem.getBoundingClientRect().height * Math.floor((~~selectedItem.innerText) / 2);
                if (selectedItem && !axChildVisible(selectedItem, elem)) {
                    elem.scrollTop = toTop;
                }
            };
        if (type === 'Array') {
            parent.forEach(k => {
                fun(k);
            });
        } else {
            fun(parent);
        }
    }
    createTimeSelectPanel() {
        this.timePanelsDom = axAddElem('ul', { panels: 'hms' });
        if (this.options.mode === 'range') {
            this.timePanelsDom.innerHTML = this.createTimeList(this.options.language.time.start) + this.createTimeList(this.options.language.time.end);
        } else {
            this.timePanelsDom.innerHTML = this.createTimeList(this.options.language.time.select);
        }
        [...this.timePanelsDom.querySelectorAll('[panel]')].forEach(k => {
            let liArr = [...k.querySelectorAll('[list] li')],
                panelObj = {
                    panelDom: k,
                    colsDom: liArr,
                    restoreDom: k.querySelector('[restore]'),
                    resetDom: k.querySelector('[reset]'),
                    nowDom: k.querySelector('[now]'),
                    closeDom: k.querySelector('[hide]'),
                    value: {},
                    hh: this.getTimeListArr(liArr[0], 'hh'),
                    mm: this.getTimeListArr(liArr[1], 'mm'),
                    ss: this.getTimeListArr(liArr[2], 'ss'),
                };
            this.data.time.push(panelObj);
        });
        this.footerDom.insertAdjacentElement('beforebegin', this.timePanelsDom);
        this.data.time.forEach((k, n) => {
            k.closeDom.onclick = () => {
                axSlideUp(this.timePanelsDom, 'inline-grid');
            }
            k.restoreDom.onclick = () => {
                if (this.raw[n]) {
                    this.setTime(this.raw[n], n, true);
                }
            }
            k.resetDom.onclick = () => {
                this.setTime({ hh: 0, mm: 0, ss: 0 }, n, true);
            }
            k.nowDom.onclick = () => {
                let time = axDateMethod.toObj(new Date(), false, this.data.type);
                this.setTime({ hh: time.hh, mm: time.mm, ss: time.ss }, n, true);
            }
            k.hh.forEach(i => {
                i.contentDom.onclick = () => {
                    if (i.selected || i.disabled) {
                        return false;
                    }
                    this.toggleTimeList(i, k.hh);
                    k.value.hh = i.value;
                    this.timeToUpdate(k, n, true);
                    this.handlers.hasOwnProperty('setTime') ? this.emit('setTime', i) : null;
                    this.options.onSetTime && this.options.onSetTime.call(this, i);
                }
            });
            k.mm.forEach(i => {
                i.contentDom.onclick = () => {
                    if (i.selected || i.disabled) {
                        return false;
                    }
                    this.toggleTimeList(i, k.mm);
                    k.value.mm = i.value;
                    this.timeToUpdate(k, n, true);
                    this.handlers.hasOwnProperty('setTime') ? this.emit('setTime', i) : null;
                    this.options.onSetTime && this.options.onSetTime.call(this, i);
                }
            });
            k.ss.forEach(i => {
                i.contentDom.onclick = () => {
                    if (i.selected || i.disabled) {
                        return false;
                    }
                    this.toggleTimeList(i, k.ss);
                    k.value.ss = i.value;
                    this.timeToUpdate(k, n, true);
                    this.handlers.hasOwnProperty('setTime') ? this.emit('setTime', i) : null;
                    this.options.onSetTime && this.options.onSetTime.call(this, i);
                }
            });
        });
    }
    timeToUpdate(parent, index, updateHTML = false) {
        updateHTML ? this.setTimeBtnHTML() : null;
        if (this.data.type !== 'time' && (this.options.mode === 'single' || this.options.mode === 'range')) {
            if (this.data.selectedDates.length >= index + 1) {
                Object.assign(this.selectedDatesProxy.proxy[index], parent.value);
            }
        }
        if (this.data.type === 'time' && this.options.autoFill) {
            this.confirm(false);
        }
    }
    setTimeBtnHTML() {
        if (!this.data.type.includes('time') || !this.timeBtnDom) {
            return false;
        }
        let timeStr = this.data.time.map(k => {
            if (axIsEmpty(k.value)) {
                return this.options.language.time.select;
            } else {
                return `${axDateMethod.fillZero(k.value.hh)}:${axDateMethod.fillZero(k.value.mm)}:${axDateMethod.fillZero(k.value.ss)}`;
            }
        });
        this.timeBtnDom.innerHTML = timeStr.join('~');
    }
    setTime(timeObj, index = 0, update = false, callback) {
        if (axIsEmpty(timeObj) || !this.data.type.includes('time') || this.destroyed) {
            return false;
        }
        let type = axType(timeObj);
        let setFun = (k, i) => {
            let time;
            if (typeof k === 'string') {
                time = axDateMethod.strToTimeObj(timeObj);
            } else {
                time = k;
            }
            this.data.time[i].value.hh = time.hh;
            this.toggleTimeList(this.data.time[i].hh[time.hh], this.data.time[i].hh);
            this.data.time[i].value.mm = time.mm;
            this.toggleTimeList(this.data.time[i].mm[time.mm], this.data.time[i].mm);
            this.data.time[i].value.ss = time.ss;
            this.toggleTimeList(this.data.time[i].ss[time.ss], this.data.time[i].ss);
            update && this.data.type === 'datetime' ? this.timeToUpdate(this.data.time[i], i) : null;
        }
        if (type === 'Array') {
            timeObj.forEach((k, i) => {
                if (this.data.time.length > i) {
                    setFun(k, i);
                }
            });
        } else {
            setFun(timeObj, index);
        }
        this.setTimeBtnHTML();
        this.handlers.hasOwnProperty('setTime') ? this.emit('setTime', timeObj) : null;
        this.options.onSetTime && this.options.onSetTime.call(this, timeObj);
        callback && callback.call(this);
    }
    assignDaytime() {
        this.selectedDatesProxy.proxy.forEach((k, i) => {
            if (this.data.time[i]) {
                Object.assign(k, this.data.time[i].value);
            }
        });
    }
    confirm(hide = this.options.confirmHide, callback) {
        if (this.destroyed) {
            return this;
        }
        let result = '';
        if (this.data.type !== 'time') {
            if (this.options.mode === 'range') {
                if (this.data.selectedDates.length === 0) {
                    result = '';
                } else if (this.data.selectedDates.length === 2) {
                    let startStr = axDateMethod.fillFormat(this.data.selectedDates[0], this.options.format),
                        endStr = axDateMethod.fillFormat(this.data.selectedDates[1], this.options.format);
                    result = `${startStr}${this.options.language.range}${endStr} `;
                } else {
                    new axMessage({
                        result: 'error',
                        iconShow: true,
                        content: this.options.language.message.requireTwoValue,
                    }).show();
                    return false;
                }
            } else {
                result = this.data.selectedDates.map(k => axDateMethod.fillFormat(k, this.options.format)).join(this.options.separator);
                if (this.options.forceSelect && !result) {
                    new axMessage({
                        result: 'error',
                        iconShow: true,
                        content: this.options.language.message.requireOneSelected,
                    }).show();
                    return false;
                }
            }
        } else {
            result = this.data.time.map(k => axDateMethod.fillFormat(k.value, this.options.format)).join(this.separator);
        }
        this.fillInput(result);
        if (hide && this.bubbleIns) {
            this.bubbleIns.hide();
            let nextIns = this.options.next ? axInstance.find(this.options.next, 'date') : null;
            nextIns && nextIns.bubbleIns ? nextIns.bubbleIns.show() : null;
        }
        this.handlers.hasOwnProperty('confirm') ? this.emit('confirm', result) : null;
        this.options.onConfirm && this.options.onConfirm.call(this, result);
        callback && callback.call(this, result);
    }
    fillInput(text) {
        if (this.inputDom) {
            if (this.inputDom.nodeName === 'INPUT') {
                this.inputDom.value = text;
            } else {
                this.inputDom.innerHTML = text;
            }
        }
        this.save();
    }
    now(hide = this.options.nowHide) {
        if (this.destroyed) {
            return this;
        }
        let date = axDateMethod.toObj(new Date(), false, this.data.type);
        if (this.data.type === 'time') {
            this.setTime(date);
        } else {
            if (this.timePanelsDom && this.options.mode !== 'range') {
                this.setTime(date)
            }
            this.setSelected(date);
        }
        if (hide) {
            this.confirm();
            this.bubbleIns ? this.bubbleIns.hide() : null;
        }
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            if (!props) {
                axLocalStorage.set(this.options.storageName, Object.assign(this.options, { content: this.inputValueToDates(false) }));
            } else {
                !props.hasOwnProperty('content') ? props.content = this.inputValueToDates(false) : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            this.handlers.hasOwnProperty('save') ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
        }, 0);
        return this;
    }
    removeInstances() {
        this.targetDom.remove();
        this.bubbleIns ? (this.bubbleIns.destroy(), this.bubbleIns = null) : null;
        this.detailIns ? (this.detailIns.destroy(), this.detailIns = null) : null;
        this.resultIns ? (this.resultIns.destroy(), this.resultIns = null) : null;
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.removeInstances();
        this.options = axExtend(this.options, setting);
        this.init();
        this.handlers.hasOwnProperty('update') ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.removeInstances();
        this.inputDom.onclick = null;
        this.positionDom ? this.positionDom.onclick = null : null;
        this.buttonDom ? this.buttonDom.onclick = null : null;
        this.destroyed = true;
        this.handlers.hasOwnProperty('destroy') ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    setValuesToObjs(data) {
        let dataType = axType(data),
            arr = [];
        if (dataType === 'Array') {
            arr = data;
        } if (dataType === 'Date') {
            arr = [data];
        } else if (dataType === 'Object') {
            arr = [data];
        } else if (dataType === 'String') {
            let separator;
            if (data.includes(this.options.separator)) {
                separator = this.options.separator;
            } else {
                separator = this.separator;
            }
            arr = data.split(separator);
        }
        if (arr.length === 0) {
            return [];
        } else {
            return arr.map(k => axDateMethod.toObj(k, false, this.data.type));
        }
    }
    set(data, callback) {
        if (axIsEmpty(data) || this.destroyed) {
            return false;
        }
        let objArr = this.setValuesToObjs(data);
        if (objArr.length === 0) {
            return false;
        }
        if (this.options.mode === 'range') {
            if (objArr.length >= 2) {
                objArr.splice(2, objArr.length - 2);
                this.setRange(objArr);
            } else {
                this.setSelected(objArr[0]);
            }
            this.setTime(objArr, '', true);
        } else {
            if (this.options.mode === 'single') {
                this.setSelected(objArr[0]);
                this.setTime(objArr[0], 0, true);
            } else if (this.options.mode === 'multiple') {
                objArr.forEach(k => {
                    this.setSelected(k);
                });
            }
        }
        this.handlers.hasOwnProperty('set') ? this.emit('set', objArr) : null;
        this.options.onSet && this.options.onSet.call(this, objArr);
        callback && callback.call(this, objArr);
        return this;
    }
    setRange(data, callback) {
        if (axIsEmpty(data) || data.length !== 2 || this.destroyed) {
            return false;
        }
        let objArr = data.map(k => axDateMethod.toObj(k, true, this.data.type)),
            curGrids = this.getCurGrids();
        axDateMethod.sort(objArr);
        this.selectedDatesProxy.proxy.splice(0, this.selectedDatesProxy.proxy.length, ...objArr);
        if (!this.inCurPanels(objArr[0], curGrids) && !this.inCurPanels(objArr[1], curGrids)) {
            this.createPanels(objArr[0]);
        } else {
            this.setTime(objArr);
        }
        this.setRangeAttr();
        this.handlers.hasOwnProperty('ranged') ? this.emit('ranged', objArr) : null;
        this.options.onRanged && this.options.onRanged.call(this, objArr);
        callback && callback.call(this, objArr);
        return this;
    }
    /*     disable(data, callback) {
            if (axIsEmpty(data)) {
                return false;
            }
            let objArr = this.setValuesToObjs(data);
            if (objArr.length === 0) {
                return false;
            }
            objArr.forEach(k => {
                this.setDisabled(k);
            });
            'disabled' in this.handlers ? this.emit('disabled', objArr) : null;
            this.options.onDisabled && this.options.onDisabled.call(this, objArr);
            callback && callback.call(this, objArr);
            return this;
        } */
    cancel(data, callback) {
        if (axIsEmpty(data) || this.destroyed) {
            return false;
        }
        let objArr = this.setValuesToObjs(data);
        if (objArr.length === 0) {
            return false;
        }
        objArr.forEach(k => {
            this.setUnselected(k);
        });
        this.handlers.hasOwnProperty('cancel') ? this.emit('cancel', objArr) : null;
        this.options.onCancel && this.options.onCancel.call(this, objArr);
        callback && callback.call(this, objArr);
        return this;
    }
    clear(resetTime = true, callback) {
        if (this.destroyed) {
            return this;
        }
        if (this.data.type !== 'time') {
            this.selectedDatesProxy.proxy.splice(0);
            this.resultIns ? this.resultIns.clear() : null;
            let curGrids = this.getCurGrids();
            curGrids.forEach(k => {
                if (k.selected) {
                    this.selectedAttrToggle(k, false);
                }
                this.removeRangeAttr(k);
            });
        }
        if (resetTime && this.timePanelsDom) {
            for (let k in this.data.time) {
                this.setTime({ hh: 0, mm: 0, ss: 0 }, k);
            }
        }
        this.handlers.hasOwnProperty('clear') ? this.emit('clear', '') : null;
        this.options.onClear && this.options.onClear.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* document.querySelectorAll('[axDate]').forEach(element => {
    new axDate(element);
}); */
/*!
* 插件：轮滑选择；改造自ion.rangeSlider | https://github.com/IonDen/ion.rangeSlider；使用方法：new axRange('#id',{参数})
*/
const axRanges = [];
class axRange {
    constructor(targetDom, options) {
        if ((typeof targetDom) === 'string') {
            this.targetDom = document.querySelector(targetDom);
        } else {
            this.targetDom = targetDom;
        }
        if (!(this instanceof axRange)) return new axRange(targetDom, options);
        let _this = this;
        this.calcCount = 0;
        this.updateTm = 0;
        this.oldFrom = 0;
        this.oldTo = 0;
        this.oldMinInterval = null;
        this.rafId = null;
        this.dragging = false;
        this.forceRedraw = false;
        this.noDiapason = false;
        this.hasTabIndex = true;
        this.isKey = false;
        this.isUpdate = false;
        this.isStart = true;
        this.isFinish = false;
        this.isActive = false;
        this.isResize = false;
        this.isClick = false;
        this.target = "base";
        this.cache = {
            win: window,
            body: document.body,
            targetDom: this.targetDom,
            cont: null,
            rs: null,
            min: null,
            max: null,
            from: null,
            to: null,
            single: null,
            bar: null,
            line: null,
            s_single: null,
            s_from: null,
            s_to: null,
            shad_single: null,
            shad_from: null,
            shad_to: null,
            edge: null,
            grid: null,
            grid_labels: []
        };
        this.coords = {
            x_gap: 0,
            x_pointer: 0,
            w_rs: 0,
            w_rs_old: 0,
            w_handle: 0,
            p_gap: 0,
            p_gap_left: 0,
            p_gap_right: 0,
            p_step: 0,
            p_pointer: 0,
            p_handle: 0,
            p_single_fake: 0,
            p_single_real: 0,
            p_from_fake: 0,
            p_from_real: 0,
            p_to_fake: 0,
            p_to_real: 0,
            p_bar_x: 0,
            p_bar_w: 0,
            grid_gap: 0,
            big_num: 0,
            big: [],
            big_w: [],
            big_p: [],
            big_x: []
        };
        this.labels = {
            w_min: 0,
            w_max: 0,
            w_from: 0,
            w_to: 0,
            w_single: 0,
            p_min: 0,
            p_max: 0,
            p_from_fake: 0,
            p_from_left: 0,
            p_to_fake: 0,
            p_to_left: 0,
            p_single_fake: 0,
            p_single_left: 0
        };
        if (this.targetDom.nodeName !== "INPUT") {
            console && console.warn && console.warn("Base targetDom should be <input>!", input);
        }
        this.config = {
            className: "",
            type: "single",
            min: 0,
            max: 100,
            from: null,
            to: null,
            step: 1,
            minInterval: 0,
            maxInterval: 0,
            dragInterval: false,
            values: [],
            pValues: [],
            fromStick: false,
            fromMin: null,
            fromMax: null,
            fromShadow: false,
            toStick: false,
            toMin: null,
            toMax: null,
            toShadow: false,
            prettifyEnabled: false,
            prettifySeparator: " ",
            prettify: null,
            forceEdges: false,
            keyboard: true,
            grid: false,
            gridMargin: true,
            gridNum: 4,
            gridSnap: false,
            hideLabelTrack: false,
            hideLabelSlider: false,
            prefix: "",
            postfix: "",
            maxPostfix: "",
            decorateBoth: true,
            valuesSeparator: " — ",
            inputValuesSeparator: ";",
            disabled: false,
            block: false,
            scope: null,
            onStart: null,
            onChange: null,
            onFinish: null,
            onUpdate: null
        }
        let val = this.targetDom.value;
        if (val !== undefined && val !== "") {
            if (options && options.inputValuesSeparator) {
                val = val.split(options.inputValuesSeparator);
            } else {
                val = val.split(";");
            }
            if (val[0] && val[0] == +val[0]) {
                val[0] = +val[0];
            }
            if (val[1] && val[1] == +val[1]) {
                val[1] = +val[1];
            }
            if (options && options.values && options.values.length) {
                this.config.from = val[0] && options.values.indexOf(val[0]);
                this.config.to = val[1] && options.values.indexOf(val[1]);
            } else {
                this.config.from = val[0] && +val[0];
                this.config.to = val[1] && +val[1];
            }
        }
        this.options = axExtend(this.config, options, this.targetDom,'axRange');
        this.targetDom ? this.referName = this.targetDom.getAttribute('axRange') : this.referName = '';
        this.handlers = {};
        this.update_check = {};
        this.result = {
            input: this.cache.targetDom,
            slider: null,
            min: this.options.min,
            max: this.options.max,
            from: this.options.from,
            from_percent: 0,
            from_value: null,
            to: this.options.to,
            to_percent: 0,
            to_value: null
        };
        const base_html =
            '<div class="ax-range-label">' +
            '<span class="ax-range-line" tabindex="0"></span>' +
            '<span class="ax-range-min">0</span><span class="ax-range-max">1</span>' +
            '<span class="ax-range-from">0</span><span class="ax-range-to">0</span><span class="ax-range-single">0</span>' +
            '</div>' +
            '<div class="ax-range-grid">1</div>';
        const single_html =
            '<div class="ax-range-bar ax-range-bar-single"></div>' +
            '<div class="ax-range-shadow ax-shadow-single"></div>' +
            '<span class="ax-range-handle ax-single"><i></i><i></i><i></i></span>';
        const double_html =
            '<div class="ax-range-bar"></div>' +
            '<div class="ax-range-shadow ax-shadow-from"></div>' +
            '<div class="ax-range-shadow ax-shadow-to"></div>' +
            '<span class="ax-range-handle ax-from"><i></i><i></i><i></i></span>' +
            '<span class="ax-range-handle ax-to"><i></i><i></i><i></i></span>';
        const disable_html =
            '<div class="ax-disabled-mask"></div>';
        this.ready = function (update) {
            this.noDiapason = false;
            this.coords.p_step = convertToPercent(this.options.step, true);
            this.target = "base";
            this.toggleInput();
            append();
            setMinMax();
            if (update) {
                this.forceRedraw = true;
                calc(true);
                callOnUpdate();
            } else {
                this.forceRedraw = true;
                calc(true);
                callOnStart();
            }
            updateScene();
        };
        const append = function () {
            const container_html = '<div class="ax-range ' + _this.options.className + '"></div>';
            _this.cache.targetDom.insertAdjacentHTML('beforebegin', container_html);
            _this.cache.targetDom.setAttribute("readonly", "true");
            _this.cache.cont = _this.cache.targetDom.previousElementSibling;
            _this.result.slider = _this.cache.cont;
            _this.cache.cont.innerHTML = base_html;
            _this.cache.label = _this.cache.cont.querySelector(".ax-range-label");
            _this.cache.min = _this.cache.cont.querySelector(".ax-range-min");
            _this.cache.max = _this.cache.cont.querySelector(".ax-range-max");
            _this.cache.from = _this.cache.cont.querySelector(".ax-range-from");
            _this.cache.to = _this.cache.cont.querySelector(".ax-range-to");
            _this.cache.single = _this.cache.cont.querySelector(".ax-range-single");
            _this.cache.line = _this.cache.cont.querySelector(".ax-range-line");
            _this.cache.grid = _this.cache.cont.querySelector(".ax-range-grid");
            if (_this.options.type === "single") {
                _this.cache.cont.insertAdjacentHTML('beforeend', single_html);
                _this.cache.bar = _this.cache.cont.querySelector(".ax-range-bar");
                _this.cache.edge = _this.cache.cont.querySelector(".ax-range-bar-single");
                _this.cache.s_single = _this.cache.cont.querySelector(".ax-single");
                _this.cache.from.style.visibility = "hidden";
                _this.cache.to.style.visibility = "hidden";
                _this.cache.shad_single = _this.cache.cont.querySelector(".ax-shadow-single");
            } else {
                _this.cache.cont.insertAdjacentHTML('beforeend', double_html);
                _this.cache.bar = _this.cache.cont.querySelector(".ax-range-bar");
                _this.cache.s_from = _this.cache.cont.querySelector(".ax-from");
                _this.cache.s_to = _this.cache.cont.querySelector(".ax-to");
                _this.cache.shad_from = _this.cache.cont.querySelector(".ax-shadow-from");
                _this.cache.shad_to = _this.cache.cont.querySelector(".ax-shadow-to");
                setTopHandler();
            }
            if (_this.options.hideLabelSlider) {
                _this.cache.from.style.display = "none";
                _this.cache.to.style.display = "none";
                _this.cache.single.style.display = "none";
            }
            appendGrid();
            if (_this.options.disabled) {
                appendDisableMask();
                _this.cache.targetDom.disabled = true;
            } else {
                _this.cache.targetDom.disabled = false;
                removeDisableMask();
                bindEvents();
            }
            if (!_this.options.disabled) {
                if (_this.options.block) {
                    appendDisableMask();
                } else {
                    removeDisableMask();
                }
            }
            if (_this.options.dragInterval) {
                _this.cache.bar.style.cursor = "ew-resize";
            }
        };
        const setTopHandler = function () {
            const min = _this.options.min,
                max = _this.options.max,
                from = _this.options.from,
                to = _this.options.to;
            if (from > min && to === max) {
                _this.cache.s_from.classList.add("ax-last");
            } else if (to < max) {
                _this.cache.s_to.classList.add("ax-last");
            }
        };
        /**
         * Determine which handles was clicked last and which handler should have hover effect
         *
         * @param _this.target {String}
         */
        const changeLevel = function (target) {
            switch (_this.target) {
                case "single":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_single_fake);
                    _this.cache.s_single.classList.add("ax-hover");
                    break;
                case "from":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_from_fake);
                    _this.cache.s_from.classList.add("ax-hover", "ax-last");
                    _this.cache.s_to.classList.remove("ax-last");
                    break;
                case "to":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_to_fake);
                    _this.cache.s_to.classList.add("ax-hover", "ax-last");
                    _this.cache.s_from.classList.remove("ax-last");
                    break;
                case "both":
                    _this.coords.p_gap_left = toFixed(_this.coords.p_pointer - _this.coords.p_from_fake);
                    _this.coords.p_gap_right = toFixed(_this.coords.p_to_fake - _this.coords.p_pointer);
                    _this.cache.s_to.classList.remove("ax-last");
                    _this.cache.s_from.classList.remove("ax-last");
                    break;
            }
        };
        /**
         * Then slider is disabled -> append extra layer with opacity
         */
        const appendDisableMask = function () {
            _this.cache.cont.insertAdjacentHTML('beforeend', disable_html);
            _this.cache.cont.classList.add("ax-disabled");
        };
        /**
         * Then slider is not disabled -> remove disable mask
         */
        const removeDisableMask = function () {
            _this.cache.cont.classList.remove(".ax-disabled-mask");
            _this.cache.cont.classList.remove("ax-disabled");
        };
        this.remove = function () {
            this.cache.cont.remove();
            this.cache.cont = null;
            this.cache.win.removeEventListener("keydown", key.bind(this, 'keyboard'));
            this.cache.body.removeEventListener("touchmove", pointerMove.bind(this));
            this.cache.body.removeEventListener("mousemove", pointerMove.bind(this));
            this.cache.win.removeEventListener("touchend", pointerUp.bind(this));
            this.cache.win.removeEventListener("mouseup", pointerUp.bind(this));
            this.cache.grid_labels = [];
            this.coords.big = [];
            this.coords.big_w = [];
            this.coords.big_p = [];
            this.coords.big_x = [];
            cancelAnimationFrame(this.rafId);
        };
        const bindEvents = function () {
            if (_this.noDiapason) {
                return;
            }
            _this.cache.body.addEventListener('touchmove', pointerMove.bind(this));
            _this.cache.body.addEventListener('mousemove', pointerMove.bind(this));
            _this.cache.win.addEventListener('touchend', pointerUp.bind(this));
            _this.cache.win.addEventListener('mouseup', pointerUp.bind(this));
            _this.cache.line.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
            _this.cache.line.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            _this.cache.line.addEventListener('focus', pointerFocus.bind(this));
            if (_this.options.dragInterval && _this.options.type === "double") {
                _this.cache.bar.addEventListener('touchstart', pointerDown.bind(this, 'both'), { passive: true });
                _this.cache.bar.addEventListener('mousedown', pointerDown.bind(this, 'both'));
            } else {
                _this.cache.bar.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.bar.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            }
            if (_this.options.type === "single") {
                _this.cache.single.addEventListener('touchstart', pointerDown.bind(this, 'single'), { passive: true });
                _this.cache.s_single.addEventListener('touchstart', pointerDown.bind(this, 'single'), { passive: true });
                _this.cache.shad_single.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.single.addEventListener('mousedown', pointerDown.bind(this, 'single'));
                _this.cache.s_single.addEventListener('mousedown', pointerDown.bind(this, 'single'));
                _this.cache.edge.addEventListener('mousedown', pointerClick.bind(this, 'click'));
                _this.cache.shad_single.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
            } else {
                _this.cache.single.addEventListener('touchstart', pointerDown.bind(this, null), { passive: true });
                _this.cache.single.addEventListener('mousedown', pointerDown.bind(this, null));
                _this.cache.from.addEventListener('touchstart', pointerDown.bind(this, 'from'), { passive: true });
                _this.cache.s_from.addEventListener('touchstart', pointerDown.bind(this, 'from'), { passive: true });
                _this.cache.to.addEventListener('touchstart', pointerDown.bind(this, 'to'), { passive: true });
                _this.cache.s_to.addEventListener('touchstart', pointerDown.bind(this, 'to'), { passive: true });
                _this.cache.shad_from.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.shad_to.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.from.addEventListener('mousedown', pointerDown.bind(this, 'from'));
                _this.cache.s_from.addEventListener('mousedown', pointerDown.bind(this, 'from'));
                _this.cache.to.addEventListener('mousedown', pointerDown.bind(this, 'to'));
                _this.cache.s_to.addEventListener('mousedown', pointerDown.bind(this, 'to'));
                _this.cache.shad_from.addEventListener('mousedown', pointerClick.bind(this, 'click'));
                _this.cache.shad_to.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            }
            if (_this.options.keyboard) {
                _this.cache.line.addEventListener('keydown', key.bind(this, 'keyboard'));
            }
        };
        /**
         * Focus with tabIndex
         *
         * @param e {Object} event object
         */
        const pointerFocus = function (e) {
            if (!_this.target) {
                let x, $handle;
                if (_this.options.type === "single") {
                    $handle = _this.cache.single;
                } else {
                    $handle = _this.cache.from;
                }
                x = $handle.getBoundingClientRect().left;
                x += ($handle.getBoundingClientRect().width / 2) - 1;
                pointerClick("single", { preventDefault: function () { }, pageX: x });
            } else {
                _this.cache.line.focus();
            }
        };
        const pointerMove = function (e) {
            if (!_this.dragging) {
                return;
            }
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            _this.coords.x_pointer = x - _this.coords.x_gap;
            calc();
        };
        const pointerUp = function (e) {
            if (_this.isActive) {
                _this.isActive = false;
            } else {
                return;
            }
            const hoverState = _this.cache.cont.querySelector(".ax-hover");
            if (hoverState) {
                hoverState.classList.remove("ax-hover");
            }
            _this.forceRedraw = true;
            updateScene();
            restoreOriginalMinInterval();
            if (_this.cache.cont.contains(e.target) || _this.dragging) {
                callOnFinish();
            }
            _this.dragging = false;
        };
        const pointerDown = function (destination, e) {
            axPreventDefault(e);
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            if (e.button === 2) {
                return;
            }
            if (destination === "both") {
                setTempMinInterval();
            }
            if (!destination) {
                destination = _this.target || "from";
            }
            _this.target = destination;
            _this.isActive = true;
            _this.dragging = true;
            _this.coords.x_gap = _this.cache.label.getBoundingClientRect().left;
            _this.coords.x_pointer = x - _this.coords.x_gap;
            calcPointerPercent();
            changeLevel(destination);
            _this.cache.line.dispatchEvent(new Event("focus"));
            updateScene();
        };
        const pointerClick = function (destination, e) {
            axPreventDefault(e);
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            if (e.button === 2) {
                return;
            }
            _this.target = destination;
            _this.isClick = true;
            _this.coords.x_gap = _this.cache.label.getBoundingClientRect().left;
            _this.coords.x_pointer = +(x - _this.coords.x_gap).toFixed();
            _this.forceRedraw = true;
            calc();
            _this.cache.line.dispatchEvent(new Event("focus"));
        };
        const key = function (destination, e) {
            if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                return;
            }
            switch (e.which) {
                case 83: 
                case 65: 
                case 40: 
                case 37: 
                axPreventDefault(e);
                    moveByKey(false);
                    break;
                case 87: 
                case 68: 
                case 38: 
                case 39: 
                axPreventDefault(e);
                    moveByKey(true);
                    break;
            }
        };
        const moveByKey = function (right) {
            let p = _this.coords.p_pointer;
            const p_step = _this.options.step / ((_this.options.max - _this.options.min) / 100);
            right ? p += p_step : p -= p_step;
            _this.coords.x_pointer = toFixed(_this.coords.w_rs / 100 * p);
            _this.isKey = true;
            calc();
        };
        const setMinMax = function () {
            if (!_this.options) {
                return;
            }
            if (_this.options.hideLabelTrack) {
                _this.cache.min.style.display = "none";
                _this.cache.max.style.display = "none";
                return;
            }
            if (_this.options.values.length) {
                _this.cache.min.innerHTML = decorate(_this.options.pValues[_this.options.min]);
                _this.cache.max.innerHTML = decorate(_this.options.pValues[_this.options.max]);
            } else {
                const min_pretty = _prettify(_this.options.min);
                const max_pretty = _prettify(_this.options.max);
                _this.result.min_pretty = min_pretty;
                _this.result.max_pretty = max_pretty;
                _this.cache.min.innerHTML = decorate(min_pretty, _this.options.min);
                _this.cache.max.innerHTML = decorate(max_pretty, _this.options.max);
            }
            _this.labels.w_min = _this.cache.min.offsetWidth;
            _this.labels.w_max = _this.cache.max.offsetWidth;
        };
        /**
         * Then _this.dragging interval, prevent interval collapsing
         * using min_interval option
         */
        const setTempMinInterval = function () {
            const interval = _this.result.to - _this.result.from;
            if (_this.oldMinInterval === null) {
                _this.oldMinInterval = _this.options.minInterval;
            }
            _this.options.minInterval = interval;
        };
        const restoreOriginalMinInterval = function () {
            if (_this.oldMinInterval !== null) {
                _this.options.minInterval = _this.oldMinInterval;
                _this.oldMinInterval = null;
            }
        };
        /**
         * All calculations and measures start here
         *
         * @param update {boolean=}
         */
        const calc = function (update) {
            if (!_this.options) {
                return;
            }
            _this.calcCount++;
            if (_this.calcCount === 10 || update) {
                _this.calcCount = 0;
                _this.coords.w_rs = _this.cache.label.offsetWidth;
                calcHandlePercent();
            }
            if (!_this.coords.w_rs) {
                return;
            }
            calcPointerPercent();
            let handle_x = getHandleX();
            if (_this.target === "both") {
                _this.coords.p_gap = 0;
                handle_x = getHandleX();
            }
            if (_this.target === "click") {
                _this.coords.p_gap = _this.coords.p_handle / 2;
                handle_x = getHandleX();
                if (_this.options.dragInterval) {
                    _this.target = "both_one";
                } else {
                    _this.target = chooseHandle(handle_x);
                }
            }
            switch (_this.target) {
                case "base":
                    const w = (_this.options.max - _this.options.min) / 100,
                        f = (_this.result.from - _this.options.min) / w,
                        t = (_this.result.to - _this.options.min) / w;
                    _this.coords.p_single_real = toFixed(f);
                    _this.coords.p_from_real = toFixed(f);
                    _this.coords.p_to_real = toFixed(t);
                    _this.coords.p_single_real = checkDiapason(_this.coords.p_single_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_single_fake = convertToFakePercent(_this.coords.p_single_real);
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    _this.target = null;
                    break;
                case "single":
                    if (_this.options.fromStick) {
                        break;
                    }
                    _this.coords.p_single_real = convertToRealPercent(handle_x);
                    _this.coords.p_single_real = calcWithStep(_this.coords.p_single_real);
                    _this.coords.p_single_real = checkDiapason(_this.coords.p_single_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_single_fake = convertToFakePercent(_this.coords.p_single_real);
                    break;
                case "from":
                    if (_this.options.fromStick) {
                        break;
                    }
                    _this.coords.p_from_real = convertToRealPercent(handle_x);
                    _this.coords.p_from_real = calcWithStep(_this.coords.p_from_real);
                    if (_this.coords.p_from_real > _this.coords.p_to_real) {
                        _this.coords.p_from_real = _this.coords.p_to_real;
                    }
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkMinInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_real = checkMaxInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    break;
                case "to":
                    if (_this.options.toStick) {
                        break;
                    }
                    _this.coords.p_to_real = convertToRealPercent(handle_x);
                    _this.coords.p_to_real = calcWithStep(_this.coords.p_to_real);
                    if (_this.coords.p_to_real < _this.coords.p_from_real) {
                        _this.coords.p_to_real = _this.coords.p_from_real;
                    }
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_real = checkMinInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_real = checkMaxInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
                case "both":
                    if (_this.options.fromStick || _this.options.toStick) {
                        break;
                    }
                    handle_x = toFixed(handle_x + (_this.coords.p_handle * 0.001));
                    _this.coords.p_from_real = convertToRealPercent(handle_x) - _this.coords.p_gap_left;
                    _this.coords.p_from_real = calcWithStep(_this.coords.p_from_real);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkMinInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_real = convertToRealPercent(handle_x) + _this.coords.p_gap_right;
                    _this.coords.p_to_real = calcWithStep(_this.coords.p_to_real);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_real = checkMinInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
                case "both_one":
                    if (_this.options.fromStick || _this.options.toStick) {
                        break;
                    }
                    const real_x = convertToRealPercent(handle_x),
                        from = _this.result.from_percent,
                        to = _this.result.to_percent,
                        full = to - from,
                        half = full / 2;
                    let new_from = real_x - half,
                        new_to = real_x + half;
                    if (new_from < 0) {
                        new_from = 0;
                        new_to = new_from + full;
                    }
                    if (new_to > 100) {
                        new_to = 100;
                        new_from = new_to - full;
                    }
                    _this.coords.p_from_real = calcWithStep(new_from);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_real = calcWithStep(new_to);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
            }
            if (_this.options.type === "single") {
                _this.coords.p_bar_x = (_this.coords.p_handle / 2);
                _this.coords.p_bar_w = _this.coords.p_single_fake;
                _this.result.from_percent = _this.coords.p_single_real;
                _this.result.from = convertToValue(_this.coords.p_single_real);
                _this.result.from_pretty = _prettify(_this.result.from);
                if (_this.options.values.length) {
                    _this.result.from_value = _this.options.values[_this.result.from];
                }
            } else {
                _this.coords.p_bar_x = toFixed(_this.coords.p_from_fake + (_this.coords.p_handle / 2));
                _this.coords.p_bar_w = toFixed(_this.coords.p_to_fake - _this.coords.p_from_fake);
                _this.result.from_percent = _this.coords.p_from_real;
                _this.result.from = convertToValue(_this.coords.p_from_real);
                _this.result.from_pretty = _prettify(_this.result.from);
                _this.result.to_percent = _this.coords.p_to_real;
                _this.result.to = convertToValue(_this.coords.p_to_real);
                _this.result.to_pretty = _prettify(_this.result.to);
                if (_this.options.values.length) {
                    _this.result.from_value = _this.options.values[_this.result.from];
                    _this.result.to_value = _this.options.values[_this.result.to];
                }
            }
            calcMinMax();
            calcLabels();
        };
        /**
         * calculates pointer X in percent
         */
        const calcPointerPercent = function () {
            if (!_this.coords.w_rs) {
                _this.coords.p_pointer = 0;
                return;
            }
            if (_this.coords.x_pointer < 0 || isNaN(_this.coords.x_pointer)) {
                _this.coords.x_pointer = 0;
            } else if (_this.coords.x_pointer > _this.coords.w_rs) {
                _this.coords.x_pointer = _this.coords.w_rs;
            }
            _this.coords.p_pointer = toFixed(_this.coords.x_pointer / _this.coords.w_rs * 100);
        };
        const convertToRealPercent = function (fake) {
            const full = 100 - _this.coords.p_handle;
            return fake / full * 100;
        };
        const convertToFakePercent = function (real) {
            const full = 100 - _this.coords.p_handle;
            return real / 100 * full;
        };
        const getHandleX = function () {
            const max = 100 - _this.coords.p_handle;
            let x = toFixed(_this.coords.p_pointer - _this.coords.p_gap);
            if (x < 0) {
                x = 0;
            } else if (x > max) {
                x = max;
            }
            return x;
        };
        const calcHandlePercent = function () {
            if (_this.options.type === "single") {
                _this.coords.w_handle = _this.cache.s_single.offsetWidth;
            } else {
                _this.coords.w_handle = _this.cache.s_from.offsetWidth;
            }
            _this.coords.p_handle = toFixed(_this.coords.w_handle / _this.coords.w_rs * 100);
        };
        /**
         * Find closest handle to pointer click
         *
         * @param real_x {Number}
         * @returns {String}
         */
        const chooseHandle = function (real_x) {
            if (_this.options.type === "single") {
                return "single";
            } else {
                const m_point = _this.coords.p_from_real + ((_this.coords.p_to_real - _this.coords.p_from_real) / 2);
                if (real_x >= m_point) {
                    return _this.options.toStick ? "from" : "to";
                } else {
                    return _this.options.fromStick ? "to" : "from";
                }
            }
        };
        /**
         * Measure Min and Max labels width in percent
         */
        const calcMinMax = function () {
            if (!_this.coords.w_rs) {
                return;
            }
            _this.labels.p_min = _this.labels.w_min / _this.coords.w_rs * 100;
            _this.labels.p_max = _this.labels.w_max / _this.coords.w_rs * 100;
        };
        /**
         * Measure labels width and X in percent
         */
        const calcLabels = function () {
            if (!_this.coords.w_rs || _this.options.hideLabelSlider) {
                return;
            }
            if (_this.options.type === "single") {
                _this.labels.w_single = _this.cache.single.offsetWidth;
                _this.labels.p_single_fake = _this.labels.w_single / _this.coords.w_rs * 100;
                _this.labels.p_single_left = _this.coords.p_single_fake + (_this.coords.p_handle / 2) - (_this.labels.p_single_fake / 2);
                _this.labels.p_single_left = checkEdges(_this.labels.p_single_left, _this.labels.p_single_fake);
            } else {
                _this.labels.w_from = _this.cache.from.offsetWidth;
                _this.labels.p_from_fake = _this.labels.w_from / _this.coords.w_rs * 100;
                _this.labels.p_from_left = _this.coords.p_from_fake + (_this.coords.p_handle / 2) - (_this.labels.p_from_fake / 2);
                _this.labels.p_from_left = toFixed(_this.labels.p_from_left);
                _this.labels.p_from_left = checkEdges(_this.labels.p_from_left, _this.labels.p_from_fake);
                _this.labels.w_to = _this.cache.to.offsetWidth;
                _this.labels.p_to_fake = _this.labels.w_to / _this.coords.w_rs * 100;
                _this.labels.p_to_left = _this.coords.p_to_fake + (_this.coords.p_handle / 2) - (_this.labels.p_to_fake / 2);
                _this.labels.p_to_left = toFixed(_this.labels.p_to_left);
                _this.labels.p_to_left = checkEdges(_this.labels.p_to_left, _this.labels.p_to_fake);
                _this.labels.w_single = _this.cache.single.offsetWidth;
                _this.labels.p_single_fake = _this.labels.w_single / _this.coords.w_rs * 100;
                _this.labels.p_single_left = ((_this.labels.p_from_left + _this.labels.p_to_left + _this.labels.p_to_fake) / 2) - (_this.labels.p_single_fake / 2);
                _this.labels.p_single_left = toFixed(_this.labels.p_single_left);
                _this.labels.p_single_left = checkEdges(_this.labels.p_single_left, _this.labels.p_single_fake);
            }
        };
        /**
         * Main function called in request animation frame
         * to update everything
         */
        const updateScene = function () {
            if (_this.rafId) {
                cancelAnimationFrame(_this.rafId);
                _this.rafId = null;
            }
            clearTimeout(_this.updateTm);
            _this.updateTm = null;
            if (!_this.options) {
                return;
            }
            drawHandles();
            if (_this.isActive) {
                _this.rafId = requestAnimationFrame(updateScene);
            } else {
                _this.updateTm = setTimeout(updateScene, 300);
            }
        };
        /**
         * Draw handles
         */
        const drawHandles = function () {
            _this.coords.w_rs = _this.cache.label.offsetWidth;
            if (!_this.coords.w_rs) {
                return;
            }
            if (_this.coords.w_rs !== _this.coords.w_rs_old) {
                _this.target = "base";
                _this.isResize = true;
            }
            if (_this.coords.w_rs !== _this.coords.w_rs_old || _this.forceRedraw) {
                setMinMax();
                calc(true);
                drawLabels();
                if (_this.options.grid) {
                    calcGridMargin();
                    calcGridLabels();
                }
                _this.forceRedraw = true;
                _this.coords.w_rs_old = _this.coords.w_rs;
                drawShadow();
            }
            if (!_this.coords.w_rs) {
                return;
            }
            if (!_this.dragging && !_this.forceRedraw && !_this.isKey) {
                return;
            }
            if (_this.oldFrom !== _this.result.from || _this.oldTo !== _this.result.to || _this.forceRedraw || _this.isKey) {
                drawLabels();
                _this.cache.bar.style.left = _this.coords.p_bar_x + "%";
                _this.cache.bar.style.width = _this.coords.p_bar_w + "%";
                if (_this.options.type === "single") {
                    _this.cache.bar.style.left = "0";
                    _this.cache.bar.style.width = _this.coords.p_bar_w + _this.coords.p_bar_x + "%";
                    _this.cache.s_single.style.left = _this.coords.p_single_fake + "%";
                    _this.cache.single.style.left = _this.labels.p_single_left + "%";
                } else {
                    _this.cache.s_from.style.left = _this.coords.p_from_fake + "%";
                    _this.cache.s_to.style.left = _this.coords.p_to_fake + "%";
                    if (_this.oldFrom !== _this.result.from || _this.forceRedraw) {
                        _this.cache.from.style.left = _this.labels.p_from_left + "%";
                    }
                    if (_this.oldTo !== _this.result.to || _this.forceRedraw) {
                        _this.cache.to.style.left = _this.labels.p_to_left + "%";
                    }
                    _this.cache.single.style.left = _this.labels.p_single_left + "%";
                }
                writeToInput();
                if ((_this.oldFrom !== _this.result.from || _this.oldTo !== _this.result.to) && !_this.isStart) {
                    _this.cache.targetDom.dispatchEvent(new Event("change"));
                    _this.cache.targetDom.dispatchEvent(new Event("input"));
                }
                _this.oldFrom = _this.result.from;
                _this.oldTo = _this.result.to;
                if (!_this.isResize && !_this.isUpdate && !_this.isStart && !_this.isFinish) {
                    callOnChange();
                }
                if (_this.isKey || _this.isClick) {
                    _this.isKey = false;
                    _this.isClick = false;
                    callOnFinish();
                }
                _this.isUpdate = false;
                _this.isResize = false;
                _this.isFinish = false;
            }
            _this.isStart = false;
            _this.isKey = false;
            _this.isClick = false;
            _this.forceRedraw = false;
        };
        /**
         * Draw labels
         * measure labels collisions
         * collapse close labels
         */
        const drawLabels = function () {
            if (!_this.options) {
                return;
            }
            const values_num = _this.options.values.length,
                p_values = _this.options.pValues;
            let text_single,
                text_from,
                text_to,
                from_pretty,
                to_pretty;
            if (_this.options.hideLabelSlider) {
                return;
            }
            if (_this.options.type === "single") {
                if (values_num) {
                    text_single = decorate(p_values[_this.result.from]);
                    _this.cache.single.innerHTML = text_single;
                } else {
                    from_pretty = _prettify(_this.result.from);
                    text_single = decorate(from_pretty, _this.result.from);
                    _this.cache.single.innerHTML = text_single;
                }
                calcLabels();
                if (_this.labels.p_single_left < _this.labels.p_min + 1) {
                    _this.cache.min.style.visibility = "hidden";
                } else {
                    _this.cache.min.style.visibility = "visible";
                }
                if (_this.labels.p_single_left + _this.labels.p_single_fake > 100 - _this.labels.p_max - 1) {
                    _this.cache.max.style.visibility = "hidden";
                } else {
                    _this.cache.max.style.visibility = "visible";
                }
            } else {
                if (values_num) {
                    if (_this.options.decorateBoth) {
                        text_single = decorate(p_values[_this.result.from]);
                        text_single += _this.options.valuesSeparator;
                        text_single += decorate(p_values[_this.result.to]);
                    } else {
                        text_single = decorate(p_values[_this.result.from] + _this.options.valuesSeparator + p_values[_this.result.to]);
                    }
                    text_from = decorate(p_values[_this.result.from]);
                    text_to = decorate(p_values[_this.result.to]);
                    _this.cache.single.innerHTML = text_single;
                    _this.cache.from.innerHTML = text_from;
                    _this.cache.to.innerHTML = text_to;
                } else {
                    from_pretty = _prettify(_this.result.from);
                    to_pretty = _prettify(_this.result.to);
                    if (_this.options.decorateBoth) {
                        text_single = decorate(from_pretty, _this.result.from);
                        text_single += _this.options.valuesSeparator;
                        text_single += decorate(to_pretty, _this.result.to);
                    } else {
                        text_single = decorate(from_pretty + _this.options.valuesSeparator + to_pretty, _this.result.to);
                    }
                    text_from = decorate(from_pretty, _this.result.from);
                    text_to = decorate(to_pretty, _this.result.to);
                    _this.cache.single.innerHTML = text_single;
                    _this.cache.from.innerHTML = text_from;
                    _this.cache.to.innerHTML = text_to;
                }
                calcLabels();
                const min = Math.min(_this.labels.p_single_left, _this.labels.p_from_left),
                    single_left = _this.labels.p_single_left + _this.labels.p_single_fake,
                    to_left = _this.labels.p_to_left + _this.labels.p_to_fake;
                let max = Math.max(single_left, to_left);
                if (_this.labels.p_from_left + _this.labels.p_from_fake >= _this.labels.p_to_left) {
                    _this.cache.from.style.visibility = "hidden";
                    _this.cache.to.style.visibility = "hidden";
                    _this.cache.single.style.visibility = "visible";
                    if (_this.result.from === _this.result.to) {
                        if (_this.target === "from") {
                            _this.cache.from.style.visibility = "visible";
                        } else if (_this.target === "to") {
                            _this.cache.to.style.visibility = "visible";
                        } else if (!_this.target) {
                            _this.cache.from.style.visibility = "visible";
                        }
                        _this.cache.single.style.visibility = "hidden";
                        max = to_left;
                    } else {
                        _this.cache.from.style.visibility = "hidden";
                        _this.cache.to.style.visibility = "hidden";
                        _this.cache.single.style.visibility = "visible";
                        max = Math.max(single_left, to_left);
                    }
                } else {
                    _this.cache.from.style.visibility = "visible";
                    _this.cache.to.style.visibility = "visible";
                    _this.cache.single.style.visibility = "hidden";
                }
                min < _this.labels.p_min + 1 ? _this.cache.min.style.visibility = "hidden" : _this.cache.min.style.visibility = "visible";
                max > 100 - _this.labels.p_max - 1 ? _this.cache.max.style.visibility = "hidden" : _this.cache.max.style.visibility = "visible";
            }
        };
        /**
         * Draw shadow intervals
         */
        const drawShadow = function () {
            const o = _this.options,
                c = _this.cache,
                is_from_min = typeof o.fromMin === "number" && !isNaN(o.fromMin),
                is_from_max = typeof o.fromMax === "number" && !isNaN(o.fromMax),
                is_to_min = typeof o.toMin === "number" && !isNaN(o.toMin),
                is_to_max = typeof o.toMax === "number" && !isNaN(o.toMax);
            let from_min,
                from_max,
                to_min,
                to_max;
            if (o.type === "single") {
                if (o.fromShadow && (is_from_min || is_from_max)) {
                    from_min = convertToPercent(is_from_min ? o.fromMin : o.min);
                    from_max = convertToPercent(is_from_max ? o.fromMax : o.max) - from_min;
                    from_min = toFixed(from_min - (_this.coords.p_handle / 100 * from_min));
                    from_max = toFixed(from_max - (_this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (_this.coords.p_handle / 2);
                    c.shad_single.style.display = "block";
                    c.shad_single.style.left = from_min + "%";
                    c.shad_single.style.width = from_max + "%";
                } else {
                    c.shad_single.style.display = "none";
                }
            } else {
                if (o.fromShadow && (is_from_min || is_from_max)) {
                    from_min = convertToPercent(is_from_min ? o.fromMin : o.min);
                    from_max = convertToPercent(is_from_max ? o.fromMax : o.max) - from_min;
                    from_min = toFixed(from_min - (_this.coords.p_handle / 100 * from_min));
                    from_max = toFixed(from_max - (_this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (_this.coords.p_handle / 2);
                    c.shad_from.style.display = "block";
                    c.shad_from.style.left = from_min + "%";
                    c.shad_from.style.width = from_max + "%";
                } else {
                    c.shad_from.style.display = "none";
                }
                if (o.toShadow && (is_to_min || is_to_max)) {
                    to_min = convertToPercent(is_to_min ? o.toMin : o.min);
                    to_max = convertToPercent(is_to_max ? o.toMax : o.max) - to_min;
                    to_min = toFixed(to_min - (_this.coords.p_handle / 100 * to_min));
                    to_max = toFixed(to_max - (_this.coords.p_handle / 100 * to_max));
                    to_min = to_min + (_this.coords.p_handle / 2);
                    c.shad_to.style.display = "block";
                    c.shad_to.style.left = to_min + "%";
                    c.shad_to.style.width = to_max + "%";
                } else {
                    c.shad_to.style.display = "none";
                }
            }
        };
        /**
         * Write values to input targetDom
         */
        const writeToInput = function () {
            if (_this.options.type === "single") {
                if (_this.options.values.length) {
                    _this.cache.targetDom.setAttribute("value", _this.result.from_value);
                } else {
                    _this.cache.targetDom.setAttribute("value", _this.result.from);
                }
                _this.cache.targetDom.dataset.from = _this.result.from;
            } else {
                if (_this.options.values.length) {
                    _this.cache.targetDom.setAttribute("value", _this.result.from_value + _this.options.inputValuesSeparator + _this.result.to_value);
                } else {
                    _this.cache.targetDom.setAttribute("value", _this.result.from + _this.options.inputValuesSeparator + _this.result.to);
                }
                _this.cache.targetDom.dataset.from = _this.result.from;
                _this.cache.targetDom.dataset.to = _this.result.to;
            }
        };
        const callOnStart = function () {
            writeToInput();
            if (_this.options.onStart && typeof _this.options.onStart === "function") {
                if (_this.options.scope) {
                    _this.options.onStart.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onStart(_this.result);
                }
            }
        };
        const callOnChange = function () {
            writeToInput();
            if (_this.options.onChange && typeof _this.options.onChange === "function") {
                if (_this.options.scope) {
                    _this.options.onChange.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onChange(_this.result);
                }
            }
        };
        const callOnFinish = function () {
            writeToInput();
            if (_this.options.onFinish && typeof _this.options.onFinish === "function") {
                if (_this.options.scope) {
                    _this.options.onFinish.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onFinish(_this.result);
                }
            }
        };
        const callOnUpdate = function () {
            writeToInput();
            if (_this.options.onUpdate && typeof _this.options.onUpdate === "function") {
                if (_this.options.scope) {
                    _this.options.onUpdate.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onUpdate(_this.result);
                }
            }
        };
        this.toggleInput = function () {
            this.cache.targetDom.classList.toggle("ax-range-input");
            if (this.hasTabIndex) {
                this.cache.targetDom.setAttribute("tabindex", "-1");
            } else {
                this.cache.targetDom.removeAttribute("tabindex");
            }
            this.hasTabIndex = !this.hasTabIndex;
        };
        /**
         * Convert real value to percent
         *
         * @param value {Number} X in real
         * @param no_min {boolean=} don't use min value
         * @returns {Number} X in percent
         */
        const convertToPercent = function (value, no_min) {
            let diapason = _this.options.max - _this.options.min,
                one_percent = diapason / 100,
                val, percent;
            if (!diapason) {
                _this.noDiapason = true;
                return 0;
            }
            if (no_min) {
                val = value;
            } else {
                val = value - _this.options.min;
            }
            percent = val / one_percent;
            return toFixed(percent);
        };
        /**
         * Convert percent to real values
         *
         * @param percent {Number} X in percent
         * @returns {Number} X in real
         */
        const convertToValue = function (percent) {
            let min = _this.options.min,
                max = _this.options.max,
                min_decimals = min.toString().split(".")[1],
                max_decimals = max.toString().split(".")[1],
                min_length, max_length,
                avg_decimals = 0,
                abs = 0;
            if (percent === 0) {
                return _this.options.min;
            }
            if (percent === 100) {
                return _this.options.max;
            }
            if (min_decimals) {
                min_length = min_decimals.length;
                avg_decimals = min_length;
            }
            if (max_decimals) {
                max_length = max_decimals.length;
                avg_decimals = max_length;
            }
            if (min_length && max_length) {
                avg_decimals = (min_length >= max_length) ? min_length : max_length;
            }
            if (min < 0) {
                abs = Math.abs(min);
                min = +(min + abs).toFixed(avg_decimals);
                max = +(max + abs).toFixed(avg_decimals);
            }
            let number = ((max - min) / 100 * percent) + min,
                string = _this.options.step.toString().split(".")[1],
                _result;
            if (string) {
                number = +number.toFixed(string.length);
            } else {
                number = number / _this.options.step;
                number = number * _this.options.step;
                number = +number.toFixed(0);
            }
            if (abs) {
                number -= abs;
            }
            string ? _result = +number.toFixed(string.length) : _result = toFixed(number);
            if (_result < _this.options.min) {
                _result = _this.options.min;
            } else if (_result > _this.options.max) {
                _result = _this.options.max;
            }
            return _result;
        };
        /**
         * Round percent value with step
         *
         * @param percent {Number}
         * @returns percent {Number} rounded
         */
        const calcWithStep = function (percent) {
            let rounded = Math.round(percent / _this.coords.p_step) * _this.coords.p_step;
            if (rounded > 100) {
                rounded = 100;
            }
            if (percent === 100) {
                rounded = 100;
            }
            return toFixed(rounded);
        };
        const checkMinInterval = function (p_current, p_next, type) {
            let o = _this.options, current, next;
            if (!o.minInterval) {
                return p_current;
            }
            current = convertToValue(p_current);
            next = convertToValue(p_next);
            if (type === "from") {
                if (next - current < o.minInterval) {
                    current = next - o.minInterval;
                }
            } else {
                if (current - next < o.minInterval) {
                    current = next + o.minInterval;
                }
            }
            return convertToPercent(current);
        };
        const checkMaxInterval = function (p_current, p_next, type) {
            let o = _this.options, current, next;
            if (!o.maxInterval) {
                return p_current;
            }
            current = convertToValue(p_current);
            next = convertToValue(p_next);
            if (type === "from") {
                if (next - current > o.maxInterval) {
                    current = next - o.maxInterval;
                }
            } else {
                if (current - next > o.maxInterval) {
                    current = next + o.maxInterval;
                }
            }
            return convertToPercent(current);
        };
        const checkDiapason = function (p_num, min, max) {
            let num = convertToValue(p_num);
            typeof min !== 'number' ? min = _this.options.min : min;
            typeof max !== 'number' ? max = _this.options.max : max;
            num < min ? num = min : num;
            num > max ? num = max : num;
            return convertToPercent(num);
        };
        const toFixed = function (num) {
            num = num.toFixed(20);
            return +num;
        };
        const _prettify = function (num) {
            if (!_this.options.prettifyEnabled) {
                return num;
            }
            if (_this.options.prettify && typeof _this.options.prettify === "function") {
                return _this.options.prettify(num);
            } else {
                return prettify(num);
            }
        };
        const prettify = function (num) {
            return num.toString().replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + _this.options.prettifySeparator);
        };
        const checkEdges = function (left, width) {
            if (!_this.options.forceEdges) return toFixed(left);
            left < 0 ? left = 0 : left > 100 - width ? left = 100 - width : left;
            return toFixed(left);
        };
        this.validate = function () {
            let o = this.options,
                r = this.result,
                v = o.values,
                vl = v.length,
                value,
                i;
            if (typeof o.min === "string") o.min = +o.min;
            if (typeof o.max === "string") o.max = +o.max;
            if (typeof o.from === "string") o.from = +o.from;
            if (typeof o.to === "string") o.to = +o.to;
            if (typeof o.step === "string") o.step = +o.step;
            if (typeof o.fromMin === "string") o.fromMin = +o.fromMin;
            if (typeof o.fromMax === "string") o.fromMax = +o.fromMax;
            if (typeof o.toMin === "string") o.toMin = +o.toMin;
            if (typeof o.toMax === "string") o.toMax = +o.toMax;
            if (typeof o.gridNum === "string") o.gridNum = +o.gridNum;
            if (o.max < o.min) {
                o.max = o.min;
            }
            if (vl) {
                o.pValues = [];
                o.min = 0;
                o.max = vl - 1;
                o.step = 1;
                o.gridNum = o.max;
                o.gridSnap = true;
                for (i = 0; i < vl; i++) {
                    value = +v[i];
                    if (!isNaN(value)) {
                        v[i] = value;
                        value = _prettify(value);
                    } else {
                        value = v[i];
                    }
                    o.pValues.push(value);
                }
            }
            if (typeof o.from !== "number" || isNaN(o.from)) o.from = o.min;
            if (typeof o.to !== "number" || isNaN(o.to)) o.to = o.max;
            if (o.type === "single") {
                if (o.from < o.min) o.from = o.min;
                if (o.from > o.max) o.from = o.max;
            } else {
                if (o.from < o.min) o.from = o.min;
                if (o.from > o.max) o.from = o.max;
                if (o.to < o.min) o.to = o.min;
                if (o.to > o.max) o.to = o.max;
                if (_this.update_check.from) {
                    if (_this.update_check.from !== o.from) {
                        if (o.from > o.to) o.from = o.to;
                    }
                    if (_this.update_check.to !== o.to) {
                        if (o.to < o.from) o.to = o.from;
                    }
                }
                if (o.from > o.to) o.from = o.to;
                if (o.to < o.from) o.to = o.from;
            }
            if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
                o.step = 1;
            }
            if (typeof o.fromMin === "number" && o.from < o.fromMin) {
                o.from = o.fromMin;
            }
            if (typeof o.fromMax === "number" && o.from > o.fromMax) {
                o.from = o.fromMax;
            }
            if (typeof o.toMin === "number" && o.to < o.toMin) {
                o.to = o.toMin;
            }
            if (typeof o.toMax === "number" && o.from > o.toMax) {
                o.to = o.toMax;
            }
            if (r) {
                if (r.min !== o.min) r.min = o.min;
                if (r.max !== o.max) r.max = o.max;
                if (r.from < r.min || r.from > r.max) r.from = o.from;
                if (r.to < r.min || r.to > r.max) r.to = o.to;
            }
            if (typeof o.minInterval !== "number" || isNaN(o.minInterval) || !o.minInterval || o.minInterval < 0) {
                o.minInterval = 0;
            }
            if (typeof o.maxInterval !== "number" || isNaN(o.maxInterval) || !o.maxInterval || o.maxInterval < 0) {
                o.maxInterval = 0;
            }
            if (o.minInterval && o.minInterval > o.max - o.min) {
                o.minInterval = o.max - o.min;
            }
            if (o.maxInterval && o.maxInterval > o.max - o.min) {
                o.maxInterval = o.max - o.min;
            }
        };
        const decorate = function (num, original) {
            let decorated = "",
                o = _this.options;
            if (o.prefix) {
                decorated += o.prefix;
            }
            decorated += num;
            if (o.maxPostfix) {
                if (o.values.length && num === o.pValues[o.max]) {
                    decorated += o.maxPostfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                } else if (original === o.max) {
                    decorated += o.maxPostfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                }
            }
            if (o.postfix) {
                decorated += o.postfix;
            }
            return decorated;
        };
        const updateFrom = function () {
            _this.result.from = _this.options.from;
            _this.result.from_percent = convertToPercent(_this.result.from);
            _this.result.from_pretty = _prettify(_this.result.from);
            if (_this.options.values) {
                _this.result.from_value = _this.options.values[_this.result.from];
            }
        };
        const updateTo = function () {
            _this.result.to = _this.options.to;
            _this.result.to_percent = convertToPercent(_this.result.to);
            _this.result.to_pretty = _prettify(_this.result.to);
            if (_this.options.values) {
                _this.result.to_value = _this.options.values[_this.result.to];
            }
        };
        this.updateResult = function () {
            this.result.min = this.options.min;
            this.result.max = this.options.max;
            updateFrom();
            updateTo();
        };
        const appendGrid = function () {
            if (!_this.options.grid) {
                return;
            }
            let o = _this.options,
                i, z,
                total = o.max - o.min,
                big_num = o.gridNum,
                big_p = 0,
                big_w = 0,
                small_max = 4,
                local_small_max,
                small_p,
                small_w = 0,
                _result,
                html = '';
            calcGridMargin();
            if (o.gridSnap) {
                big_num = total / o.step;
            }
            if (big_num > 50) big_num = 50;
            big_p = toFixed(100 / big_num);
            if (big_num > 4) {
                small_max = 3;
            }
            if (big_num > 7) {
                small_max = 2;
            }
            if (big_num > 14) {
                small_max = 1;
            }
            if (big_num > 28) {
                small_max = 0;
            }
            for (i = 0; i < big_num + 1; i++) {
                local_small_max = small_max;
                big_w = toFixed(big_p * i);
                if (big_w > 100) {
                    big_w = 100;
                }
                _this.coords.big[i] = big_w;
                small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);
                for (z = 1; z <= local_small_max; z++) {
                    if (big_w === 0) {
                        break;
                    }
                    small_w = toFixed(big_w - (small_p * z));
                    html += '<span class="ax-range-grid-pol ax-small" style="left: ' + small_w + '%"></span>';
                }
                html += '<span class="ax-range-grid-pol" style="left: ' + big_w + '%"></span>';
                _result = convertToValue(big_w);
                if (o.values.length) {
                    _result = o.pValues[_result];
                } else {
                    _result = _prettify(_result);
                }
                html += '<span class="ax-range-grid-text ax-grid-text-' + i + '" style="left: ' + big_w + '%">' + _result + '</span>';
            }
            _this.coords.big_num = Math.ceil(big_num + 1);
            _this.cache.cont.classList.add("ax-with-grid");
            _this.cache.grid.innerHTML = html;
            cacheridLabels();
        };
        const cacheridLabels = function () {
            for (let i = 0; i < _this.coords.big_num; i++) {
                _this.cache.grid_labels.push(_this.cache.grid.querySelector(".ax-grid-text-" + i));
            }
            calcGridLabels();
        };
        const calcGridLabels = function () {
            const start = [], finish = [],
                num = _this.coords.big_num;
            for (let i = 0; i < num; i++) {
                _this.coords.big_w[i] = _this.cache.grid_labels[i].offsetWidth;
                _this.coords.big_p[i] = toFixed(_this.coords.big_w[i] / _this.coords.w_rs * 100);
                _this.coords.big_x[i] = toFixed(_this.coords.big_p[i] / 2);
                start[i] = toFixed(_this.coords.big[i] - _this.coords.big_x[i]);
                finish[i] = toFixed(start[i] + _this.coords.big_p[i]);
            }
            if (_this.options.forceEdges) {
                if (start[0] < -_this.coords.grid_gap) {
                    start[0] = -_this.coords.grid_gap;
                    finish[0] = toFixed(start[0] + _this.coords.big_p[0]);
                    _this.coords.big_x[0] = _this.coords.grid_gap;
                }
                if (finish[num - 1] > 100 + _this.coords.grid_gap) {
                    finish[num - 1] = 100 + _this.coords.grid_gap;
                    start[num - 1] = toFixed(finish[num - 1] - _this.coords.big_p[num - 1]);
                    _this.coords.big_x[num - 1] = toFixed(_this.coords.big_p[num - 1] - _this.coords.grid_gap);
                }
            }
            calcGridCollision(2, start, finish);
            calcGridCollision(4, start, finish);
            for (let i = 0; i < num; i++) {
                const label = _this.cache.grid_labels[i];
                if (_this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {
                    label.style.marginLeft = -_this.coords.big_x[i] + "%";
                }
            }
        };
        const calcGridCollision = function (step, start, finish) {
            const num = _this.coords.big_num;
            for (let i = 0; i < num; i += step) {
                let next_i = i + (step / 2);
                if (next_i >= num) {
                    break;
                }
                const label = _this.cache.grid_labels[next_i];
                if (finish[i] <= start[next_i]) {
                    label.style.visibility = "visible";
                } else {
                    label.style.visibility = "hidden";
                }
            }
        };
        const calcGridMargin = function () {
            if (!_this.options.gridMargin) {
                return;
            }
            _this.coords.w_rs = _this.cache.label.offsetWidth;
            if (!_this.coords.w_rs) {
                return;
            }
            if (_this.options.type === "single") {
                _this.coords.w_handle = _this.cache.s_single.offsetWidth;
            } else {
                _this.coords.w_handle = _this.cache.s_from.offsetWidth;
            }
            _this.coords.p_handle = toFixed(_this.coords.w_handle / _this.coords.w_rs * 100);
            _this.coords.grid_gap = toFixed((_this.coords.p_handle / 2) - 0.1);
            _this.cache.grid.style.width = toFixed(100 - _this.coords.p_handle) + "%";
            _this.cache.grid.style.left = _this.coords.grid_gap + "%";
        };
        this.init();
    }
    init() {
        this.validate();
        this.ready();
        if (this.referName) {
            if (axIsEmpty(axRanges)) {
                axRanges.push({ name: this.referName, instance: this });
            } else {
                for (let i = 0; i < axRanges.length; i++) {
                    if (axRanges[i].name == this.referName) {
                        axRanges[i].instance = this;
                        break;
                    } else {
                        axRanges.push({ name: this.referName, instance: this });
                    }
                }
            }
        }
    }
    update(options, callback) {
        if (!this.targetDom) {
            return;
        }
        this.isUpdate = true;
        this.options.from = this.result.from;
        this.options.to = this.result.to;
        this.update_check.from = this.result.from;
        this.update_check.to = this.result.to;
        this.options = Object.assign(this.options, options);
        this.validate();
        this.updateResult(options);
        this.toggleInput();
        this.remove();
        this.ready(true);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    reset(callback) {
        if (!this.targetDom) {
            return;
        }
        this.updateResult();
        'reset' in this.handlers ? this.emit('reset', '') : null;
        callback && callback.call(this);
        this.update();
    }
    destroy(callback) {
        if (!this.targetDom) {
            return;
        }
        this.toggleInput();
        this.targetDom.removeAttribute("readonly");
        this.remove();
        this.targetDom = null;
        this.options = null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axRange]').forEach(element => {
        new axRange(element);
    });
})(); */
/*!
 * 插件：分页；使用方法：new axPagination('#id',{参数})
 * 从现有的list中自动创建分页
 * 从已知的数组创建列表并分页
 * 可追加列表item数量并重新渲染分页
 * 分页节点能自动在列表下方创建，也可以在指定的dom创建
 */
class axPagination {
    constructor(targetDom, options) {
        this.options = axExtend({
            insName: '',
            listDom: '',
            count: 10, 
            current: 1, 
            total: 0,
            firstText: '首页', 
            prevText: '上一页', 
            nextText: '下一页', 
            lastText: '尾页', 
            allPages: false,
            data: [], 
            clickDelay: 200,
            template: '', 
            type: 'regular', 
            loadingMode: 'replace',
            className: '',
            lastDel: '', 
            async: '',
            ajaxType: 'post',
            delay: 0,
            dataExtend: '',
            onBeforeRendered: function (listArr) {
            },
            onRendered: function (current, pagesNum,offset) {
            },
            onUpdated: function (current, pagesNum,offset) {
            },
            onTurned: function (current, pagesNum,offset) {
            }
        }, options, targetDom, this.constructor.name);
        this.targetExist = targetDom ? true : false;
        this.targetDom = targetDom ? axIdToDom(targetDom) : axAddElem('div', { class: this.options.className ? 'ax-pagination ' + this.options.className : 'ax-pagination' });
        this.listDom = '';
        this.options.total ? this.options.data = { length: this.options.total } : null;
        this.handlers = {};
        this.preData = [];
        this.asyncData = []
        this.selectData = [];
        this.itemsNum = 0;
        this.pagesNum = 0;
        this.current = this.options.current;
        this.loadingDom = axAddElem('div', { class: 'ax-pageTurning' })
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) === '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.pagesDom = axAddElem('div', { class: 'ax-core' });
        this.pageFirst = axAddElem('a', { href: '###', class: 'ax-first' }, this.options.firstText);
        this.pageLast = axAddElem('a', { href: '###', class: 'ax-last' }, this.options.lastText);
        this.pagePrev = axAddElem('a', { href: '###', class: 'ax-prev' }, this.options.prevText);
        this.pageNext = axAddElem('a', { href: '###', class: 'ax-next' }, this.options.nextText);
        this.pageTotal = axAddElem('span', { class: 'ax-total' });
        this.pageGo = axAddElem('span', { class: 'ax-gopage' });
        this.group = axAddElem('div', { class: 'ax-group' });
        this.renderedIndex = 0;
        this.init(this.options.data);
        return this;
    }
    async init(data) {
        axInstance.push(this, this.options.insName, 'pagination');
        this.dataType = this.getDataType(data);
        if (this.dataType === 'pageDom') {
            this.listDom = axIdToDom(this.options.data);
        } else if (this.options.listDom) {
            this.listDom = axIdToDom(this.options.listDom);
        }
        if (axIsEmpty(data)) {
            this.listDom ? this.listDom.innerHTML = '' : null;
            this.targetDom.innerHTML = '';
            this.current = 1;
            this.pagesNum = 1;
            this.itemsNum = 0;
            return false;
        }
        let initCurrent;
        if (this.dataType === 'json' || this.dataType === 'sql') {
            if (!this.template && this.listDom.nodeName != 'TBODY') {
                console.error('The template is required!');
                return false;
            }
            if (this.options.async === 'json') {
                await this.getJsonData({ url: data });
            } else if (this.options.async === 'sql') {
                await this.getSqlData({ current: this.current });
            }
            initCurrent = 1;
        } else {
            if (this.dataType === 'sortList') {
                data.forEach(i => {
                    this.preData.push(i.dom);
                });
            } else if (this.dataType === 'pureNode') {
                this.preData = [...data];
            } else if (this.dataType === 'tplArray') {
                if (!this.template) {
                    console.error('The template is required!');
                    return false;
                }
                this.preData = this.tplToDoms(data);
            } else if (this.dataType === 'manual') {
                this.preData = { ...data };
            } else {
                this.preData = [...this.listDom.childNodes].filter(k => k.nodeType == 1);
            }
            this.getCurrent(this.preData.length);
            initCurrent = this.current;
        }
        this.listDom && this.dataType !== 'manual' ? this.renderList(initCurrent) : null;
        this.renderFinish();
    }
    getDataType(data) {
        let type = '',
            dataType = axType(data);
        if (dataType === 'Object' && data.hasOwnProperty('length')) {
            type = 'manual';
        } else {
            if (dataType === 'Array') {
                if (data.length > 0 && data[0].hasOwnProperty('dom')) {
                    type = 'sortList';
                } else if (data.length > 0 && axType(data[0]).includes('Element')) {
                    type = 'pureNode';
                } else {
                    type = 'tplArray';
                }
            } else if (dataType === 'String') {
                if (this.options.async === 'json') {
                    type = 'json';
                } else if (this.options.async === 'sql') {
                    type = 'sql';
                } else {
                    type = 'pageDom';
                }
            }
        }
        return type;
    }
    tplToDoms(data, tpl = this.template) {
        let domArr = [];
        data.forEach(i => {
            let item = axStrToDom(axTplEngine(tpl, i));
            domArr.push(item);
        });
        return domArr;
    }
    renderTotal() {
        this.pageTotal.innerHTML = '共有' + this.pagesNum + '页, ' + this.itemsNum + '条数据';
    }
    renderFinish() {
        this.targetDom.removeAttribute('paging');
        this.renderPagesTotal(this.current, () => {
            this.renderTotal();
        });
        this.getPagination();
        if (this.listDom && !this.targetExist) {
            if (this.listDom.nodeName == 'TBODY') {
                this.listDom.parentElement.insertAdjacentElement('afterend', this.targetDom)
            } else {
                this.listDom.insertAdjacentElement('afterend', this.targetDom)
            }
        }
        this.pageFirst.onclick = axDebounce((e) => {
            if (this.current <= 1) {
                axPreventDefault(e);
            } else {
                this.current = 1;
                this.currentToRenderList(this.current);
            }
        }, this.options.clickDelay);
        this.pageLast.onclick = axDebounce((e) => {
            if (this.current >= this.pagesNum) {
                axPreventDefault(e);
            } else {
                this.current = this.pagesNum;
                this.currentToRenderList(this.current);
            }
        }, this.options.clickDelay);
        this.pagePrev.onclick = axDebounce((e) => {
            if (this.current <= 1) {
                axPreventDefault(e);
            } else {
                this.current = this.current - 1;
                this.currentToRenderList(this.current);
            }
        }, this.options.clickDelay);
        this.pageNext.onclick = axDebounce((e) => {
            if (this.current >= this.pagesNum) {
                axPreventDefault(e);
            } else {
                this.current = this.current + 1;
                this.currentToRenderList(this.current);
            }
        }, this.options.clickDelay);
        this.renderedIndex++;
        this.options.onTurned && this.options.onTurned.call(this, this.current, this.pagesNum,this.getOffset());
        this.handlers.hasOwnProperty('turned') ? this.emit('turned', this.current, this.pagesNum,this.getOffset()) : null;
    }
    getOffset(current = this.current, total = this.itemsNum, count = this.options.count) {
        let rest = count * current - total;
        return total && rest > 0 ? rest : count;
    }
    currentFix(current, pagesNum = this.pagesNum) {
        if (!current) {
            return this.current;
        }
        if (current <= 1) {
            this.current = 1;
        } else if (current >= pagesNum) {
            this.current = pagesNum;
        } else {
            this.current = current;
        }
        return this.current;
    }
    getCurrent(dataLen, current, pagesNum, itemsNum) {
        this.itemsNum = itemsNum ? itemsNum : dataLen;
        if (pagesNum) {
            this.pagesNum = pagesNum;
        } else {
            let divisor = this.itemsNum / this.options.count;
            this.pagesNum = divisor % 1 === 0 ? divisor : Math.floor(divisor) + 1;
        }
        this.currentFix(current ? current : this.current, this.pagesNum);
    }
    renderList(current, source,callback) {
        let fragment = document.createDocumentFragment(),
            data = source || this.preData,
            realData = this.options.total ? data.slice(0, this.options.total) : data;
        this.selectData = realData.slice(this.options.count * (current - 1), this.options.count * current);
        this.selectData.forEach((item, index) => {
            if (index + 1 == this.selectData.length && this.options.lastDel && item.querySelector(this.options.lastDel)) {
                item.removeChild(item.querySelector(this.options.lastDel))
            }
            fragment.appendChild(item);
        });
        this.options.onBeforeRendered && this.options.onBeforeRendered.call(this, this.selectData, this.asyncData);
        'beforeRendered' in this.handlers ? this.emit('beforeRendered', this.selectData, this.asyncData) : null;
        this.listDom.innerHTML = '';
        if (this.selectData.length === 0) {
            new axMessage({
                content: `有效数据只有${realData.length}条，本页没有数据，渲染数据失败！`,
                iconShow: true,
                result: 'error'
            }).show();
        } else {
            this.listDom.appendChild(fragment);
            this.options.onRendered && this.options.onRendered.call(this, this.current, this.pagesNum,this.getOffset());
            this.handlers.hasOwnProperty('rendered') ? this.emit('rendered', this.current, this.pagesNum,this.getOffset()) : null;
            callback && callback.call(this,this.current, this.pagesNum,this.getOffset());
        }
    }
    renderPagesTotal(current, callback) {
        current = this.currentFix(current);
        this.pagesDom.innerHTML = ''
        if (this.options.allPages) {
            for (let i = 1; i <= this.pagesNum; i++) {
                let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                this.pagesDom.appendChild(item);
            }
        } else {
            if (this.pagesNum < 11) {
                for (let i = 1; i <= this.pagesNum; i++) {
                    let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                    this.pagesDom.appendChild(item);
                }
            } else {
                if (current < 6) {
                    for (let i = 1; i <= 8; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 1; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                } else if (this.pagesNum - current < 5) {
                    for (let i = 1; i <= 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 6; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                } else {
                    for (let i = 1; i <= 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = current - 2; i <= current + 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 1; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                }
            }
        }
        let pages = this.pagesDom.querySelectorAll('[data-page]');
        [...pages].forEach(item => {
            item.onclick = axDebounce(() => {
                this.current = ~~item.dataset.page; 
                this.currentToRenderList(this.current);
            }, this.options.clickDelay);
        });
        this.setClass(current);
        callback && callback.call(this, current);
        return this.pagesDom;
    }
    setClass(current) {
        let pages = this.pagesDom.querySelectorAll('[data-page]'),
            page = [...pages].filter(item => ~~item.dataset.page == current)[0];
        page.classList.add('ax-active');
        if (~~page.dataset.page == 1) {
            this.pageFirst.classList.add('ax-disabled');
            this.pagePrev.classList.add('ax-disabled');
            if (this.pagesNum == 1) {
                this.pageLast.classList.add('ax-disabled');
                this.pageNext.classList.add('ax-disabled');
            } else {
                this.pageLast.classList.remove('ax-disabled');
                this.pageNext.classList.remove('ax-disabled');
            }
        } else if (~~page.dataset.page == this.pagesNum) {
            this.pageLast.classList.add('ax-disabled');
            this.pageNext.classList.add('ax-disabled');
            this.pageFirst.classList.remove('ax-disabled');
            this.pagePrev.classList.remove('ax-disabled');
        } else {
            this.pageFirst.classList.remove('ax-disabled');
            this.pagePrev.classList.remove('ax-disabled');
            this.pageLast.classList.remove('ax-disabled');
            this.pageNext.classList.remove('ax-disabled');
        }
    }
    getPagination() {
        let fragment = document.createDocumentFragment();
        this.pageGo.innerHTML = '跳到</span><input type="text"><button type="button" class="ax-btn">确定</button>';
        let goInput = this.pageGo.querySelector('input'),
            goBtn = this.pageGo.querySelector('button');
        goBtn.onclick = axDebounce(() => {
            let val = ~~goInput.value;
            if (val <= 1) {
                console.warn('The value is out of range,it has been fixed!');
                goInput.value = 1;
                this.current = 1;
            } else if (val >= this.pagesNum) {
                console.warn('The value is out of range,it has been fixed!');
                goInput.value = this.pagesNum;
                this.current = this.pagesNum;
            } else {
                this.current = val;
            }
            this.currentToRenderList(this.current);
        }, this.options.clickDelay);
        goInput.onkeyup = function (e) {
            if (e.code === 'Enter') {
                goBtn.click();
            }
        }
        if (this.options.type === 'regular') {
            fragment.appendChild(this.pageFirst);
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pagesDom);
            fragment.appendChild(this.pageNext);
            fragment.appendChild(this.pageLast);
        } else if (this.options.type === 'group') {
            this.group.appendChild(this.pageFirst);
            this.group.appendChild(this.pagePrev);
            this.group.appendChild(this.pagesDom);
            this.group.appendChild(this.pageNext);
            this.group.appendChild(this.pageLast);
            fragment.appendChild(this.group);
        } else if (this.options.type === 'simple') {
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pageNext);
        } else if (this.options.type === 'full') {
            fragment.appendChild(this.pageTotal);
            fragment.appendChild(this.pageFirst);
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pagesDom);
            fragment.appendChild(this.pageNext);
            fragment.appendChild(this.pageLast);
            fragment.appendChild(this.pageGo);
        } else if (this.options.type === 'pagesRight') {
            let left = axAddElem('div'),
                right = axAddElem('div', { class: 'ax-col ax-align-right' });
            this.targetDom.classList.add('ax-row');
            left.appendChild(this.pageTotal);
            right.appendChild(this.pageFirst);
            right.appendChild(this.pagePrev);
            right.appendChild(this.pagesDom);
            right.appendChild(this.pageNext);
            right.appendChild(this.pageLast);
            right.appendChild(this.pageGo);
            fragment.appendChild(left);
            fragment.appendChild(right);
        } else if (this.options.type === 'pagesLeft') {
            let right = axAddElem('div'),
                left = axAddElem('div', { class: 'ax-col ax-align-left' });
            this.targetDom.classList.add('ax-row');
            right.appendChild(this.pageTotal);
            left.appendChild(this.pageFirst);
            left.appendChild(this.pagePrev);
            left.appendChild(this.pagesDom);
            left.appendChild(this.pageNext);
            left.appendChild(this.pageLast);
            left.appendChild(this.pageGo);
            fragment.appendChild(left);
            fragment.appendChild(right);
        } else {
            fragment.appendChild(this.pagesDom);
        }
        this.targetDom.appendChild(fragment);
    }
    getJsonData(data = {}) {
        data.template = data.template || this.template;
        data.url = data.url || this.options.data;
        return axAjax({
            url: data.url,
            type: this.options.ajaxType,
            before: (response) => {
                this.listDom ? this.listDom.innerHTML = '<div class="ax-pageTurning">' + response.content + '</div>' : null;
            },
            success: (response) => {
                let doms = [], dataLen;
                response.content.forEach((i, index) => {
                    let item, obj = { index: index };
                    if (!data.template && this.listDom.nodeName == 'TBODY') {
                        item = axAddElem('tr');
                        for (let k in i) {
                            let td = axAddElem('td', { name: k }, i[k])
                            item.appendChild(td);
                            obj.children = [];
                            obj.children.push({ dom: td, name: k, label: i[k].toString() });
                        }
                    } else {
                        item = axStrToDom(axTplEngine(data.template, i));
                    }
                    obj.dom = item;
                    this.asyncData.push(obj);
                    doms.push(item);
                });
                this.dataType !== 'manual' ? this.preData = [...doms] : null;
                dataLen = this.preData.length;
                this.getCurrent(dataLen);
                data.callback && data.callback.call(this, doms, this.asyncData, response.content);
            }
        });
    }
    getSqlData(data = {}) {
        data.current = data.current || 1;
        data.count = data.count || this.options.count;
        data.total = data.total || this.options.total;
        data.template = data.template || this.template;
        data.url = data.url || this.options.data;
        return axAjax({
            data: Object.assign({ count: data.count, current: data.current, offset:this.getOffset(data.current,data.total,data.count) }, this.options.dataExtend),
            url: data.url,
            type: this.options.ajaxType,
            before: (response) => {
                if (this.listDom) {
                    this.loadingDom.style = '';
                    this.loadingDom.innerHTML = response.content;
                    if (this.options.loadingMode === 'overlay') {
                        this.loadingDom.classList.add('ax-overlay');
                    } else {
                        this.listDom.innerHTML = '';
                        this.listDom.appendChild(this.loadingDom)
                    }
                    this.listDom.insertAdjacentElement('afterbegin', this.loadingDom);
                    axFadeIn(this.loadingDom, 'flex');
                }
            },
            success: (response) => {
                if (typeof response.content != 'object') {
                    console.error('The type of content must be object!');
                    return false;
                }
                if (axIsEmpty(response.content.data)) {
                    this.listDom ? this.listDom.innerHTML = '' : null;
                    new axMessage({
                        content: `没有从数据库中获得数据，已停止渲染列表！`,
                        iconShow: true,
                        result: 'error'
                    }).show();
                    return false;
                }
                this.dataType !== 'manual' ? this.preData = [] : null;
                this.asyncData = [];
                let doms = [], dataLen;
                response.content.data.forEach((i, index) => {
                    let item, obj = { index: index };
                    if (!data.template && this.listDom.nodeName == 'TBODY') {
                        item = axAddElem('tr');
                        obj.children = [];
                        for (let k in i) {
                            let td = axAddElem('td', { name: k }, i[k].toString());
                            item.appendChild(td);
                            obj.children.push({ dom: td, name: k, label: i[k].toString() });
                        }
                    } else {
                        item = axStrToDom(axTplEngine(data.template, i));
                    }
                    obj.dom = item;
                    this.asyncData.push(obj);
                    doms.push(item);
                });
                this.dataType !== 'manual' ? this.preData = [...doms] : null;
                dataLen = this.preData.length;
                this.getCurrent(dataLen, ~~response.content.current, ~~response.content.pagesNum, ~~response.content.itemsNum);
                data.callback && data.callback.call(this, doms, this.asyncData, response.content);
            }
        });
    }
    async currentToRenderList(current, callback) {
        if (this.listDom && this.dataType !== 'manual') {
            if (this.options.async === 'sql') {
                await this.getSqlData({
                    current,
                    callback: () => {
                        if (this.options.delay) {
                            setTimeout(() => {
                                this.renderList(1)
                            }, this.options.delay)
                        } else {
                            this.renderList(1)
                        }
                    }
                });
            } else {
                this.renderList(current);
            }
        }
        this.renderPagesTotal(current, callback && callback.call(this, current));
        this.options.onTurned && this.options.onTurned.call(this, this.current, this.pagesNum,this.getOffset());
        this.handlers.hasOwnProperty('turned') ? this.emit('turned', this.current, this.pagesNum,this.getOffset()) : null;
    }
    first(callback) {
        this.current = 1;
        this.currentToRenderList(this.current);
        callback && callback.call(this, this.current, this.pagesNum);
        return this;
    }
    prev(callback) {
        if (this.current <= 1) {
            return false;
        } else {
            this.current = this.current - 1;
            this.currentToRenderList(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    next(callback) {
        if (this.current >= this.pagesNum) {
            return false;
        } else {
            this.current = this.current + 1;
            this.currentToRenderList(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    last(callback) {
        this.current = this.pagesNum;
        this.currentToRenderList(this.current);
        callback && callback.call(this, this.current, this.pagesNum);
        return this;
    }
    go(page, callback) {
        if (this.current <= 1 || this.current >= this.pagesNum) {
            console.error('The value is out of range!');
            return false;
        } else {
            this.current = ~~page;
            this.currentToRenderList(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    info(callback) {
        let info = { current: this.current, pagesNum: this.pagesNum, count: this.options.count, itemsNum: this.itemsNum, selectData: this.selectData };
        callback && callback.call(this, info);
        return info;
    }
    updatePages(obj, type, callback) {
        if (!obj) {
            return false;
        }
        type = type || 'remove';
        let item;
        if (typeof obj === 'number') {
            item = this.preData[obj];
        } else {
            item = obj;
        }
        if (!item) {
            return false;
        }
        if (type === 'remove') {
            this.preData = this.preData.filter(i => i != item);
            this.getCurrent(this.preData.length, this.current, '');
        } else if (type === 'addBefore') {
        } else if (type === 'addAfter') {
        } else {
        }
        this.currentToRenderList(this.current, () => {
            this.renderTotal();
        });
        callback && callback.call(this);
    }
    async update(setting, mode, callback) {
        mode = mode || 'overwrite';
        this.options = axExtend(this.options, setting);
        this.current = this.options.current;
        this.targetDom.setAttribute('paging', '');
        this.targetDom.innerHTML = '';
        mode === 'overwrite' ? this.preData = [] : null;
        await this.init(this.options.data);
        this.options.onUpdated && this.options.onUpdated.call(this, this.current, this.pagesNum,this.getOffset());
        'updated' in this.handlers ? this.emit('updated', this.current, this.pagesNum,this.getOffset()) : null;
        callback && callback.call(this);
        return this;
    }
    async updateData(data, mode, callback) {
        mode = mode || 'overwrite';
        this.targetDom.setAttribute('paging', '');
        this.targetDom.innerHTML = '';
        if (mode === 'overwrite') {
            this.preData = [];
            this.options.dataExtend = '';
        }
        if (typeof data === 'object' && data.url && data.hasOwnProperty('sql')) {
            this.options.data = data.url;
            this.options.dataExtend = data.sql;
        } else {
            this.options.data = data;
        }
        await this.init(this.options.data);
        this.options.onUpdated && this.options.onUpdated.call(this, this.current, this.pagesNum,this.getOffset());
        'updated' in this.handlers ? this.emit('updated', this.current, this.pagesNum,this.getOffset()) : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axPagination]').forEach(element => {
        new axPagination(element);
    });
})(); */
/*!
* 插件：可排序列表；使用方法：new axList('#id',{参数})；#id是可选参数，可以从该dom获取参数值
*/
class axList {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.rawOptions = {
            insName: '',
            names: '',
            inputDelay: 200,
            clickDelay: 200,
            paginationDom: null,
            maxCount: 10000,
            order: 'asc',
            operator: 'or',
            paginationShow: true,
            onUpdated: '',
            onInit: '',
            pagination: {
                current: 1, 
                count: 10, 
                data: [], 
                template: null, 
                async: '',
                ajaxType: 'post',
                loadingMode: 'overlay',
            }
        }
        this.options = axExtend(axClone(this.rawOptions), options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.rawData = [];
        this.preData = [];
        this.paginationDom = this.options.paginationDom ? axIdToDom(this.options.paginationDom) : this.targetDom.querySelector('.ax-pagination') || '';
        if (!this.options.pagination.template) {
            this.template = '';
        } else {
            if (this.options.pagination.template.trim().substr(0, 1) === '#') {
                this.template = document.querySelector(this.options.pagination.template).innerHTML
            } else {
                this.template = this.options.pagination.template;
            }
        }
        this.names = this.options.names.replace(/\s+/g, '').split(',');
        this.listDom = this.targetDom.querySelector('[list]');
        this.searchs = [...this.targetDom.querySelectorAll('[search]')];
        this.keywords = [...this.targetDom.querySelectorAll('[keyword]')];
        this.searchVal = '';
        this.sorts = [...this.targetDom.querySelectorAll('[sort]')];
        this.resets = [...this.targetDom.querySelectorAll('[reset]')];
        this.filters = [...this.targetDom.querySelectorAll('[filter]')];
        this.extends = [...this.targetDom.querySelectorAll('[extend]')];
        this.paginationOpt = {};
        this.pagination = null;
        this.init();
        return this;
    }
    async init() {
         axInstance.push(this, this.options.insName, 'list');
        this.setPaginationOpt();
        if (this.listDom.children.length > 0) {
            let data = [...this.listDom.childNodes].filter(item => item.nodeType == 1);
            this.getDomArr(data);
            this.paginationOpt.data = this.preData;
        } else if (axType(this.options.pagination.data) === 'String' && !!this.options.pagination.template) {
            if (this.options.pagination.async === 'json') {
                await axAjax({
                    url: this.options.pagination.data,
                    type: this.options.pagination.ajaxType,
                    success: (response) => {
                        let data = [];
                        response.content.forEach(i => {
                            let item = axStrToDom(axTplEngine(this.template, i));
                            data.push(item);
                        });
                        this.getDomArr(data);
                        this.paginationOpt.data = this.preData;
                    }
                });
            } else if (this.options.pagination.async === 'sql') {
                if (!['relative', 'absolute', 'fixed'].includes(axStyle(this.listDom).position)) {
                    this.listDom.style.position = 'relative';
                }
            }
        } else {
            this.preData = this.options.pagination.data;
            this.rawData = [...this.preData];
            this.paginationOpt.data = this.options.pagination.data;
        }
        this.renderFinish();
        this.options.onInit && this.options.onInit.call(this, this.pagination.current, this.pagination.pagesNum);
    }
    getDomArr(listData) {
        if (this.options.names) {
            listData.forEach(item => {
                let obj = { dom: item };
                this.names.forEach(i => {
                    item.querySelector('[' + i + ']') ? obj[i] = item.querySelector('[' + i + ']').innerText.trim() : null;
                })
                this.preData.push(obj);
            });
            this.rawData = [...this.preData];
            return true;
        } else {
            this.preData = listData;
            this.rawData = [...listData];
            return false;
        }
    }
    renderFinish() {
        this.pagination = new axPagination(this.paginationDom, this.paginationOpt);
        if (!this.options.paginationShow) {
            this.pagination.targetDom.remove();
            if (this.pagination.itemsNum > this.paginationOpt.count) {
                console.error('The maximum length cannot exceed ' + this.paginationOpt.count + '!');
                return false;
            }
        }
        let isSql = this.paginationOpt.async === 'sql' ? true : false;
        this.loadExtend(isSql);
        this.loadSort(isSql);
        this.loadKeyword(isSql);
        this.loadSearch(isSql);
        this.loadFilter(isSql);
        this.loadReset(isSql);
    }
    setPaginationOpt() {
        this.paginationOpt = this.options.pagination;
        this.paginationOpt.listDom = this.listDom;
        this.paginationOpt.count = !this.options.paginationShow ? this.options.maxCount : this.paginationOpt.count;
        return this.paginationOpt;
    }
    loadExtend(isSql) {
        if (this.extends.length !== 0) {
            this.extends.forEach(item => {
                let attr = item.getAttribute('extend');
                item.onclick = axDebounce(() => {
                    this.extend(attr, isSql);
                }, this.options.clickDelay);
            });
        }
    }
    extend(str, isSql) {
        if (!isSql) {
            this.strSearch(str);
        } else {
            this.updateSql({ dataExtend: { extend: str } });
            this.pagination.on('rendered', () => {
                if (axIsEmpty(this.pagination.preData)) {
                    this.listDom.innerHTML = '';
                    this.pagination.targetDom.innerHTML = '';
                }
            });
        }
    }
    loadKeyword(isSql) {
        if (this.keywords.length !== 0) {
            this.keywords.forEach(item => {
                let source = [...this.preData],
                    attr = item.getAttribute('keyword').trim(),
                    operator = item.getAttribute('operator') ? item.getAttribute('operator').trim() : this.options.operator,
                    value = '',
                    arr = attr ? attr.split(',') : [],
                    names = arr.length !== 0 ? arr : this.names;
                if (item.hasAttribute('auto')) {
                    item.oninput = axDebounce(() => {
                        let inputValue = item.value;
                        if (arr.length !== 0) {
                            let obj = {};
                            arr.forEach(i => {
                                obj[i] = inputValue;
                            });
                            value = obj;
                        } else {
                            value = inputValue;
                        }
                        if (!isSql) {
                            this.keySearch(value, source, operator);
                        } else {
                            this.sqlSearch(names, inputValue, operator);
                        }
                    }, this.options.inputDelay);
                }
            });
        }
    }
    loadFilter(isSql) {
        if (this.filters.length !== 0) {
            this.filters.forEach(item => {
                let data,
                    source = [...this.preData],
                    operator = item.getAttribute('operator') ? item.getAttribute('operator').trim() : this.options.operator;
                if (!isSql) {
                    data = axAttrToJson(item, 'filter');
                } else {
                    data = item.getAttribute('filter');
                }
                item.onclick = axDebounce(() => {
                    this.filter(data, source, operator, isSql);
                }, this.options.clickDelay);
            });
        }
    }
    filter(data, source, operator, isSql) {
        operator = operator ? operator : this.options.operator;
        source = source ? source : [...this.preData];
        if (!isSql) {
            this.keySearch(data, source, operator);
        } else {
            this.updateSql({ dataExtend: { filter: data } });
        }
    }
    loadSearch(isSql) {
        if (this.searchs.length !== 0) {
            this.searchs.forEach(item => {
                if (this.keywords.length == 0) {
                    return false;
                }
                let fieldName = item.getAttribute('field'),
                    fieldDom = this.keywords.filter(i => i.name == fieldName)[0],
                    searchNames = fieldDom.getAttribute('keyword'),
                    operator = fieldDom.getAttribute('operator') ? fieldDom.getAttribute('operator').trim() : this.options.operator,
                    source = [...this.preData];
                searchNames = searchNames ? searchNames.replace(/\s+/g, '').split(',') : this.names;
                item.onclick = axDebounce(() => {
                    this.search(searchNames, fieldDom.value, source, operator, isSql);
                }, this.options.clickDelay);
                fieldDom.onkeyup = (e) => {
                    if (e.code === 'Enter') {
                        item.click();
                    }
                }
            });
        }
    }
    search(names, value, source, operator, isSql) {
        operator = operator ? operator : this.options.operator;
        if (!isSql) {
            let obj = {};
            source = source ? source : [...this.preData];
            names.forEach(i => {
                obj[i] = value;
            });
            this.keySearch(obj, source, operator);
        } else {
            this.sqlSearch(names, value, operator);
        }
    }
    loadSort(isSql) {
        if (this.sorts.length !== 0) {
            for (let item of this.sorts) {
                let attr = item.getAttribute('sort').trim();
                if (!isSql) {
                    if (this.names.every(i => i !== attr)) {
                        continue;
                    }
                }
                item.onclick = axDebounce(() => {
                    if (!isSql) {
                        if (item.getAttribute('order') === 'desc') {
                            item.setAttribute('order', 'asc');
                            this.sort(attr, 'asc', false);
                        } else if (item.getAttribute('order') === 'asc') {
                            item.setAttribute('order', 'desc');
                            this.sort(attr, 'desc', false);
                        } else {
                            item.setAttribute('order', this.options.order);
                            this.sort(attr, this.options.order, false);
                        }
                    } else {
                        this.sort(attr, '', true);
                        if (!attr.includes(',')) {
                            if (attr.includes('desc')) {
                                item.setAttribute('order', 'desc');
                                attr = attr.replace('desc', 'asc');
                            } else if (attr.includes('asc')) {
                                item.setAttribute('order', 'asc');
                                attr = attr.replace('asc', 'desc');
                            }
                        }
                    }
                    this.sorts.filter(i => i != item).forEach(k => {
                        k.setAttribute('order', '');
                    });
                }, this.options.clickDelay);
            }
        }
    }
    sort(data, order, isSql) {
        if (!isSql) {
            this.preSort(data, order);
        } else {
            this.updateSql({ dataExtend: { sort: data } });
        }
    }
    preSort(name, order, callback) {
        if (order === 'desc') {
            this.preData.sort(function (a, b) {
                if (isNaN(a[name] - b[name])) {
                    return b[name].localeCompare(a[name], 'zh-CN-u-kf-lower');
                } else {
                    return b[name] - a[name];
                }
            })
        } else if (order === 'asc') {
            this.preData.sort(function (a, b) {
                if (isNaN(a[name] - b[name])) {
                    return a[name].localeCompare(b[name], 'zh-CN-u-kf-lower');
                } else {
                    return a[name] - b[name];
                }
            })
        } else {
            return false;
        }
        this.pagination.updateData(this.preData);
        this.handlers.hasOwnProperty('sorted') ? this.emit('sorted', this.pagination.current, this.pagination.pagesNum) : null;
        this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
        callback && callback.call(this, this.preData, this.pagination.current);
        return this;
    }
    loadReset(isSql) {
        if (this.resets.length !== 0) {
            this.resets.forEach(item => {
                item.onclick = axDebounce(() => {
                    this.reset(isSql);
                }, this.options.clickDelay);
            });
        }
    }
    reset(isSql) {
        if (!isSql) {
            this.preData = [...this.rawData];
            let obj = axClone(this.rawOptions.pagination);
            obj.data = this.preData;
            this.updatePages(obj);
        } else {
            this.updateSql({ dataExtend: '' });
        }
        this.sorts.forEach(i => {
            i.setAttribute('order', '');
        });
        this.keywords.forEach(i => {
            i.value = '';
        });
        'reset' in this.handlers ? this.emit('reset', '') : null;
        this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
    }
    keySearch(value, sourceArr, operator = this.options.operator, callback) {
        let filterArr = sourceArr.filter(i => {
            let values = [];
            if (typeof value === "object") {
                let flag = [];
                for (let k in value) {
                    flag.push(String(i[k]).includes(value[k]));
                }
                if (operator === 'or') {
                    return flag.some(k => k == true);
                } else if (operator === 'and') {
                    return flag.every(k => k == true);
                }
            } else {
                for (let k of this.names) {
                    values.push(i[k]);
                }
                return values.toString().includes(value);
            }
        });
        this.preData = filterArr;
        if (axIsEmpty(this.preData)) {
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
            this.preData = [...this.rawData];
            this.listDom.innerHTML = '';
            this.pagination.targetDom.innerHTML = '';
            return false;
        } else {
            this.pagination.updateData(this.preData);
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
        }
    }
    strSearch(str, callback) {
        this.preData = axStrToFilter(str, [...this.preData]);
        if (axIsEmpty(this.preData)) {
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
            this.preData = [...this.rawData];
            this.listDom.innerHTML = '';
            this.pagination.targetDom.innerHTML = '';
            return false;
        } else {
            this.pagination.updateData(this.preData);
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
        }
    }
    sqlSearch(names, value, operator) {
        let dataString = '',
            last;
        operator = operator || this.options.operator;
        if (names.length == 0) {
            console.error('The length of names array cannot be greater than 0!')
            return false;
        }
        if (value) {
            names.forEach((i, index) => {
                last = names.length - 1 != index ? operator + ' ' : '';
                dataString += i + ' like "%' + value + '%" ' + last;
            });
        }
        this.pagination.options.dataExtend = '';
        this.updatePages({ dataExtend: { search: dataString } });
        this.pagination.on('rendered', () => {
            if (axIsEmpty(this.pagination.preData)) {
                this.listDom.innerHTML = '';
                this.pagination.targetDom.innerHTML = '';
            }
        })
    }
    updateSql(extend, callback) {
        this.pagination.options.dataExtend = '';
        this.pagination.update(extend, '', () => {
            this.handlers.hasOwnProperty('updated') ? this.emit('updated', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
        });
        callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
        return this;
    }
    updatePages(setting, callback) {
        let opt = axExtend(this.options.pagination, setting);
        this.pagination.update(opt, '', () => {
            this.handlers.hasOwnProperty('updated') ? this.emit('updated', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
        });
        callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axList]').forEach(element => {
        new axList(element);
    });
})(); */
/*!a
 * 插件：灯箱画廊；使用方法：axLightbox('#id',{参数})
 */
class axLightbox {
    constructor(options, elem) {
        this.options = axExtend({
            insName: '',
            src: '',
            gallery: true,
            download: false,
            autoplay: false,
            thumb: {
                show: false,
                placement: 'bottom',
                row: 1,
            },
            zoom: true,
            share: false,
            btnClass: 'ax-lightbox-open',
            index: 0,
            zIndex: 0,
            onInit: '',
            onShow: '',
            onShown: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onDestroy: '',
        }, options, elem, this.constructor.name);
        this.handlers = {};
        this.data = [];
        this.closeArea = [];
        this.zoomIn = false;
        this.button = elem ? axIdToDom(elem) : null;
        this.shown = false;
        axInstance.push(this, this.options.insName, 'lightbox');
    }
    init() {
        let _this = this;
        this.destroyed = false;
        this.data = axCreateData(this.options.src, ['src', 'cover', 'caption', 'type'], ['media', 'cover', 'caption', 'type'], 'figure', ['', '', '', 'image'], function (data) {
            data.forEach(item => {
                if (!item.cover && item.type == 'image') {
                    item.cover = item.media;
                }
                item.cover = item.cover ? item.cover : '';
            });
        });
        this.setAttribute();
        this.createBox();
        this.createSlide();
        if (this.data.length > 1) {
            this.prev = axStrToDom(`<span class="ax-prev ax-light"></span>`);
            this.next = axStrToDom(`<span class="ax-next ax-light"></span>`);
            this.swiper.appendChild(this.prev);
            this.swiper.appendChild(this.next);
        }
        let swiperOpt = {
            zoom: this.options.zoom,
            lazy: true,
            keyboard: true,
            mousewheel: true,
            initialSlide: this.options.index || 0,
            pagination: {
                el: this.options.gallery ? this.targetDom.querySelector('.ax-pages') : null,
                type: "fraction",
            },
            thumbs: {
                swiper: '',
            },
            on: {
                touchStart:  (swiper, event)=> {
                    swiper.el.classList.add('ax-grabbing');
                },
                touchEnd: (swiper, event)=> {
                    swiper.el.classList.remove('ax-grabbing');
                },
                zoomChange:  (swiper, scale)=> {
                    if (scale > 1) {
                        this.zoomIn = true;
                    } else {
                        setTimeout( ()=> {
                            this.zoomIn = false;
                        }, 100)
                    }
                },
            },
        }
        let thumbOpt = {
            lazy: true,
            spaceBetween: 4,
            slidesPerView: "auto",
            mousewheel: true,
            grid: {
                rows: this.options.thumb.row,
            },
            watchSlidesProgress: true,
        }
        if (this.options.gallery && this.options.thumb) {
            this.stage.insertAdjacentElement('afterend', this.createThumb());
            this.insThumb = new axSwiper(this.thumb.querySelector('.ax-swiper'), thumbOpt);
            swiperOpt.thumbs.swiper = this.insThumb;
            this.btnList.onclick =  ()=> {
                this.targetDom.classList.toggle('ax-thumb-hide');
            }
        }
        if (!this.options.thumb.show) {
            this.targetDom.classList.add('ax-thumb-hide');
        }
        if (this.options.autoplay) {
            swiperOpt.autoplay = {
                delay: 5000,
                stopOnLastSlide: false,
                disableOnInteraction: true,
            }
        }
        this.insSwiper = new axSwiper(this.swiper, swiperOpt);
        document.body.appendChild(this.targetDom);
        if (this.data.length > 1 && this.options.thumb.row && this.options.thumb.row > 1) {
            this.thumb.querySelector('.ax-swiper').style.height = axHeight(this.thumb.querySelector('.ax-slide'), 'outer') * this.options.thumb.row + thumbOpt.spaceBetween * (this.options.thumb.row - 1) + 'px';
        }
        if (!this.options.gallery) {
            this.insSwiper.disable();
        }
        axPreventScroll(this.targetDom);
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', ()=> {
                this.hide();
            }, false);
        });
        if (this.options.zoom) {
            this.btnZoom.onclick = function () {
                if (this.classList.contains('ax-icon-zoomin')) {
                    _this.insSwiper.zoom.in();
                } else {
                    _this.insSwiper.zoom.out();
                }
            }
        }
        /*     if (this.options.list && this.thumb) {
                this.btnList.onclick = function () {
                    _this.targetDom.classList.toggle('ax-thumb-hide');
                }
            } */
        if (this.options.download) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnDownload.href = '###';
                this.btnDownload.classList.add('ax-disabled');
                this.btnDownload.removeAttribute('download');
                this.btnDownload.removeAttribute('target');
            } else {
                this.btnDownload.href = this.data[this.insSwiper.activeIndex].media;
                this.btnDownload.classList.remove('ax-disabled');
                this.btnDownload.setAttribute('download', '');
                this.btnDownload.setAttribute('target', '_blank');
            }
        }
        if (this.options.zoom) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnZoom.classList.add('ax-disabled');
                this.insSwiper.zoom.disable();
            } else {
                this.btnZoom.classList.remove('ax-disabled');
                this.insSwiper.zoom.enable();
            }
        }
        if (this.options.share) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnShare.classList.add('ax-disabled');
            } else {
                this.btnShare.classList.remove('ax-disabled');
            }
        }
        this.insSwiper.on('slideChangeTransitionEnd', function () {
            if (_this.options.download) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnDownload.href = '###';
                    _this.btnDownload.classList.add('ax-disabled');
                    _this.btnDownload.removeAttribute('download');
                    _this.btnDownload.removeAttribute('target');
                } else {
                    _this.btnDownload.href = _this.data[this.activeIndex].media;
                    _this.btnDownload.classList.remove('ax-disabled');
                    _this.btnDownload.setAttribute('download', '');
                    _this.btnDownload.setAttribute('target', '_blank');
                }
            }
            if (_this.options.zoom) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnZoom.classList.add('ax-disabled');
                    _this.insSwiper.zoom.disable();
                } else {
                    _this.btnZoom.classList.remove('ax-disabled');
                    _this.btnZoom.classList.remove('ax-icon-zoomout');
                    _this.btnZoom.classList.add('ax-icon-zoomin');
                    _this.insSwiper.zoom.enable();
                }
            }
            if (_this.options.share) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnShare.classList.add('ax-disabled');
                } else {
                    _this.btnShare.classList.remove('ax-disabled');
                }
            }
            _this.targetDom.querySelectorAll('video,audio').forEach(elem => {
                elem.pause();
            });
            _this.zoomIn = false;
        })
        this.insSwiper.on('zoomChange',  (ins, scale)=> {
            if (scale > 1) {
                this.btnZoom.classList.remove('ax-icon-zoomin');
                this.btnZoom.classList.add('ax-icon-zoomout');
            } else {
                this.btnZoom.classList.remove('ax-icon-zoomout');
                this.btnZoom.classList.add('ax-icon-zoomin');
            }
        })
        this.options.onInit && this.options.onInit.call(this);
        'init' in this.handlers ? this.emit('init', '') : null;
        return this;
    }
    overlayClose(ev) {
        this.closeArea = [];
        let booPrev = true,
            booNext = true,
            booThumb = true;
        if (this.prev) {
            booPrev = axIsOutside(ev, this.prev);
        }
        this.closeArea.push(booPrev);
        if (this.next) {
            booNext = axIsOutside(ev, this.next)
        }
        this.closeArea.push(booNext);
        if (this.options.thumb) {
            booThumb = axIsOutside(ev, this.thumb);
        } else {
            booThumb = true;
        }
        this.closeArea.push(booThumb);
        this.swiperWrapper.querySelectorAll('.ax-media').forEach(item => {
            let dom = item.firstElementChild;
            this.closeArea.push(axIsOutside(ev, dom));
        })
        if (this.swiperWrapper.querySelectorAll('.ax-caption')) {
            this.swiperWrapper.querySelectorAll('.ax-caption').forEach(item => {
                this.closeArea.push(axIsOutside(ev, item));
            })
        }
        this.closeArea.push(axIsOutside(ev, this.operate));
        this.closeArea.push(axIsOutside(ev, this.pages));
        return this.closeArea;
    }
    createSlide() {
        let slideTpl = (src, type) => {
            if (type && type == 'video') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <video controls><source src="${src}"></video>
                    </div>
                </div>
                `
            } else if (type && type == 'audio') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <audio controls><source src="${src}" ></audio>
                    </div>
                </div>
                `
            } else if (type && type == 'iframe') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <iframe src="${src}" frameborder="0" width="100%" height="100%"></iframe>
                    </div>
                </div>
                `
            } else if (type && type == 'text') {
                if (src.substr(0, 1) == "#") {
                    src = document.querySelector(src).innerHTML;
                }
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <div class="ax-text">${src}</div>
                    </div>
                </div>
                `
            } else {
                return `
                <div class="ax-slide">
                    <div class="ax-media ax-zoom">
                        <img data-src="${src}" class="ax-lazy" />
                        <span class="ax-loading ax-white"><i></i></span>
                    </div>
                </div>
                `
            }
        }
        this.data.forEach(item => {
            let slide = null,
                caption = null;
            slide = axStrToDom(slideTpl(item.media, item.type));
            caption = item.caption ? axStrToDom(`<div class="ax-caption">${item.caption}</div>`) : null;
            caption ? slide.appendChild(caption) : null;
            this.swiperWrapper.appendChild(slide);
        })
    }
    createThumb() {
        this.thumb = axStrToDom('<div class="ax-thumb"><div class="ax-swiper"><div class="ax-wrapper"></div></div></div>');
        this.thumbWrapper = this.thumb.querySelector('.ax-wrapper');
        this.data.forEach(item => {
            let slide = axStrToDom(`
            <div class="ax-slide">
                <img data-src="${item.cover}" class="ax-lazy" />
                <span class="ax-loading ax-white"><i></i></span>
            </div>
            `);
            this.thumbWrapper.appendChild(slide);
        })
        return this.thumb;
    }
    createBox() {
        let boxTpl = `
        <div class="ax-lightbox">
        <div class="ax-overlay"></div>
        <div class="ax-tools">
            <div class="ax-pages"></div>
            <div class="ax-operate"><i class="ax-iconfont ax-icon-close" close></i></div>
        </div>
        <div class="ax-stage">
            <div class="ax-swiper">
                <div class="ax-wrapper">
                </div>
            </div>
        </div>
    </div>
      `;
        this.targetDom = axStrToDom(boxTpl);
        this.tools = this.targetDom.querySelector('.ax-tools');
        this.pages = this.targetDom.querySelector('.ax-pages');
        this.operate = this.targetDom.querySelector('.ax-operate');
        this.stage = this.targetDom.querySelector('.ax-stage');
        this.swiper = this.stage.querySelector('.ax-swiper');
        this.swiperWrapper = this.swiper.querySelector('.ax-wrapper');
        this.createBtn();
    }
    createBtn() {
        this.btnShare = axStrToDom('<i class="ax-iconfont ax-icon-share-f" share></i>');
        this.btnDownload = axStrToDom('<a href="###" class="ax-iconfont ax-icon-download" target="_blank" download></a>');
        this.btnZoom = axStrToDom('<i class="ax-iconfont ax-icon-zoomin" zoom></i>');
        this.btnList = axStrToDom('<i class="ax-iconfont ax-icon-list" list></i>');
        this.options.thumb ? this.operate.insertAdjacentElement('afterbegin', this.btnList) : null;
        this.options.download ? this.operate.insertAdjacentElement('afterbegin', this.btnDownload) : null;
        this.options.zoom ? this.operate.insertAdjacentElement('afterbegin', this.btnZoom) : null;
        this.options.share ? this.operate.insertAdjacentElement('afterbegin', this.btnShare) : null;
    }
    setAttribute() {
        for (let i = 0, len = this.data.length; i < len; i++) {
            if (this.data[i].hasOwnProperty('type') && (['iframe', 'video', 'text'].includes(this.data[i].type))) {
                this.options.thumb = false;
            }
            break;
        }
        if (this.data.length < 2) {
            this.options.thumb == false;
        }
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.init();
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        if (this.destroyed || this.shown || !this.targetDom || axIsVnode(this.targetDom)) {
            return this;
        }
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.style.visibility = 'visible';
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        callback && callback.call(this);
        this.options.onShown && this.options.onShown.call(this);
        'shown' in this.handlers ? this.emit('shown', '') : null;
        this.targetDom.onclick =  (ev)=> {
            this.overlayClose(ev);
            let closeArea = this.closeArea.includes(false);
            if (!closeArea && !this.zoomIn) {
                this.hide();
            }
        }
        this.shown = true;
        return this;
    }
    hide(callback) {
        if (this.destroyed || !this.shown) {
            return this;
        }
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        this.targetDom.classList.remove('ax-show');
        /*         setTimeout(function () {
                    _this.targetDom.remove();
                }, parseFloat(axStyle(_this.targetDom).transitionDuration) * 1000 * 2)
                 */
        this.targetDom.addEventListener('transitionend',  ()=> {
            this.targetDom.remove();
        }, false)
        this.shown = false;
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        callback && callback.call(this);
        this.options.onHidden && this.options.onHidden.call(this);
        'hidden' in this.handlers ? this.emit('hidden', '') : null;
        return this;
    }
    destroy() {
        this.targetDom.remove();
        callback && callback.call(this);
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    let getSource = (element) => {
        let elem = axIdToDom(element),
            obj = [{}],
            node = elem.nodeName;
        if (node == 'A') {
            if (elem.hasAttribute('href') && elem.getAttribute('href').indexOf('##') == -1) {
                obj[0].media = elem.getAttribute('href');
                obj[0].cover = elem.getAttribute('href');
            }
        } else if (node == 'IMG') {
            if (elem.hasAttribute('src')) {
                obj[0].media = elem.getAttribute('src');
                obj[0].cover = elem.getAttribute('src');
            }
        }
        if (elem.hasAttribute('type')) {
            obj[0].type = elem.getAttribute('type');
        } else {
            obj[0].type = 'image';
        }
        if (elem.hasAttribute('title')) {
            obj[0].caption = elem.getAttribute('title');
        } else if (elem.hasAttribute('alt')) {
            obj[0].caption = elem.getAttribute('alt');
        } else {
            obj[0].caption = '';
        }
        return obj;
    }
    let datas = [];
    let btns = [...document.querySelectorAll('[axLightbox]')].filter(i => i.getAttribute('axLightbox').includes('insName')),
        names = {};
    for (let i = 0, len = btns.length; i < len; i++) {
        let item = btns[i],
            name = axAttrToJson(item, 'axLightbox').insName;
        if (!name) {
            continue;
        }
        if (!names.hasOwnProperty(name)) {
            names[name] = [item];
        } else {
            names[name].push(item);
        }
    }
    for (let i in names) {
        let index = 0;
        names[i].forEach(k => {
            k.slideIndex = index;
            let data = [],
                src = axAttrToJson(k, 'axLightbox').src;
            if (src) {
                data = axCreateData(src, ['src', 'cover', 'caption', 'type'], 'figure', ['media', 'cover', 'caption', 'type'], ['', '', '', 'image'], function (data) {
                    data.forEach(item => {
                        if (!item.cover && item.type == 'image') {
                            item.cover = item.media
                        }
                        item.cover = item.cover ? item.cover : '';
                    });
                });
            } else {
                data = getSource(k);
            }
            index += data.length;
            if (axIsEmpty(datas)) {
                datas.push({ name: i, data: data });
            } else {
                datas.forEach(item => {
                    if (item.name == i) {
                        item.data.push(...data);
                    }
                })
                if (!datas.some(item => (item.name == i))) {
                    datas.push({ name: i, data: data });
                }
            }
        });
    }
    datas.forEach(item => {
        new axLightbox({
            insName: item.name,
            src: item.data,
        });
    });
    document.querySelectorAll('[axLightbox]').forEach((element) => {
        let attr = axAttrToJson(element, 'axLightbox'),
            name = attr.insName;
        if (name) {
            let ins = axInstance.find(name, 'lightbox');
            element.onclick = (ev) => {
                axPreventDefault(ev);
                if (ins) {
                    ins.init();
                    ins.insSwiper.slideTo(element.slideIndex, 0);
                    ins.show();
                }
            }
        } else {
            if (attr.src) {
                element.onclick = (ev) => {
                    axPreventDefault(ev);
                    new axLightbox('', element).init().show();
                }
            } else {
                element.onclick = (ev) => {
                    axPreventDefault(ev);
                    new axLightbox({
                        src: getSource(element),
                    }).init().show();
                }
            }
        }
    });
})();
/*!
* 插件：网页媒体懒加载；使用方法：new axLazyload('#id',{参数})
*/
class axLazyload {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            offset: '0px', 
            visible: [0, 0.5, 1], 
            parent: null,
            animation: 'ax-fadeIn',
            dataName: 'src',
            onBefore: '',
            onShow: '',
            onShowing: '',
            onShown: '',
            onAllShown: '',
            onIn: '',
            onOut: '',
            onAdd: '',
            onRemove: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.items = [];
        this.shownNum = 0;
        if (['VIDEO', 'AUDIO', 'IMG', 'IFRAME'].includes(this.targetDom.nodeName)) {
            this.type = 'single';
        } else {
            this.type = 'multiple';
        }
        this.parent = this.options.parent ? axIdToDom(this.options.parent) : this.options.parent;
        this.init();
        return this;
    }
    init() {
        axInstance.push(this, this.options.insName, 'lazyload');
        this.interactOpt();
        this.active();
        return this;
    }
    active() {
        this.createInteract();
        if (this.type === 'single') {
            this.items.push(this.targetDom);
        } else if (this.type === 'multiple') {
            this.items = [...this.targetDom.querySelectorAll('[data-' + this.options.dataName + ']')];
        }
        let flag = this.options.onBefore ? this.options.onBefore.call(this, this.items) : true;
        if (flag) {
            this.items.forEach(i => {
                i.lazyload = { observed: true };
                this.interact.observe(i);
            });
        }
        return this;
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.parent,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    createInteract() {
        this.interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                let args = [i.target, i];
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('data-' + this.options.dataName)) {
                        i.target.classList.add(this.options.animation);
                        if (i.target.nodeName === 'VIDEO' || i.target.nodeName === 'AUDIO') {
                            i.target.src = i.target.dataset[this.options.dataName];
                            i.target.querySelector('source').setAttribute('src', i.target.dataset[this.options.dataName]);
                        } else {
                            i.target.setAttribute('src', i.target.dataset[this.options.dataName]);
                        }
                        i.target.removeAttribute('data-' + this.options.dataName);
                        if (i.intersectionRatio === 0) {
                            i.target.lazyload.state = 'show';
                            this.handlers.hasOwnProperty('show') ? this.emit('show', ...args) : null;
                            this.options.onShow && this.options.onShow.call(this, ...args);
                        } else if (i.intersectionRatio === 1) {
                            i.target.lazyload.state = 'shown';
                            this.handlers.hasOwnProperty('shown') ? this.emit('shown', ...args) : null;
                            this.options.onShown && this.options.onShown.call(this, ...args);
                            this.shownNum++;
                            this.interact.unobserve(i.target);
                        } else {
                            i.target.lazyload.state = 'showing';
                            this.handlers.hasOwnProperty('showing') ? this.emit('showing', ...args) : null;
                            this.options.onShowing && this.options.onShowing.call(this, ...args);
                        }
                        this.handlers.hasOwnProperty('in') ? this.emit('in', ...args) : null;
                        this.options.onIn && this.options.onIn.call(this, ...args);
                        if (this.shownNum >= this.items.length) {
                            this.handlers.hasOwnProperty('allShown') ? this.emit('allShown', this.items) : null;
                            this.options.onAllShown && this.options.onAllShown.call(this, this.items);
                        }
                    }
                } else {
                    this.handlers.hasOwnProperty('out') ? this.emit('out', ...args) : null;
                    this.options.onOut && this.options.onOut.call(this, ...args);
                }
            });
        }, this.interactOpt());
    }
    getDoms(data) {
        let dataType = axType(data),
            doms = [];
        if (dataType === 'Array') {
            doms = data.map(k => axIdToDom(k)).filter(Boolean);
        } else if (dataType === 'String') {
            doms = axAllToDoms(data).filter(Boolean);
        }
        return doms;
    }
    add(data, callback) {
        let doms = this.getDoms(data);
        doms.forEach(i => {
            if (!i.lazyload) {
                i.lazyload = { observed: true };
                this.interact.observe(i);
                !this.items.includes(i)?this.items.push(i):null;
            } else {
                new axMessage({
                    content: `媒体文件${i.dataset.src || i.src}已经处于监听状态，不需要添加监听操作！`,
                    iconShow: true,
                    result: 'warning',
                }).show();
            }
        });
        this.handlers.hasOwnProperty('add') ? this.emit('add', doms) : null;
        this.options.onAdd && this.options.onAdd.call(this, doms);
        callback && callback.call(this, doms);
    }
    remove(data, callback) {
        let doms = this.getDoms(data);
        doms.forEach(i => {
            if (this.items.includes(i)) {
                if (i.lazyload) {
                    Reflect.deleteProperty(i, 'lazyload');
                    this.interact.unobserve(i);
                } else {
                    new axMessage({
                        content: `媒体文件${i.dataset.src || i.src}还未被监听，不需要取消监听操作！`,
                        iconShow: true,
                        result: 'warning',
                    }).show();
                }
            }
        });
        this.handlers.hasOwnProperty('remove') ? this.emit('remove', doms) : null;
        this.options.onRemove && this.options.onRemove.call(this, doms);
        callback && callback.call(this, doms);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：列表异步无限滚动；使用方法：new axInfinite('#id',{参数})
*/
class axInfinite {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            type: 'list', 
            offset: '0px', 
            visible: [0], 
            url: '', 
            urlMax: 20,
            data: [], 
            template: null, 
            selector: '',
            trigger: 'scroll',
            parent: null,
            animation: 'ax-fadeIn',
            start: 0,
            count: 10, 
            finishText: '没有更多内容了',
            nextBtn: '<button class="ax-btn ax-btn-primary ax-longer">查看更多</button>',
            ajaxType: 'post',
            active: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.start = this.options.start;
        this.data = this.options.data;
        this.loadStatus = this.targetDom.querySelector('.ax-infinite-status') ? this.targetDom.querySelector('.ax-infinite-status') : axAddElem('div', { class: 'ax-infinite-status' });
        this.loadingDiv = axAddElem('div', { class: 'ax-infinite-loading' }, '<span class="ax-loading"><i></i></span>');
        this.resultDiv = axAddElem('div', { class: 'ax-infinite-tips' });
        this.nextDiv = axAddElem('div', { class: 'ax-infinite-next' }, this.options.nextBtn);
        this.nextButton = this.nextDiv.firstElementChild;
        this.loadStatus.insertAdjacentElement('afterbegin', this.loadingDiv);
        this.loadStatus.appendChild(this.resultDiv);
        this.url = [];
        if (typeof this.options.url === 'string') {
            if (this.options.url.indexOf('{') > 0 && this.options.url.indexOf('}') > 0) {
                let pageStart = ~~this.options.url.match(/\{(\S*)\}/)[1],
                    str = `{${pageStart}}`;
                for (let i = pageStart; i <= pageStart + this.options.urlMax; i++) {
                    this.url.push(this.options.url.replace(str, i));
                }
            } else if (this.options.url === 'pagination') {
                let pages = this.loadStatus.querySelectorAll('[data-page]');
                [...pages].forEach(i => {
                    this.url.push(i.href);
                });
            } else {
                this.options.url ? this.url = [this.options.url] : null;
            }
        } else if (axType(this.options.url) == 'Array') {
            this.url = this.options.url;
        }
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.items = [];
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'infinite');
        if (this.options.type != 'image' && !this.targetDom.classList.contains('ax-infinite')) {
            this.targetDom.classList.add('ax-infinite');
        }
        this.interactOpt();
        if (this.options.trigger == 'scroll') {
            this.active();
        } else if (this.options.trigger == 'clicks') {
            this.loadStatus.appendChild(this.nextDiv);
            this.loadStatus.setAttribute('preloading', '');
            this.targetDom.appendChild(this.loadStatus);
            this.nextButton.onclick = () => {
                this.loadStatus.removeAttribute('preloading', '');
                this.loadStatus.removeAttribute('loaded', '');
                this.loadStatus.setAttribute('loading', '');
                if (this.options.type == 'pages') {
                    this.getAsyncData('page', { start: this.start });
                } else if (this.options.url && this.options.template) {
                    if (this.options.type == 'json') {
                        this.getAsyncData('json', { start: this.start });
                    } else if (this.options.type == 'sql') {
                        this.getAsyncData('sql', { start: this.start, count: this.options.count });
                    }
                }
            }
        }
    }
    active(url, callback) {
        if (!axIsEmpty(url)) {
            if (axType(url) == 'Array') {
                this.url.push(...url)
            } else {
                this.url.push(url);
            }
        }
        if (this.options.type == 'pages') {
            this.asyncInteract('page');
        } else if (!axIsEmpty(this.url) && this.options.template) {
            if (this.options.type == 'json') {
                this.asyncInteract('json');
            } else if (this.options.type == 'sql') {
                this.asyncInteract('sql');
            }
        } else if (this.options.type == 'list') {
            if (!axIsEmpty(this.data)) {
                this.renderList(this.data);
            }
            let children = [...this.targetDom.childNodes].filter(i => i.nodeType == 1);
            children.forEach(i => {
                if (axOffset(i).top > window.innerHeight) {
                    i.setAttribute('infinite', '');
                    this.items.push(i);
                }
            });
            this.listInteract();
            this.items.forEach(i => {
                this.listInteract().observe(i);
            });
        }
        callback && callback.call(this);
        this.options.active && this.options.active.call(this);
        'activated' in this.handlers ? this.emit('activated', '') : null;
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.options.parent,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    listInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('infinite')) {
                        i.target.classList.add(this.options.animation);
                        i.target.removeAttribute('infinite');
                        interact.unobserve(i.target);
                    }
                    'shown' in this.handlers ? this.emit('shown', i.target) : null;
                }
            });
        }, this.interactOpt());
        return interact;
    }
    asyncInteract(type) {
        this.targetDom.appendChild(this.loadStatus);
        this.asyncObserver = new IntersectionObserver(entries => {
            if (entries[0].isIntersecting) {
                if (type == 'page' || type === 'json') {
                    this.getAsyncData(type, { start: this.start });
                } else if (type === 'sql') {
                    this.getAsyncData('sql', { start: this.start, count: this.options.count });
                }
            }
        }, this.interactOpt());
        this.asyncObserver.observe(this.loadStatus);
    }
    itemInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('infinite')) {
                        i.target.classList.add(this.options.animation);
                        i.target.removeAttribute('infinite');
                        interact.unobserve(i.target);
                        'shown' in this.handlers ? this.emit('shown', i.target) : null;
                    }
                }
            });
        }, this.interactOpt());
        return interact;
    }
    renderList(data) {
        let fragment = document.createDocumentFragment();
        data.forEach(i => {
            let item = axStrToDom(axTplEngine(this.template, i));
            item.setAttribute('infinite', '');
            this.items.push(item);
            fragment.appendChild(item);
        });
        this.targetDom.appendChild(fragment);
        !this.options.type == 'list' ? this.targetDom.appendChild(this.loadStatus) : null;
    }
    loadFinish() {
        this.options.trigger != 'clicks' ? this.asyncObserver.disconnect() : null;
        this.loadStatus.removeAttribute('loading');
        this.loadStatus.removeAttribute('loaded');
        this.loadStatus.setAttribute('finish', '');
        this.loadingDiv ? this.loadingDiv.remove() : null;
        this.nextDiv ? this.nextDiv.remove() : null;
        this.resultDiv.innerHTML = this.options.finishText;
        'finished' in this.handlers ? this.emit('finished', '') : null;
    }
    getAsyncData(type = 'json', options, callback) {
        return axAjax({
            data: type === 'sql' ? { start: options.start, count: options.count } : '',
            type: this.options.ajaxType,
            url: type === 'sql' ? this.options.url : this.url[options.start],
            selector: this.options.selector,
            error: (response) => {
                if(response.status == '404'){
                    new axMessage({
                        content:'已经没有更多内容了！',
                        result:'warning',
                        iconShow:true,
                    }).show();
                }else{
                    console.error(`发生错误：${response.status}，可能是地址错误！`);
                }
                this.loadFinish();
            },
            opened: (response) => {
                this.contentXhr = response.xhr;
            },
            success: (response) => {
                if (type === 'page') {
                    this.targetDom.insertAdjacentHTML('beforeEnd', response.content);
                    this.targetDom.appendChild(this.loadStatus);
                    this.start++;
                    if (this.start >= this.url.length) {
                        this.loadFinish();
                    }
                } else {
                    this.itemInteract();
                    if (type === 'json') {
                        this.renderList(response.content);
                        this.targetDom.appendChild(this.loadStatus);
                        this.start++;
                        if (this.start >= this.url.length) {
                            this.loadFinish();
                        }
                    } else if (type === 'sql') {
                        this.renderList(response.content.data);
                        this.targetDom.appendChild(this.loadStatus);
                        this.start += options.count;
                        if (this.start >= response.content.total) {
                            this.loadFinish();
                        }
                    }
                }
                if (this.options.trigger == 'clicks') {
                    this.loadStatus.removeAttribute('loading', '');
                    this.loadStatus.setAttribute('loaded', '');
                }
                this.items.forEach(i => {
                    this.itemInteract().observe(i);
                });
                this.handlers.hasOwnProperty('loaded') ? this.emit('loaded', response.content) : null;
                callback && callback(response.content);
            }
        });
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axInfinite]').forEach(element => {
        new axInfinite(element);
    });
})(); */
/*!
* 插件：进度条；使用方法：new axProgress('#id',{参数})
*/
class axProgress {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            type: 'line', 
            color: '',
            gradient: false,
            linecap: 'round',
            size: '',
            range: [0, 100],
            value: 0,
            duration: '',
            rotate: false,
            trackShow: true,
            labelFormat: '',
            labelShow: true,
            lablePlace: '',
            labelText: {
                unit: '%',
                tips: '当前进度',
                complete: '完成!',
            },
            started: '',
            completed: '',
            processing: '',
        }, options, this.targetDom,this.constructor.name);
        this.handlers = {};
        this.circleWidth = 251.2;
        this.semiWidth = 125.6;
        this.gapWidth = 167.6;
        let getValue;
        if (this.options.type == 'circle') {
            getValue = (this.circleWidth - ((this.options.value / this.options.range[1]) * this.circleWidth))
        } else if (this.options.type == 'semicircle') {
            getValue = (this.semiWidth - ((this.options.value / this.options.range[1]) * this.semiWidth));
        } else if (this.options.type == 'gapcircle') {
            getValue = (this.gapWidth - ((this.options.value / this.options.range[1]) * this.gapWidth));
        } else {
            getValue = Math.abs((this.options.value / (this.options.range[1] - this.options.range[0])) * 100);
        }
        this.trueValue = this.getDecimals(getValue);
        this.value = this.options.value;
        this.complete = this.value == this.options.range[1] ? true : false;
        this.completeDom = axAddElem('span', { complete: '' }, `${this.options.labelText.complete}`);
        this.init();
        return this;
    }
    init() {
        axInstance.push(this, this.options.insName, 'progress');
        this.getTrueValue(this.options.value);
        this.createHtml();
        this.setAttribute();
        this.hasComplete();
        this.options.started && this.options.started.call(this);
        'started' in this.handlers ? this.emit('started', '') : null;
        return this;
    }
    hasComplete() {
        if (this.complete) {
            this.targetDom.setAttribute('complete', 'true');
            this.labelDom ? this.labelDom.appendChild(this.completeDom) : null;
            this.options.completed && this.options.completed.call(this);
            'completed' in this.handlers ? this.emit('completed', '') : null;
        } else {
            this.targetDom.removeAttribute('complete');
        }
    }
    createAnimation() {
        let dftTime = width => width * 3 + 200;
        let time;
        if (this.options.duration !== undefined && typeof this.options.duration === 'number') {
            time = this.options.duration;
        } else {
            time = dftTime(Math.abs(this.barDiffer));
        }
        let initTime = new Date().getTime();
        let repeat = () => {
            if (this.complete) {
                this.complete = false;
                this.hasComplete();
            }
            let newTime = new Date().getTime() - initTime,
                timestep = newTime / time,
                timefactor = axCurves.easeOut(timestep),
                valueStep = this.lastValue + this.valueDiffer * timefactor,
                barStep = this.lastTrueValue + this.barDiffer * timefactor;
            if (newTime <= time) {
                let value = this.getDecimals(valueStep),
                    trueValue = this.getDecimals(barStep);
                if (this.options.type == 'line') {
                    this.bar.style.width = trueValue + '%';
                } else {
                    this.bar.setAttribute('stroke-dashoffset', trueValue);
                }
                this.progressDom ? this.progressDom.innerText = Math.trunc(valueStep) : null;
                this.options.processing && this.options.processing.call(this, value, trueValue);
                'processing' in this.handlers ? this.emit('processing', value, trueValue) : null;
            } else {
                if (this.options.type == 'line') {
                    this.bar.style.width = this.trueValue + '%';
                } else {
                    this.bar.setAttribute('stroke-dashoffset', this.trueValue);
                }
                this.progressDom ? this.progressDom.innerText = this.value : null;
                this.complete = this.value >= this.options.range[1] ? true : false;
            }
            let repeatLoop = requestAnimationFrame(repeat);
            if (newTime > time) {
                cancelAnimationFrame(repeatLoop);
                this.hasComplete();
                if (this.value <= 0) {
                    this.options.started && this.options.started.call(this);
                    'started' in this.handlers ? this.emit('started', '') : null;
                }
            }
        };
        repeat();
    }
    getDecimals(num) {
        return Math.floor(num * 100) / 100;
    }
    getTrueValue(val) {
        if (val < this.options.range[0]) {
            val = this.options.range[0];
        } else if (val > this.options.range[1]) {
            val = this.options.range[1];
        }
        this.valueDiffer = val - this.value;
        this.lastValue = this.value;
        this.value = val;
        if (this.options.type == 'circle') {
            this.barDiffer = (this.circleWidth - ((val / this.options.range[1]) * this.circleWidth)) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = (this.circleWidth - ((val / this.options.range[1]) * this.circleWidth));
            this.trueValue > this.circleWidth ? this.trueValue = this.circleWidth : this.trueValue = this.getDecimals(this.trueValue);
        } else if (this.options.type == 'semicircle') {
            this.barDiffer = (this.semiWidth - ((val / this.options.range[1]) * this.semiWidth)) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = (this.semiWidth - ((val / this.options.range[1]) * this.semiWidth));
            this.trueValue > this.semiWidth ? this.trueValue = this.semiWidth : this.trueValue = this.getDecimals(this.trueValue);
        }else if (this.options.type == 'gapcircle') {
            this.barDiffer = (this.gapWidth - ((val / this.options.range[1]) * this.gapWidth)) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = (this.gapWidth - ((val / this.options.range[1]) * this.gapWidth));
            this.trueValue > this.gapWidth ? this.trueValue = this.gapWidth : this.trueValue = this.getDecimals(this.trueValue);
        } else if (this.options.type == 'line') {
            this.barDiffer = Math.abs((val / (this.options.range[1] - this.options.range[0])) * 100) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = Math.abs((val / (this.options.range[1] - this.options.range[0])) * 100);
            this.trueValue > 100 ? this.trueValue = 100 : this.trueValue = this.getDecimals(this.trueValue);
        }
    }
    setAttribute() {
        this.targetDom.setAttribute('linecap', this.options.linecap);
        this.targetDom.setAttribute('type', this.options.type);
        this.options.size ? this.targetDom.setAttribute('size', this.options.size) : null;
        this.options.color ? this.targetDom.setAttribute('color', this.options.color) : null;
        this.options.gradient ? this.targetDom.setAttribute('gradient', '') : null;
        !this.options.trackShow ? this.targetDom.setAttribute('track', 'false') : null;
        if (this.options.rotate) {
            this.wrapper.classList.add('ax-rotate360');
            this.wrapper.style.animationIterationCount = 'infinite';
        }
    }
    createHtml() {
        let svg;
        if (this.options.type == 'line') {
            this.wrapper = axAddElem('div', { 'track': '' });
            this.bar = axAddElem('div', { 'bar': '', 'style': `width:${this.trueValue}%` });
            this.labelFormat = this.options.labelFormat ? this.options.labelFormat : `<span label><i progress></i><i unit></i></span>`;
        } else {
            this.labelFormat = this.options.labelFormat ? this.options.labelFormat : `<div label><div tips></div><div result><i progress></i><i unit></i></div></div>`;
            let gradient = '';
            if (this.options.gradient) {
                if (this.options.color == 'primary') {
                    gradient = `
                <linearGradient id="svgbar-primary" >
                    <stop offset="0%" style="stop-color:var(--color-primary);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-primary-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'secondary') {
                    gradient = `
                <linearGradient id="svgbar-secondary" >
                    <stop offset="0%" style="stop-color:var(--color-secondary);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-secondary-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'danger') {
                    gradient = `
                <linearGradient id="svgbar-danger" >
                    <stop offset="0%" style="stop-color:var(--color-danger);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-danger-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'success') {
                    gradient = `
                <linearGradient id="svgbar-success" >
                    <stop offset="0%" style="stop-color:var(--color-success);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-success-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'warning') {
                    gradient = `
            <linearGradient id="svgbar-warning" >
                <stop offset="0%" style="stop-color:var(--color-warning);" ></stop>
                <stop offset="100%" style="stop-color:var(--color-warning-like);" ></stop>
            </linearGradient>
          `;
                } else if (this.options.color == 'info') {
                    gradient = `
                <linearGradient id="svgbar-info" >
                    <stop offset="0%" style="stop-color:var(--color-info);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-info-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'ad') {
                    gradient = `
                <linearGradient id="svgbar-ad" >
                    <stop offset="0%" style="stop-color:var(--color-ad);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-ad-like);"></stop>
                </linearGradient>
              `;
                }
            }
            if (this.options.type == 'circle') {
                svg = `<svg viewBox="0 0 100 100">
                            ${gradient}
                            ${this.options.trackShow ? '<path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0  a 40 40 0 1 1 -80 0" track></path>' : ''}
                            <path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0  a 40 40 0 1 1 -80 0" bar stroke-dasharray=${this.circleWidth} stroke-linecap=${this.options.linecap}  stroke-dashoffset=${this.trueValue}></path>
                       </svg>
                        `;
            } else if (this.options.type == 'semicircle') {
                svg = `<svg viewBox="0 0 100 60">
                            ${gradient}
                            ${this.options.trackShow ? `<path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0" track stroke-linecap=${this.options.linecap}></path>` : ''}
                            <path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0" bar stroke-dasharray=${this.semiWidth} stroke-linecap=${this.options.linecap} stroke-dashoffset=${this.trueValue}></path>
                       </svg>
                        `;
            }
            else if (this.options.type == 'gapcircle') {
                svg = `<svg viewBox="0 0 100 80">
                            ${gradient}
                            ${this.options.trackShow ? `<path d="M15.367,70.026C11.954,64.137,10,57.296,10,49.999 C10,27.909,27.909,10,50,10c22.092,0,40,17.909,40,39.999c0,7.295-1.952,14.134-5.363,20.022" track stroke-linecap=${this.options.linecap}></path>` : ''}
                            <path d="M15.367,70.026C11.954,64.137,10,57.296,10,49.999 C10,27.909,27.909,10,50,10c22.092,0,40,17.909,40,39.999c0,7.295-1.952,14.134-5.363,20.022" bar stroke-dasharray=${this.gapWidth} stroke-linecap=${this.options.linecap} stroke-dashoffset=${this.trueValue}></path>
                       </svg>
                        `;
            }
        }
        if (this.options.labelShow) {
            if (!this.options.labelPlace) {
                this.targetDom.insertAdjacentHTML('beforeEnd', this.labelFormat);
                this.labelDom = this.targetDom.querySelector('[label]');
            } else {
                let place = axIdToDom(this.options.labelPlace);
                place.insertAdjacentHTML('beforeEnd', this.labelFormat);
                this.labelDom = place.querySelector('[label]');
            }
            this.progressDom = this.labelDom.querySelector('[progress]');
            this.unitDom = this.labelDom.querySelector('[unit]');
            this.tipsDom = this.labelDom.querySelector('[tips]');
            this.progressDom ? this.progressDom.innerHTML = this.value : null;
            this.unitDom ? this.unitDom.innerHTML = this.options.labelText.unit : null;
            this.tipsDom ? this.tipsDom.innerHTML = this.options.labelText.tips : null;
        }
        if (this.options.type == 'line') {
            this.wrapper.appendChild(this.bar);
            this.targetDom.insertAdjacentElement('afterBegin', this.wrapper);
        } else {
            this.targetDom.insertAdjacentHTML('afterBegin', svg);
            this.wrapper = this.targetDom.querySelector('svg');
            this.bar = this.wrapper.querySelector('[bar]');
            this.track = this.wrapper.querySelector('[track]');
        }
    }
    set(val, callback) {
        this.getTrueValue(val);
        if (this.value == this.lastValue) {
            return false;
        }
        this.createAnimation();
        callback && callback.call(this);
        'seted' in this.handlers ? this.emit('seted', this.value, this.trueValue) : null;
        return this;
    }
    get() {
        return {
            value: this.value,
            trueValue: this.trueValue,
            lastValue: this.lastValue,
            lastTrueValue: this.lastTrueValue,
            complete: this.complete
        };
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axProgress]').forEach(element => {
        new axProgress(element);
    });
})(); */
/*!
 * 插件：创建单行文本域和多行文本域；使用方法：new axInput('#id',{参数})
 * text、textarea、hidden、url、tel、search、email、color、number、range、month、week、date、time、datetime、datetime-local
 * submit、reset和button特别，通过value设定名称
 * radio和checkbox请使用axCheckbox组件
 */
class axInput {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            insName: '',
            type: 'text', 
            name: '', 
            value: '', 
            limit: 0, 
            placeholder: '', 
            width: '', 
            height: '', 
            size: '', 
            className: '', 
            props: '', 
            toolsShow: true, 
            extend: '', 
            clearShow: false, 
            onClear: '', 
            onSet: '', 
            onReset: '', 
            onInit: '', 
            onExceed: '', 
            onInput: '', 
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.output = { name: this.options.name };
        this.createElem();
        this.setAttribute();
        this.addExtend(this.options.extend);
        axInstance.push(this, this.options.insName, 'input');
    }
    createElem() {
        let getField = () => {
            if (this.options.type == 'textarea') {
                this.field = axAddElem('textarea', { name: this.options.name, placeholder: this.options.placeholder });
            } else if (this.options.type == 'button') {
                this.field = axAddElem('button', '', this.options.value);
            } else {
                this.field = axAddElem('input', { type: this.options.type, name: this.options.name, placeholder: this.options.placeholder });
            }
        }
        if (this.targetDom) {
            if (this.targetDom.nodeName == 'INPUT' || this.targetDom.nodeName == 'TEXTAREA' || this.targetDom.nodeName == 'BUTTON') {
                this.parent = this.targetDom.parentElement;
                this.field = this.targetDom;
            } else {
                this.parent = this.targetDom;
                getField();
            }
        } else {
            this.parent = axAddElem('div', { class: 'ax-form-wrapper' });
            getField();
        }
        this.parent.appendChild(this.field);
        if (this.parent.querySelector('.ax-pos-right')) {
            this.tools = this.parent.querySelector('.ax-pos-right');
        } else {
            this.tools = axAddElem('span', { class: "ax-pos-right" });
        }
        if (this.tools.querySelector('[clear]')) {
            this.clearBtn = this.tools.querySelector('[clear]');
        } else {
            this.clearBtn = axAddElem('a', { href: '###', class: "ax-iconfont ax-icon-close", clear: '' });
            if (this.options.clearShow) {
                this.tools.appendChild(this.clearBtn);
            }
        }
        if (this.clearBtn) {
            this.clearBtn.onclick = () => {
                this.clear();
            }
            this.clearBtn.clear = true;
        }
        this.options.toolsShow ? this.parent.appendChild(this.tools) : null;
        if (this.options.limit) {
            this.limit = axAddElem('div', { class: "ax-form-limit" }, `已输入<i have>0</i>个字符,还可以输入<i remainder>${this.options.limit}</i>个字`);
            let have = this.limit.querySelector('[have]'),
                remainder = this.limit.querySelector('[remainder]');
            this.parent.appendChild(this.limit);
            this.field.oninput = () => {
                let obj = this.intercept(this.field.value);
                this.field.value = obj.text;
                have ? have.innerHTML = obj.have : null;
                remainder ? remainder.innerHTML = obj.remainder : null;
                this.options.onInput && this.options.onInput.call(this, this.output);
                'input' in this.handlers ? this.emit('input', this.output) : null;
            }
        }
        this.options.value ? this.set(this.options.value) : null;
        this.output.dom = this.field;
        this.output.parent = this.parent;
        this.output.type = this.options.type;
        this.options.onInit && this.options.onInit.call(this, this.output);
    }
    setAttribute() {
        this.options.className ? this.field.setAttribute('class', this.options.className) : null;
        this.options.width ? this.field.style.width = this.options.width : null;
        this.options.height ? this.field.style.height = this.options.height : null;
        this.options.size ? this.field.classList.add(`ax-${this.options.size}`) : null;
        for (let i in this.options.props) {
            this.field.setAttribute(i, this.options.props[i]);
        }
    }
    addExtend(data) {
        if (!this.options.toolsShow) {
            return false;
        }
        let render = (obj) => {
            let btn = axAddElem(obj.node || 'a', { class: obj.icon }, obj.text);
            btn.setAttribute(obj.name, '');
            if (obj.props) {
                for (let i in obj.props) {
                    this.field.setAttribute(i, obj.props[i]);
                }
            }
            this.tools.appendChild(btn);
            obj.callback && obj.callback.call(this, btn, this.field);
        }
        if (Array.isArray(data)) {
            data.forEach(i => {
                render(i);
            });
        } else {
            render(data);
        }
    }
    intercept(text) {
        let len = text.length,
            obj = {};
        if (len >= this.options.limit && this.options.limit) {
            obj = { text: text.substring(0, this.options.limit), have: this.options.limit, remainder: 0 }
            this.limit ? this.limit.classList.add('ax-color-danger') : null;
            this.options.onExceed && this.options.onExceed.call(this, this.output);
            'exceed' in this.handlers ? this.emit('exceed', this.output) : null;
        } else {
            this.limit ? this.limit.classList.remove('ax-color-danger') : null;
            obj = { text: text, have: text.length, remainder: Math.abs(this.options.limit - len) }
        }
        return obj;
    }
    set(str, callback) {
        if(Array.isArray(str)){
            str = JSON.stringify(str[0]);
        }else if(typeof str != 'string'){
            str = JSON.stringify(str);
        }
        let text = str.replace(/<[^>]+>/g, '').trim(),
            obj = this.intercept(text);
        this.field.value = obj.text;
        if (this.limit) {
            this.limit.querySelector('[have]') ? this.limit.querySelector('[have]').innerHTML = obj.have : null;
            this.limit.querySelector('[remainder]') ? this.limit.querySelector('[remainder]').innerHTML = obj.remainder : null;
        }
        this.output.value = this.field.value;
        callback && callback.call(this, this.field, obj.text, obj.remainder);
        this.options.onSet && this.options.onSet.call(this, this.field, obj.text, obj.remainder);
        'set' in this.handlers ? this.emit('set', this.field, obj.text, obj.remainder) : null;
        return this;
    }
    getValues() {
        return this.field.value;
    }
    clear(callback) {
        this.set('');
        callback && callback.call(this, this.field);
        this.options.onClear && this.options.onClear.call(this, this.field);
        'clear' in this.handlers ? this.emit('clear', this.field) : null;
    }
    reset(callback){
        this.set(this.options.value);
        callback && callback.call(this, this.field);
        this.options.onReset && this.options.onReset.call(this, this.field);
        'reset' in this.handlers ? this.emit('reset', this.field) : null;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axInput]').forEach(element => {
        new axInput(element);
    });
})(); */
/*!
 * 插件：单选和多选文本域；使用方法：new axCheckbox('#id',{参数})
 */
class axCheckbox {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            insName: '',
            type: 'checkbox', 
            style: 'beautify', 
            name: '', 
            children: '', 
            /* [{
                checked: false, 
                disabled: false, 
                value: '', 
                label: '', 
                props: {}, 
                callback: '', 
            }],  */
            value: '', 
            limit: 0, 
            separator: ',', 
            size: '', 
            parentClass: '', 
            childClass: '',
            props: '', 
            display: '', 
            gap: '', 
            columns: 0, 
            clearShow: true, 
            onClear: '', 
            onSet: '', 
            onReset: '', 
            onAddChecked: '', 
            onExceed: '', 
            onInit: '', 
            onChange: '', 
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.output = { children: [] };
        this.getChildren();
        this.name = this.options.name;
        this.trueLimit = this.children.length <= this.options.limit ? this.children.length : this.options.limit;
        this.createParent();
        this.setAttribute();
        if (!axIsEmpty(this.options.value)) {
            this.set(this.options.value);
        }
         axInstance.push(this, this.options.insName, 'checkbox');
         return this;
    }
    getChildren() {
        if (Array.isArray(this.options.children)) {
            if (typeof this.options.children[0] === 'object') {
                this.options.children.forEach(i => {
                    if (!i.hasOwnProperty('value')) {
                        i.value = i.label;
                    }
                });
                this.children = this.options.children;
            } else {
                this.children = this.options.children.map(i => {
                    return { label: i, value: i };
                });
            }
        } else {
            if (typeof this.options.children === 'object') {
                if (!this.options.children.hasOwnProperty('value')) {
                    this.options.children.value = this.options.children.label;
                }
                this.children = [this.options.children];
            } else {
                this.children = [{ label: this.options.children, value: this.options.children }]
            }
        }
    }
    createParent() {
        if (!this.targetDom || this.targetDom.nodeName == 'INPUT') {
            this.parent = axAddElem('div', { class: 'ax-form-wrapper' });
            if (this.targetDom.nodeName == 'INPUT') {
                this.hidden = this.targetDom;
                this.hidden.insertAdjacentElement('beforeBegin', this.parent);
                this.name = this.targetDom.name;
                this.hidden.type != 'hidden' ? this.hidden.style.display = 'none' : null;
            }
        } else {
            this.parent = this.targetDom;
        }
        if (this.children.length > 0) {
            this.children.forEach(i => {
                this.createElem(i);
            });
        }
        let checkedDoms = this.output.children.filter(i => i.checked);
        for (let i = 0, len = checkedDoms.length; i < len; i++) {
            let item = checkedDoms[i],
                input = item.dom.querySelector('input');
            if (this.options.type == 'radio') {
                if (i > 0) {
                    item.checked = false;
                    break;
                } else {
                    input.setAttribute('checked', '');
                    item.checked = true;
                }
            } else if (this.options.type == 'checkbox') {
                if (i < this.trueLimit || !this.trueLimit) {
                    input.setAttribute('checked', '');
                    item.checked = true;
                } else {
                    item.checked = false;
                }
            }
        }
        if (this.options.limit) {
            this.limit = axAddElem('div', { class: "ax-form-limit" }, `已选择<i have>0</i>项,还可以选择<i remainder>${this.options.limit}</i>项`);
            this.resetLimit();
            this.parent.insertAdjacentElement('afterend', this.limit);
        }
        this.output.name = this.name;
        this.output.parent = this.parent;
        this.output.type = this.options.type;
        this.output.value = this.getValues();
        if (this.hidden) {
            this.hidden.value = this.getValues('string', this.options.separator);
        }
        this.output.children.forEach(i => {
            let input = i.dom.querySelector('input');
            input.onchange = () => {
                this.change(i);
            }
        });
        this.options.onInit && this.options.onInit.call(this, this.output);
    }
    createElem(obj) {
        let tpl = `<label class="ax-${this.options.style == 'beautify' ? this.options.type : this.options.style}"><input name="${this.name + '_ax_alt'}" value="${obj.value}" ${obj.disabled ? 'disabled' : ''} type="${this.options.type}"><u></u>${obj.label ? '<i>' + obj.label + '</i>' : ''}</label>`,
            elem = axStrToDom(axTplEngine(tpl, obj)),
            labelWrapper = axAddElem('div');
        if (this.options.childClass) {
            axClass.add(labelWrapper, this.options.childClass);
        }
        this.options.size ? elem.classList.add(`ax-${this.options.size}`) : null;
        for (let i in obj.props) {
            elem.setAttribute(i, obj.props[i]);
        }
        if (this.options.display == 'grid' || this.options.display == 'block') {
            labelWrapper.appendChild(elem);
            this.parent.appendChild(labelWrapper)
        } else {
            this.parent.appendChild(elem);
        }
        let item = { dom: elem, label: obj.label, value: obj.value, checked: obj.checked ? obj.checked : false, disabled: obj.disabled ? obj.disabled : false }
        this.output.children.push(item);
        obj.callback && obj.callback.call(this, item);
        return elem;
    }
    setAttribute() {
        if (this.options.parentClass) {
            axClass.add(this.parent, this.options.parentClass);
        }
        for (let i in this.options.props) {
            this.parent.setAttribute(i, this.options.props[i]);
        }
        if (this.options.display == 'grid') {
            this.parent.classList.add('ax-grid');
            if (this.options.columns) {
                this.parent.classList.add(`ax-grid-${this.options.columns}`);
            };
            if (this.options.gap) {
                this.parent.style.gridColumnGap = this.options.gap;
            }
        }
    }
    change(item) {
        let input = item.dom.querySelector('input'),
            value = item.value;
        if (!value) {
            return false;
        }
        if (input.checked) {
            if (this.options.type == 'radio') {
                let old = this.output.children.find(i => i.checked);
                old ? old.checked = false : null;
            }
            item.checked = true;
        } else {
            item.checked = false;
        }
        let checkedItems = this.output.children.filter(i => i.checked);
        if (this.trueLimit && checkedItems.length > this.trueLimit) {
            input.checked = false;
            item.checked = false;
        }
        this.output.value = this.getValues();
        if (this.hidden) {
            this.hidden.value = this.getValues('string', this.options.separator);
            this.hidden.onchange ? this.hidden.onchange() : null;
        }
        this.resetLimit();
        this.intercept();
        this.options.onChange && this.options.onChange.call(this, item);
        'change' in this.handlers ? this.emit('change', item) : null;
    }
    intercept() {
        let len = this.output.children.filter(i => i.checked).length,
            flag = false;
        if (!this.trueLimit) {
            return false;
        }
        if (len >= this.trueLimit) {
            flag = true;
            this.options.onExceed && this.options.onExceed.call(this, this.output);
            'exceed' in this.handlers ? this.emit('exceed', this.output) : null;
        } else {
            flag = false;
        }
        return flag;
    }
    resetLimit() {
        if (!this.trueLimit) {
            return false;
        }
        let len = this.output.children.filter(i => i.checked).length,
            have = this.limit.querySelector('[have]'),
            remainder = this.limit.querySelector('[remainder]');
        if (len >= this.trueLimit) {
            this.limit ? this.limit.classList.add('ax-color-danger') : null;
            have.innerHTML = this.trueLimit;
            remainder.innerHTML = 0;
        } else {
            this.limit ? this.limit.classList.remove('ax-color-danger') : null;
            have.innerHTML = len;
            remainder.innerHTML = this.trueLimit - len;
        }
    }
    set(data, callback) {
        if (this.options.type == 'radio') {
            let str = '';
            if (Array.isArray(data)) {
                str = data[0];
            } else {
                str = data;
            }
            let item, other;
            if (!str) {
                item = this.output.children.find(i => i.checked);
                if (item) {
                    item.checked = false;
                    item.dom.querySelector('input').checked = false;
                }
            } else {
                item = this.output.children.find(i => i.value == str);
                other = this.output.children.filter(i => i.value != str);
                if (item) {
                    item.checked = true;
                    item.dom.querySelector('input').checked = true;
                }
                other.forEach(i => {
                    i.checked = false;
                    i.dom.querySelector('input').checked = false;
                });
            }
        } else if (this.options.type == 'checkbox') {
            let arr;
            if (Array.isArray(data)) {
                arr = data;
            } else if (typeof data === 'string') {
                arr = data.split(this.options.separator);
            } else {
                arr = [data];
            }
            arr = arr.filter(Boolean);
            if (this.trueLimit && arr.length > this.trueLimit) {
                arr = arr.slice(0, this.trueLimit);
            }
            this.output.children.forEach(i => {
                let input = i.dom.querySelector('input');
                if (arr.includes(i.value)) {
                    i.checked = true;
                    input.checked = true;
                } else {
                    i.checked = false;
                    input.checked = false;
                }
            });
        }
        this.output.value = this.getValues();
        this.hidden ? this.hidden.value = this.getValues('string', this.options.separator) : null;
        this.resetLimit();
        callback && callback.call(this, this.output);
        this.options.onSet && this.options.onSet.call(this, this.output);
        'set' in this.handlers ? this.emit('set', this.output) : null;
        return this;
    }
    addChecked(data, callback) {
        if (this.options.type == 'radio') {
            console.error('Do not use this method of addChecked() in type of radio!');
            return false;
        }
        let trueData = [];
        if (Array.isArray(data)) {
            trueData = data;
        } else {
            trueData = [data];
        }
        trueData = trueData.filter(Boolean);
        for (let i = 0, len = trueData.length; i < len; i++) {
            if (this.intercept()) {
                break;
            }
            let item = trueData[i];
            let find = this.output.children.find(i => i.value == item);
            find.dom.querySelector('input').checked = true;
            find.checked = true;
            this.resetLimit();
        }
        this.output.value = this.getValues();
        this.hidden ? this.hidden.value = this.getValues('string', this.options.separator) : null;
        callback && callback.call(this, trueData, this.output);
        this.options.onAddChecked && this.options.onAddChecked.call(this, trueData, this.output);
        'addChecked' in this.handlers ? this.emit('addChecked', trueData, this.output) : null;
    }
    checkedAll(callback) {
        this.output.children.forEach(i => {
            i.dom.querySelector('input').checked = true;
            i.checked = true;
        });
        this.resetLimit();
        this.output.value = this.getValues();
        callback && callback.call(this, this.output);
        this.options.onCheckedAll && this.options.onCheckedAll.call(this, this.output);
        'checkedAll' in this.handlers ? this.emit('checkedAll', this.output) : null;
    }
    getValues(type, separator) {
        type = type || 'array';
        separator = separator || this.options.separator;
        let values = [];
        this.output.children.forEach(i => {
            if (i.checked) {
                if (type == 'json') {
                    values.push({ label: i.label, value: i.value });
                } else {
                    values.push(i.value);
                }
            }
        });
        if (type == 'string') {
            values = values.join(separator);
        }
        return values;
    }
    reset(callback) {
        let value;
        if (this.options.value) {
            value = this.options.value;
        } else {
            let checkedItem = this.options.children.filter(i => i.checked);
            value = [];
            checkedItem.forEach(i => {
                value.push(i.value);
            });
        }
        this.set(value);
        callback && callback.call(this, this.output);
        this.options.onReset && this.options.onReset.call(this, this.output);
        'reset' in this.handlers ? this.emit('reset', this.output) : null;
    }
    clear(callback) {
        this.output.children.forEach(i => {
            if (i.checked) {
                i.checked = false;
                i.dom.querySelector('input').checked = false;
            }
        });
        this.output.value = [];
        this.resetLimit();
        callback && callback.call(this, this.output);
        this.options.onClear && this.options.onClear.call(this, this.output);
        'clear' in this.handlers ? this.emit('clear', this.output) : null;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axCheckbox]').forEach(element => {
        new axCheckbox(element);
    });
})(); */
/*!
 * 插件：复选列表全选和取消全选；使用方法：new axCheckAll('#id',{参数})
 */
class axCheckAll {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        if (!this.targetDom) {
            return false;
        }
        this.options = axExtend({
            checkDom: '', 
            clearDom: '', 
            separator: ',', 
            includeDisabled: true,
            onInit: '', 
            onChecked: '', 
            onCheckAll: '', 
            onClearAll: '', 
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.checkDom = this.options.checkDom ? axIdToDom(this.options.checkDom) : '';
        this.clearDom = this.options.clearDom ? axIdToDom(this.options.clearDom) : '';
        this.list = [];
        this.listAvailable = [];
        this.toggleType = '';
        this.state = '';
        this.toggleBtns = [];
        this.name = '';
        this.init();
    }
    init() {
        this.getOptionsList();
        if (this.list.length === 0) {
            return false;
        }
        this.observeToggle();
        this.observeList();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    observeList() {
        this.setLinkage();
        this.listAvailable.forEach(i => {
            i.field.addEventListener('change', () => {
                this.setLinkage();
            }, false);
        });
    }
    observeToggle() {
        if (this.checkDom && this.checkDom.type === 'checkbox') {
            this.toggleType = 'checkbox';
            this.toggleBtns = [this.checkDom];
            if (this.checkDom.checked) {
                this.checkAll();
            }
            this.checkDom.addEventListener('change', () => {
                if (this.checkDom.checked) {
                    this.checkAll();
                } else {
                    this.clearAll();
                }
            }, false);
        } else if (this.checkDom && this.checkDom.type === 'radio') {
            this.toggleType = 'radio';
            this.toggleBtns = [...document.querySelectorAll(this.options.checkDom.replace('[', '[name='))];
            if (axMultiValues(this.options.checkDom, 'radio', 'string') == 1) {
                this.checkAll();
            }
            this.toggleBtns.forEach(i => {
                i.addEventListener('change', () => {
                    let value = axMultiValues(this.options.checkDom, 'radio', 'string');
                    if (value == 1) {
                        this.checkAll();
                    } else {
                        this.clearAll();
                    }
                }, false);
            });
        } else {
            this.toggleType = 'button';
            if (this.checkDom) {
                this.toggleBtns.push(this.checkDom);
                this.checkDom.onclick = () => {
                    this.checkAll();
                }
            }
            if (this.clearDom) {
                this.toggleBtns.push(this.clearDom);
                this.clearDom.onclick = () => {
                    this.clearAll();
                }
            }
        }
    }
    setLinkage() {
        let value = axMultiValues(this.name, 'checkbox', 'array');
        if (value.length === 0) {
            this.state = 'cleared';
            this.toggleBtns.forEach(i => {
                i.removeAttribute('checking');
            });
            if (this.checkDom && this.toggleType === 'checkbox') {
                this.checkDom.checked = false;
            } else if (this.toggleType = 'radio') {
                let radioChecked = this.toggleBtns.find(k => k.checked);
                if (radioChecked) {
                    radioChecked.checked = false;
                }
            }
            this.options.onClearAll && this.options.onClearAll.call(this);
            'clearAll' in this.handlers ? this.emit('clearAll', '') : null;
        } else if (value.length === this.listAvailable.length) {
            this.state = 'checked';
            this.toggleBtns.forEach(i => {
                i.removeAttribute('checking');
            });
            if (this.checkDom && this.toggleType === 'checkbox') {
                this.checkDom.checked = true;
            } else if (this.toggleType = 'radio') {
                let radio = this.toggleBtns.find(k => k.value == 1);
                if (radio) {
                    radio.checked = true;
                }
            }
            this.options.onCheckAll && this.options.onCheckAll.call(this);
            'checkAll' in this.handlers ? this.emit('checkAll', '') : null;
        } else {
            this.state = 'checking';
            if (this.checkDom && this.toggleType === 'checkbox') {
                this.checkDom.checked = false;
                this.checkDom.setAttribute('checking', '');
            } else if (this.toggleType = 'radio') {
                this.toggleBtns.forEach(i => {
                    i.checked ? i.checked = false : null;
                    i.value == 1 ? i.setAttribute('checking', '') : null;
                });
            }
        }
    }
    getOptionsList(all = this.options.includeDisabled) {
        [...this.targetDom.querySelectorAll('label')].forEach(i => {
            let field = i.querySelector('input');
            if (all) {
                this.list.push({ dom: i, field: field, name: field.name, value: field.value });
            } else {
                if (!i.field.disabled) {
                    this.list.push({ dom: i, field: field, name: field.name, value: field.value });
                }
            }
        });
        if (this.list.find(i => !i.name)) {
            console.error('Checkbox must have name attribute!');
        }
        if (this.list.some(i => i.name != this.list[0].name)) {
            console.error('All names need to be consistent!');
        }
        if (this.list.find(i => !i.value || !i.field.hasAttribute('value'))) {
            console.error('Checkbox must have a value!');
        }
        this.listAvailable = all ? this.list.filter(i => !i.field.disabled) : this.list;
        this.name = this.listAvailable[0].name;
        return this.list;
    }
    getValues(type, separator) {
        type = type || 'array';
        separator = separator || this.options.separator;
        let arr = this.list.filter(i => i.field.checked),
            valueArr = arr.map(i => i.field.value);
        if (type === 'string') {
            return valueArr.join(separator);
        } else if (type === 'array') {
            return valueArr;
        } else {
            return '';
        }
    }
    checked(values, callback) {
        let items = [];
        if (typeof values === 'string') {
            items = values.split(this.options.separator);
        } else if (Array.isArray(values)) {
            items = values;
        } else {
            return false;
        }
        items.forEach(i => {
            let item = this.list.find(k => k.value == i);
            item ? item.field.checked = true : null;
        });
        this.setLinkage();
        callback && callback.call(this, items);
        this.options.onChecked && this.options.onChecked.call(this, items);
        'checked' in this.handlers ? this.emit('checked', items) : null;
        return this;
    }
    checkAll(callback) {
        this.state = 'checked';
        this.list.forEach(i => {
            if (!i.field.disabled) {
                i.field.checked = true;
            }
        });
        this.toggleBtns.forEach(i => {
            i.removeAttribute('checking');
        });
        callback && callback.call(this);
        this.options.onCheckAll && this.options.onCheckAll.call(this);
        'checkAll' in this.handlers ? this.emit('checkAll', '') : null;
        return this;
    }
    clearAll(callback) {
        this.state = 'cleared';
        this.list.forEach(i => {
            if (i.field.checked) {
                i.field.checked = false;
            }
        });
        this.toggleBtns.forEach(i => {
            i.removeAttribute('checking');
        });
        callback && callback.call(this);
        this.options.onClearAll && this.options.onClearAll.call(this);
        'clearAll' in this.handlers ? this.emit('clearAll', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/* (() => {
    document.querySelectorAll('[axCheckAll]').forEach(element => {
        new axCheckAll(element);
    });
})(); */
/*!
 * 插件：创建表单；使用方法：new axForm([{}],'#id')
 */
class axForm {
    constructor(targetDom, obj) {
        this.targetDom = targetDom ? axIdToDom(targetDom) : null;
        this.form;
        this.output = [];
        this.handlers = {};
        if (this.targetDom) {
            if (this.targetDom.nodeName == 'FORM') {
                this.form = this.targetDom;
            } else {
                this.form = axAddElem('form');
                this.targetDom.appendChild(this.form);
            }
        } else {
            this.form = axAddElem('form');
        }
        this.init(obj);
        return this;
    }
    init(obj) {
        this.setAttribute(obj);
        obj.rows.forEach(i => {
            this.createSection(i, obj.style);
        });
        obj.onInit && obj.onInit.call(this, this.output);
        axInstance.push(this, obj.insName, 'form');
        return this;
    }
    createTpl(obj, style) {
        let title = '',
            separate = '',
            props = '';
        if (obj.title && obj.title.show) {
            if (obj.title.html) {
                title = obj.title.html;
            } else {
                title = `<div class="ax-form-label${obj.title.className ? ' ' + obj.title.className : ''}">${obj.title.text ? obj.title.text : ''}</div>`;
            }
        }
        if (style == 'emulate') {
            separate = `<div class="ax-break-line"></div>`;
        } else if (style == 'fit') {
            separate = `<div class="ax-break ax-hide-tel"></div><div class="ax-break-line ax-hide-pad ax-hide-pc"></div>`;
        } else {
            separate = `<div class="ax-break"></div>`;
        }
        if (!axIsEmpty(obj.props)) {
            for (let i in obj.props) {
                props += ` ${i}="${obj.props[i]}" `;
            }
        }
        return `
                    <section${props}>
                    ${obj.before || ''}
                        <div class="ax-form-group">
                            <div class="ax-flex-row">
                                ${title}
                                <div class="ax-form-con">
                                    <div class="ax-form-input"></div>
                                </div>
                                ${obj.tools ? obj.tools : ''}
                            </div>
                        </div>
                        ${obj.after || ''}
                        ${separate}
                    </section >
                    `;
    }
    setAttribute(obj) {
        if (obj.style == 'emulate') {
            this.form.classList.add('ax-emulate');
        } else if (obj.style == 'fit') {
            this.form.classList.add('ax-fit-tel');
        }
        obj.className ? this.form.classList.add(obj.className) : null;
        if (!axIsEmpty(obj.props)) {
            for (let i in obj.props) {
                this.form.setAttribute(i, obj.props[i])
            }
        }
    }
    createCols(cols, parent, display, columns, gap, callback) {
        cols.forEach(i => {
            let colDiv, field;
            if (display == 'grid') {
                parent.classList.add('ax-grid');
                colDiv = axAddElem('div');
                columns ? parent.classList.add('ax-grid-' + columns) : null;
                parent.style.gridGap = gap;
                field = colDiv;
                parent.appendChild(colDiv);
                callback(i, colDiv);
            } else if (display == 'flex') {
                parent.classList.add('ax-row');
                colDiv = axAddElem('div', { class: 'ax-col' });
                field = colDiv;
                parent.appendChild(colDiv);
                callback(i, colDiv);
            } else {
                colDiv = parent;
                field = callback(i, colDiv);
            }
            i.prefix ? field.insertAdjacentHTML('beforebegin', i.prefix) : null;
            i.suffix ? field.insertAdjacentHTML('afterend', i.suffix) : null;
        });
    };
    createSection(obj, style) {
        let section = axStrToDom(this.createTpl(obj, style)),
            wrapper = section.querySelector('.ax-form-input');
        if (axIsEmpty(obj.cols)) {
            this.createItem(obj, wrapper);
        } else {
            this.createCols(obj.cols, wrapper, obj.display, obj.columns, obj.gap, (item, parent) => {
                return this.createItem(item, parent);
            });
        }
        this.form.appendChild(section);
    }
    createItem(obj, parent) {
        let field,
            item = {};
        if (obj.type == 'select') {
            field = axAddElem('select', { name: obj.name || '', ...obj.props });
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
            if (obj.options && obj.options.length > 0) {
                obj.options.forEach(i => {
                    let opt = axAddElem('option', { value: i.value || '' }, i.label);
                    i.checked ? opt.setAttribute('selected', '') : null;
                    i.disabled ? opt.setAttribute('disabled', '') : null;
                    field.appendChild(opt);
                    i.callback && i.callback.call(this, opt, i);
                });
            }
        } else if (obj.type == 'radio') {
            for (let i in obj.props) {
                parent.setAttribute(i, obj.props[i]);
            }
            if (obj.className) {
                parent.setAttribute('class', obj.className);
            }
            field = [];
            this.createCols(obj.options, parent, obj.display, obj.columns, obj.gap, (i, p) => {
                let item = axAddElem('input', { type: 'radio', name: obj.name || '', value: i.value || '' }),
                    label = axAddElem('label', { class: 'ax-radio' }, `<u></u><i> ${i.label}</i>`);
                i.checked ? item.checked = true : null;
                i.disabled ? item.disabled = true : null;
                label.insertAdjacentElement('afterBegin', item);
                p.appendChild(label);
                field.push(item);
                return label;
            });
        } else if (obj.type == 'checkbox') {
            for (let i in obj.props) {
                parent.setAttribute(i, obj.props[i]);
            }
            if (obj.className) {
                parent.setAttribute('class', obj.className);
            }
            field = [];
            this.createCols(obj.options, parent, obj.display, obj.columns, obj.gap, (i, p) => {
                let item = axAddElem('input', { type: 'checkbox', name: obj.name || '', value: i.value || '' }),
                    label = axAddElem('label', { class: 'ax-checkbox' }, `<u></u><i> ${i.label}</i>`);
                i.checked ? item.checked = true : null;
                i.disabled ? item.disabled = true : null;
                label.insertAdjacentElement('afterBegin', item);
                p.appendChild(label);
                field.push(item);
                return label;
            });
        } else if (obj.type == 'html') {
            field = axAddElem('div', obj.props, obj.value || '');
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
        } else if (obj.type == 'a') {
            field = axAddElem('a', obj.props, obj.value || '');
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
        } else if (obj.type == 'button') {
            field = axAddElem('button', obj.props, obj.value || '');
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
        } else if (obj.type == 'textarea') {
            field = axAddElem('textarea', { name: obj.name || '', value: obj.value || '', ...obj.props });
            obj.readonly ?  field.readonly = true : null;
            obj.disabled ?  field.disabled = true : null;
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            obj.placeholder ? field.setAttribute('placeholder',obj.placeholder) : null;
            parent.appendChild(field);
        } else {
            field = axAddElem('input', { type: obj.type, name: obj.name || '', value: obj.value || '', ...obj.props });
            obj.readonly ?  field.readonly = true : null;
            obj.disabled ?  field.disabled = true : null;
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            obj.placeholder ? field.setAttribute('placeholder',obj.placeholder) : null;
            parent.appendChild(field);
        }
        item.name = obj.name || '';
        item.value = obj.value || '';
        item.field = field;
        item.parent = parent;
        this.output.push(item);
        obj.callback && obj.callback.call(this, item);
        return field;
    }
    get(type = 'string', separator = ',') {
        let inputs = [];
        this.output.forEach(i => {
            inputs.push(i.field);
        });
        inputs = inputs.flat(2).filter(i => ['INPUT', 'SELECT', 'TEXTAREA'].includes(i.nodeName) && i.name);
        return axSerialize(inputs, type, separator);
    }
    update(obj, callback) {
        this.form.innerHTML = '';
        this.output = [];
        this.init(obj);
         obj.onUpdate && obj.onUpdate.call(this, this.output);
        callback && callback.call(this, this.output);
        'updated' in this.handlers ? this.emit('updated', this.output) : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：表单标题避让；使用方法：new axDodge('#id',{参数})
*/
class axDodge {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        if (!this.targetDom) { return false; }
        this.inputDom = this.targetDom.querySelector("input,textarea");
        if (!this.inputDom) { return false; }
        this.options = axExtend({
            insName: '',
            placeholder: '请输入...',
            onInit: '',
            onSet: '',
            onClear: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.isFocus = false;
        this.focusEvent = () => {
            this.inputDom.focus();
            this.targetDom.classList.add("ax-active");
            this.inputDom.removeAttribute('readonly');
            this.isFocus = true;
        }
        this.blurEvent = () => {
            this.inputDom.blur();
            if (!this.inputDom.value) {
                this.targetDom.classList.remove("ax-active");
            } else {
                this.targetDom.classList.add("ax-active");
            }
            this.inputDom.setAttribute('readonly', '');
            this.isFocus = false;
        }
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'dodge');
        this.setAttribute();
        this.labelDom = axAddElem('label');
        let placeholder = this.inputDom.getAttribute("placeholder");
        if (placeholder) {
            this.labelDom.innerHTML = placeholder;
            this.inputDom.removeAttribute("placeholder");
        } else {
            this.labelDom.innerHTML = this.options.placeholder;
        }
        this.targetDom.appendChild(this.labelDom);
        this.inputDom.addEventListener('focus', this.focusEvent, false);
        this.inputDom.addEventListener('blur', this.blurEvent, false);
        this.labelDom.onclick = () => {
            this.focusEvent();
        };
        this.inputDom.value ? this.focusEvent() : null;
        this.handlers.hasOwnProperty('init') ? this.emit('init', '') : null;
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    setAttribute() {
        this.inputDom.setAttribute('readonly', '');
        this.inputDom.classList.contains("ax-lg") ? this.targetDom.classList.add("ax-lg") : null;
        !this.targetDom.classList.contains('ax-dodge') ? this.targetDom.classList.add('ax-dodge') : null;
    }
    set(value, callback) {
        if (value) {
            this.inputDom.value = value;
            this.focusEvent();
        } else {
            this.inputDom.focus();
        }
        this.options.onSet && this.options.onSet.call(this, value);
        this.handlers.hasOwnProperty('set') ? this.emit('set', value) : null;
        callback && callback.call(this, value);
        return this;
    }
    clear(callback) {
        this.inputDom.value = '';
        this.inputDom.blur();
        this.blurEvent();
         this.options.onClear && this.options.onClear.call(this);
         this.handlers.hasOwnProperty('clear') ? this.emit('clear', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：操作面板；使用方法：new axPanel('#id',{参数})
*/
class axPanel {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        if (!this.targetDom) { return false; }
        this.options = axExtend({
            insName: '',
            type: 'panel',
            display: '',
            expanded: true,
            headerClosable: false,
            arrow: {
                enable: true,
                rotate: 180,
                iconClose: 'ax-icon-down',
                iconOpen: 'ax-icon-down',
                position: 'end',
            },
            onInit: '',
            onCollapsed: '',
            onExpanded: '',
            onRemove: '',
            onRestore: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.location = { parent: this.targetDom.parentElement, brother: this.targetDom.nextElementSibling };
        this.expanded = true;
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'panel');
        this.headerDom = this.targetDom.querySelector(`.ax-panel-header`);
        this.bodyDom = this.targetDom.querySelector(`.ax-panel-body`);
        if (this.headerDom.querySelector('[arrow]')) {
            this.arrowDom = this.headerDom.querySelector('[arrow]');
        } else {
            if (this.options.arrow.enable) {
                this.arrowDom = axAddElem('i', { arrow: '', class: `ax-iconfont ${this.options.arrow.iconOpen}` });
                if (this.options.arrow.position === 'begin') {
                    this.headerDom.insertAdjacentElement('afterbegin', this.arrowDom);
                } else if (this.options.arrow.position === 'end') {
                    this.headerDom.insertAdjacentElement('beforeend', this.arrowDom);
                }
            }
        }
        this.setAttribute();
        if (this.options.expanded && !axIsVisible(this.bodyDom)) {
            this.expand();
        } else if (!this.options.expanded && axIsVisible(this.bodyDom)) {
            this.collapse();
        }
        if (this.options.headerClosable) {
            this.headerDom.onclick = () => {
                if (axIsVisible(this.bodyDom)) {
                    this.collapse();
                } else {
                    this.expand();
                }
            }
        } else {
            if (this.arrowDom) {
                this.arrowDom.onclick = () => {
                    if (axIsVisible(this.bodyDom)) {
                        this.collapse();
                    } else {
                        this.expand();
                    }
                };
            }
        }
        this.handlers.hasOwnProperty('init') ? this.emit('init', '') : null;
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    setAttribute() {
        !this.targetDom.classList.contains(`ax-panel`) ? this.targetDom.classList.add(`ax-panel`) : null;
        if (this.targetDom.getAttribute('type') === 'box') {
            this.options.type = 'box';
        } else {
            this.options.type === 'box' ? this.targetDom.setAttribute('type', this.options.type) : null;
        }
        this.options.lamp ? this.targetDom.setAttribute('lamp', this.options.lamp) : null;
        this.options.headerClosable ? this.targetDom.setAttribute('headerClosable', '') : null;
    }
    expand(callback) {
        if (this.expanded) {
            return false;
        }
        if (this.arrowDom) {
            if (this.options.arrow.iconClose === this.options.arrow.iconOpen) {
                this.arrowDom.classList.remove(`ax-deg${this.options.arrow.rotate}`);
            } else {
                this.arrowDom.classList.remove(this.options.arrow.iconClose);
                this.arrowDom.classList.add(this.options.arrow.iconOpen);
            }
        }
        axSlideDown(this.bodyDom, this.options.display, () => {
            this.expanded = true;
            this.options.onExpanded && this.options.onExpanded.call(this);
            this.handlers.hasOwnProperty('expanded') ? this.emit('expanded', '') : null;
        });
        callback && callback.call(this);
    }
    collapse(callback) {
        if (!this.expanded) {
            return false;
        }
        if (this.arrowDom) {
            if (this.options.arrow.iconClose === this.options.arrow.iconOpen) {
                this.arrowDom.classList.add(`ax-deg${this.options.arrow.rotate}`);
            } else {
                this.arrowDom.classList.remove(this.options.arrow.iconOpen);
                this.arrowDom.classList.add(this.options.arrow.iconClose);
            }
        }
        axSlideUp(this.bodyDom, this.options.display, () => {
            this.expanded = false;
            this.options.onCollapsed && this.options.onCollapsed.call(this);
            this.handlers.hasOwnProperty('collapsed') ? this.emit('collapsed', '') : null;
        });
        callback && callback.call(this);
    }
    remove(callback) {
        if (axIsVnode(this.targetDom)) {
            return false;
        }
        this.targetDom.remove();
        this.options.onRemove && this.options.onRemove.call(this);
        this.handlers.hasOwnProperty('remove') ? this.emit('remove', '') : null;
        callback && callback.call(this);
    }
    restore(callback) {
        if (!axIsVnode(this.targetDom)) {
            return false;
        }
        if (this.location.brother) {
            this.location.brother.insertAdjacentElement('beforebegin', this.targetDom);
        } else {
            this.location.parent.appendChild(this.targetDom);
        }
        this.options.onRestore && this.options.onRestore.call(this);
        this.handlers.hasOwnProperty('restore') ? this.emit('restore', '') : null;
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：光晕特效；使用方法：new axRipple('#id',{参数})
*/
class axRipple {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        if (!this.targetDom) { return false; }
        this.options = axExtend({
            insName: '',
            duration: 0,
            removeTime: 800,
            theme: 'dark',
        }, options, this.targetDom, this.constructor.name);
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'ripple');
        !this.targetDom.classList.contains(`ax-ripple`) ? this.targetDom.classList.add(`ax-ripple`) : null;
        this.targetDom.setAttribute('theme',this.options.theme);
        let width = axWidth(this.targetDom, 'inner'),
            height = axHeight(this.targetDom, 'inner'),
            size = Math.max(width, height);
        this.targetDom.addEventListener('click',  (e)=> {
            let x = e.clientX - (axOffset(this.targetDom).left - document.documentElement.scrollLeft),
                y = e.clientY - (axOffset(this.targetDom).top - document.documentElement.scrollTop),
                ripple = axAddElem('u', {
                    style: `left: ${x}px;top: ${y}px; width: ${size}px;height: ${size}px${this.options.duration ? ';animation-duration:' + this.options.duration + 'ms' : ''}`,
                    class: this.options.theme,
                });
            this.targetDom.appendChild(ripple);
            setTimeout(() => {
                ripple.parentNode.removeChild(ripple);
            }, this.options.removeTime);
        }, false);
        return this;
    }
}
/*!
* 插件：光晕特效；使用方法：new axShortcut('#id',{参数})
*/
class axShortcut {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        if (!this.targetDom) { return false; }
        this.options = axExtend({
            insName: '',
            shape: '',
            placement: 'right-bottom',
            gap: {
                side: '',
                bottom: '',
                top: '',
            },
            size: '',
            threshold: 400,
            scrollTo: 0,
            onInit: '',
        }, options, this.targetDom, this.constructor.name);
        this.totopEvent = () => {
            let btn = this.totop.querySelector('a'),
                scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
            if (scrollTop >= this.options.threshold) {
                btn.classList.add('ax-show');
            } else {
                btn.classList.remove('ax-show');
            }
        }
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'shortcut');
        this.setAttribute();
        this.children = [...this.targetDom.children];
        if (this.children.length === 0) {
            return false;
        }
        this.totop = this.targetDom.querySelector('[totop]');
        for (let v of this.children) {
            let pop = v.querySelector('[pop]');
            new axHover(v, {
                enter: () => {
                    v.classList.add('ax-active');
                    if (pop) { axFadeIn(pop); }
                },
                leave: () => {
                    v.classList.remove('ax-active');
                    if (pop) { axFadeOut(pop); }
                }
            });
        }
        if (this.totop) {
            this.totop.addEventListener('click', () => {
                axScrollTo(this.options.scrollTo);
            }, false);
            window.addEventListener("scroll", this.totopEvent, false);
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    setAttribute() {
        !this.targetDom.classList.contains(`ax-shortcut`) ? this.targetDom.classList.add(`ax-shortcut`) : null;
        this.options.shape ? this.targetDom.setAttribute('shape', this.options.shape) : null;
        this.options.placement ? this.targetDom.setAttribute('placement', this.options.placement) : null;
        this.options.size ? this.targetDom.setAttribute('size', this.options.size) : null;
        if (this.options.gap.side) {
            if (this.options.placement.includes('left')) {
                this.targetDom.style.left = this.options.gap.side;
                this.targetDom.style.right = 'auto';
            } else {
                this.targetDom.style.right = this.options.gap.side;
            }
        }
        if (this.options.gap.bottom) {
            if (this.options.placement.includes('bottom')) {
                this.targetDom.style.bottom = this.options.gap.bottom;
            }
        }
        if (this.options.gap.top) {
            this.targetDom.style.top = this.options.gap.top;
            this.targetDom.style.bottom = 'auto';
        }
    }
}
/*!
* 插件：元素进入视窗监听；使用方法：new axSpy('#id',{参数})
*/
class axSpy {
    constructor(elem, options) {
        if (axIsEmpty(elem)) {
            return false;
        }
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            offset: '0px', 
            visible: [0, 0.5, 1], 
            parent: null,
            distance: 0,
            spySelector: '',
            navSelector: '',
            btnSelector: '',
            duration: 0,
            interval: 500,
            repeat: true,
            active: '',
            in: '',
            out: '',
            rel: '',
            onBefore: '',
            onShow: '',
            onShowing: '',
            onShown: '',
            onIn: '',
            onOut: '',
            onAdd: '',
            onRemove: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.navDom = this.options.navSelector ? axIdToDom(this.options.navSelector) : null;
        this.btnDoms = this.navDom && this.options.btnSelector ? this.navDom.querySelectorAll(this.options.btnSelector) : [];
        this.items = [];
        this.parentDom = this.options.parent ? axIdToDom(this.options.parent) : this.options.parent;
        if (this.options.active.trim().startsWith('[') && this.options.active.trim().endsWith(']')) {
            this.isAttr = true;
            this.active = this.options.active.replace('[', '').replace(']', '').replace(' ', '');
        } else {
            this.activeIsAttr = false;
            this.active = this.options.active;
        }
        this.init();
        return this;
    }
    init() {
        axInstance.push(this, this.options.insName, 'spy');
        this.interactOpt();
        this.interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                let args = [i.target, i.target.spy, i];
                if (i.isIntersecting) {
                    if (i.target.spy.in) {
                        axClass.add(i.target, i.target.spy.in, (name) => {
                            return i.target.classList.contains(name) ? false : true;
                        });
                    }
                    if (i.intersectionRatio === 0) {
                        i.target.spy.state = 'show';
                        this.handlers.hasOwnProperty('show') ? this.emit('show', ...args) : null;
                        this.options.onShow && this.options.onShow.call(this, ...args);
                    } else if (i.intersectionRatio === 1) {
                        i.target.spy.state = 'shown';
                        this.handlers.hasOwnProperty('shown') ? this.emit('shown', ...args) : null;
                        this.options.onShown && this.options.onShown.call(this, ...args);
                        this.setActiveOnly(i.target);
                        if (!this.options.repeat) {
                            this.interact.unobserve(i.target);
                        }
                    } else {
                        i.target.spy.state = 'showing';
                        this.handlers.hasOwnProperty('showing') ? this.emit('showing', ...args) : null;
                        this.options.onShowing && this.options.onShowing.call(this, ...args);
                    }
                    this.handlers.hasOwnProperty('in') ? this.emit('in', ...args) : null;
                    this.options.onIn && this.options.onIn.call(this, ...args);
                } else {
                    i.target.spy.state = 'hidden';
                    if (this.options.repeat) {
                        axDebounce(() => {
                            if (i.target.spy.out) {
                                axClass.add(i.target, i.target.spy.out);
                            }
                            if (i.target.spy.in) {
                                axClass.del(i.target, i.target.spy.in);
                            }
                            if (this.active) {
                                i.target.spy.rel.forEach(k => {
                                    this.isAttr ? k.removeAttribute(this.active) : axClass.del(k, this.active);
                                });
                            }
                        }, this.options.interval)();
                    }
                    this.handlers.hasOwnProperty('out') ? this.emit('out', ...args) : null;
                    this.options.onOut && this.options.onOut.call(this, ...args);
                }
            });
        }, this.interactOpt());
        if (this.options.spySelector) {
            this.items = [...this.targetDom.querySelectorAll(this.options.spySelector)];
        } else {
            this.items.push(this.targetDom);
        }
        let flag = this.options.onBefore ? this.options.onBefore.call(this, this.items) : true;
        if (flag) {
            this.items.forEach(k => {
                this.setSpyAttr(k);
                this.interact.observe(k);
            });
        }
        return this;
    }
    setActiveOnly(dom) {
        if (this.active) {
            dom.spy.rel.forEach(k => {
                if (this.isAttr) {
                    k.setAttribute(this.active, '');
                } else {
                    axClass.add(k, this.active, (name) => {
                        return k.classList.contains(name) ? false : true;
                    });
                }
            });
            let other = this.items.filter(k => k !== dom && k.spy),
                otherRels = other.map(k => k.spy.rel).flat(Infinity);
            otherRels.forEach(k => {
                this.isAttr ? k.removeAttribute(this.active) : axClass.del(k, this.active);
            });
        }
    }
    setSpyAttr(dom) {
        if (!axType(dom).includes('HTML')) {
            return false;
        }
        let attrs = axAttrToJson(dom, 'spy');
        dom.spy = {
            observed: true,
            rel: this.getRels(dom),
            in: attrs.in || this.options.in,
            out: attrs.out || this.options.out,
        }
    }
    getRels(dom) {
        let arrFromId = [], arrFromSpy = [], arrFromOpt = [], relArr = [];
        if (dom.id) {
            if (this.btnDoms.length > 0 && this.btnDoms[0].hasAttribute('href')) {
                let navRel = this.btnDoms.find(k => k.getAttribute('href') === `#${k.id}`);
                navRel ? arrFromId.push(navRel) : null;
            } else {
                arrFromId = [...document.querySelectorAll(`[href='#${dom.id}']`)];
            }
        } else {
            let index = this.items.findIndex(k => k == dom);
            index !== -1 && this.btnDoms[index] ? arrFromId.push(this.btnDoms[index]) : null;
        }
        if (dom.hasAttribute('spy')) {
            let attrs = axAttrToJson(dom, 'spy');
            if (attrs.rel) {
                arrFromSpy = axAllToDoms(attrs.rel);
            }
        }
        if (this.options.rel) {
            arrFromOpt = axAllToDoms(this.options.rel);
        }
        relArr = [...arrFromId, ...arrFromSpy, ...arrFromOpt].filter(Boolean);
        relArr.forEach(k => {
            k.onclick = (e) => {
                axPreventDefault(e);
                axScrollTo(dom, { parent: this.parentDom, duration: this.options.duration, offset: this.options.distance });
            }
        });
        return relArr;
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.parentDom,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    getDoms(data) {
        let dataType = axType(data),
            doms = [];
        if (dataType === 'Array') {
            doms = data.map(k => axIdToDom(k)).filter(Boolean);
        } else if (dataType === 'String') {
            doms = axAllToDoms(data).filter(Boolean);
        }
        return doms;
    }
    add(data, callback) {
        let doms = this.getDoms(data);
        doms.forEach(i => {
            if (!i.spy) {
                this.setSpyAttr(i);
                this.interact.observe(i);
                !this.items.includes(i) ? this.items.push(i) : null;
            } else {
                new axMessage({
                    content: `媒体文件${i.dataset.src || i.src}已经处于监听状态，不需要添加监听操作！`,
                    iconShow: true,
                    result: 'warning',
                }).show();
            }
        });
        this.handlers.hasOwnProperty('add') ? this.emit('add', doms) : null;
        this.options.onAdd && this.options.onAdd.call(this, doms);
        callback && callback.call(this, doms);
    }
    remove(data, callback) {
        let doms = this.getDoms(data);
        doms.forEach(i => {
            if (this.items.includes(i)) {
                if (i.spy) {
                    Reflect.deleteProperty(i, 'spy');
                    this.interact.unobserve(i);
                } else {
                    new axMessage({
                        content: `媒体文件${i.dataset.src || i.src}还未被监听，不需要取消监听操作！`,
                        iconShow: true,
                        result: 'warning',
                    }).show();
                }
            }
        });
        this.handlers.hasOwnProperty('remove') ? this.emit('remove', doms) : null;
        this.options.onRemove && this.options.onRemove.call(this, doms);
        callback && callback.call(this, doms);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
*项目所需的立即执行的代码片段，避免污染全局变量
*/
const axInit = (type, dom = document) => {
    let parent = axIdToDom(dom);
    if (axIsEmpty(type) || type.includes('other')) {
        let posLefts = [...parent.querySelectorAll('.ax-pos-left')];
        for (let k of posLefts) {
            if (k.nextElementSibling.nodeName == 'INPUT' || k.nextElementSibling.nodeName == 'TEXTAREA') {
                k.nextElementSibling.style.paddingLeft = `${axWidth(k, 'outer') / 10}rem`;
            }
        }
        let posRights = [...parent.querySelectorAll('.ax-pos-right [clear]')].filter(k => !k.clear),
            clearFun = function () {
                let elem = this.parentElement.previousElementSibling;
                if (elem.nodeName == 'INPUT' || elem.nodeName == 'TEXTAREA') {
                    elem.value = '';
                }
            };
        for (let k of posRights) {
            k.clear = true;
            k.addEventListener('click', clearFun, false);
        }
    }
    let moduleNodeList = [],
        allModules = [
            'axAccordion', 'axAlert', 'axAmount', 'axCheckbox', 'axCheckAll', 'axComplete',
            'axDate', 'axDialog', 'axDodge', 'axDrawer', 'axDropdown', 'axInfinite', 'axInput',
            'axLazyload', 'axList', 'axMenu', 'axMore', 'axPanel', 'axPagination', 'axPopup',
            'axProgress', 'axRange', 'axRipple', 'axSelect', 'axShare', 'axShortcut','axSpy', 'axStick', 'axSwiper',
            'axTab', 'axTags', 'axTooltip', 'axUpload', 'axTree', 'axRate'
        ],
        getNodeList = (arg) => {
            if (!axIsEmpty(arg)) {
                arg = arg.map(k => !k.startsWith('ax') ? 'ax' + k.slice(0, 1).toUpperCase() + k.slice(1) : k);
            }
            let modules = arg || allModules,
                modulesStr = modules.map(k => `[${k}]`).join(','),
                modulesDoms = [...parent.querySelectorAll(modulesStr)],
                modulesNodes = modules.map(k => {
                    let items = modulesDoms.filter(i => i.attributes.hasOwnProperty(k.toLowerCase()) && !i[k]);
                    return { module: k, nodeList: items }
                });
            return modulesNodes;
        },
        activeFun = (nodes) => {
            for (let v of nodes) {
                if (v.nodeList.length === 0) {
                    continue;
                }
                if (['axDialog', 'axDrawer', 'axPopup'].includes(v.module)) {
                    higherParent(v.module, v.nodeList);
                } else {
                    let funStr = `dom`;
                    if (v.module === 'axMessage') {
                        funStr = '';
                    } else if (v.module === 'axSwiper') {
                        funStr = `dom,axAttrToJson(dom, 'axSwiper')`;
                    }
                    v.nodeList.forEach(k => {
                        let instance = new Function('dom', `try {return new ${v.module}(${funStr})} catch(e) {}`)(k);
                        instance ? k[v.module] = true : null;
                    });
                }
            }
        },
        higherParent = (module, nodes) => {
            let eachInstance = (arr, parent) => {
                arr.forEach(k => {
                    let instance, funStr = `dom`;
                    if (module === 'axDialog' || module === 'axDrawer') {
                        funStr = `'',dom`;
                    }
                    instance = new Function('dom', `try {return new ${module}(${funStr})} catch(e) {}`)(k); 
                    instance ? k[module] = true : null;
                    parent && instance ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
                    let children = instance.content.querySelectorAll(`[${module}]`);
                    children.length > 0 ? eachInstance(children, instance) : null;
                });
            }
            eachInstance(nodes);
        }
    if (!axIsEmpty(type)) {
        let moduleType = axType(type);
        if (moduleType === 'String') {
            type !== 'other' ? moduleNodeList = getNodeList([type]) : null;
        } else if (moduleType === 'Array') {
            type = type.filter(k => k !== 'other');
            moduleNodeList = getNodeList(type);
        }
    } else {
        moduleNodeList = getNodeList();
    }
    moduleNodeList.length > 0 ? activeFun(moduleNodeList) : null;
}
axInit();